package org.llvm.binding;
import java.util.Collections;
import java.util.Iterator;
import org.bridj.BridJ;
import org.bridj.CRuntime;
import org.bridj.Callback;
import org.bridj.FlagSet;
import org.bridj.IntValuedEnum;
import org.bridj.Pointer;
import org.bridj.SizeT;
import org.bridj.TypedPointer;
import org.bridj.ann.Library;
import org.bridj.ann.Name;
import org.bridj.ann.Ptr;
import org.bridj.ann.Runtime;
/**
 * Wrapper for library <b>LLVM</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("LLVM-4.0") 
@Runtime(CRuntime.class) 
public class LLVMLibrary {
	static {
		BridJ.register();
	}
	/** enum values */
	public enum LLVMAttribute implements IntValuedEnum<LLVMAttribute > {
		LLVMZExtAttribute(1 << 0),
		LLVMSExtAttribute(1 << 1),
		LLVMNoReturnAttribute(1 << 2),
		LLVMInRegAttribute(1 << 3),
		LLVMStructRetAttribute(1 << 4),
		LLVMNoUnwindAttribute(1 << 5),
		LLVMNoAliasAttribute(1 << 6),
		LLVMByValAttribute(1 << 7),
		LLVMNestAttribute(1 << 8),
		LLVMReadNoneAttribute(1 << 9),
		LLVMReadOnlyAttribute(1 << 10),
		LLVMNoInlineAttribute(1 << 11),
		LLVMAlwaysInlineAttribute(1 << 12),
		LLVMOptimizeForSizeAttribute(1 << 13),
		LLVMStackProtectAttribute(1 << 14),
		LLVMStackProtectReqAttribute(1 << 15),
		LLVMAlignment(31 << 16),
		LLVMNoCaptureAttribute(1 << 21),
		LLVMNoRedZoneAttribute(1 << 22),
		LLVMNoImplicitFloatAttribute(1 << 23),
		LLVMNakedAttribute(1 << 24),
		LLVMInlineHintAttribute(1 << 25),
		LLVMStackAlignment(7 << 26),
		LLVMReturnsTwice(1 << 29),
		LLVMUWTable(1 << 30),
		LLVMNonLazyBind(1 << 31);
		LLVMAttribute(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMAttribute > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMAttribute > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/** enum values */
	public enum LLVMOpcode implements IntValuedEnum<LLVMOpcode > {
		LLVMRet(1),
		LLVMBr(2),
		LLVMSwitch(3),
		LLVMIndirectBr(4),
		LLVMInvoke(5),
		LLVMUnreachable(7),
		LLVMAdd(8),
		LLVMFAdd(9),
		LLVMSub(10),
		LLVMFSub(11),
		LLVMMul(12),
		LLVMFMul(13),
		LLVMUDiv(14),
		LLVMSDiv(15),
		LLVMFDiv(16),
		LLVMURem(17),
		LLVMSRem(18),
		LLVMFRem(19),
		LLVMShl(20),
		LLVMLShr(21),
		LLVMAShr(22),
		LLVMAnd(23),
		LLVMOr(24),
		LLVMXor(25),
		LLVMAlloca(26),
		LLVMLoad(27),
		LLVMStore(28),
		LLVMGetElementPtr(29),
		LLVMTrunc(30),
		LLVMZExt(31),
		LLVMSExt(32),
		LLVMFPToUI(33),
		LLVMFPToSI(34),
		LLVMUIToFP(35),
		LLVMSIToFP(36),
		LLVMFPTrunc(37),
		LLVMFPExt(38),
		LLVMPtrToInt(39),
		LLVMIntToPtr(40),
		LLVMBitCast(41),
		LLVMAddrSpaceCast(60),
		LLVMICmp(42),
		LLVMFCmp(43),
		LLVMPHI(44),
		LLVMCall(45),
		LLVMSelect(46),
		LLVMUserOp1(47),
		LLVMUserOp2(48),
		LLVMVAArg(49),
		LLVMExtractElement(50),
		LLVMInsertElement(51),
		LLVMShuffleVector(52),
		LLVMExtractValue(53),
		LLVMInsertValue(54),
		LLVMFence(55),
		LLVMAtomicCmpXchg(56),
		LLVMAtomicRMW(57),
		LLVMResume(58),
		LLVMLandingPad(59),
		LLVMCleanupRet(61),
		LLVMCatchRet(62),
		LLVMCatchPad(63),
		LLVMCleanupPad(64),
		LLVMCatchSwitch(65);
		LLVMOpcode(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMOpcode > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMOpcode > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/** enum values */
	public enum LLVMTypeKind implements IntValuedEnum<LLVMTypeKind > {
		/** < type with no size */
		LLVMVoidTypeKind(0),
		/** < 16 bit floating point type */
		LLVMHalfTypeKind(1),
		/** < 32 bit floating point type */
		LLVMFloatTypeKind(2),
		/** < 64 bit floating point type */
		LLVMDoubleTypeKind(3),
		/** < 80 bit floating point type (X87) */
		LLVMX86_FP80TypeKind(4),
		/** < 128 bit floating point type (112-bit mantissa) */
		LLVMFP128TypeKind(5),
		/** < 128 bit floating point type (two 64-bits) */
		LLVMPPC_FP128TypeKind(6),
		/** < Labels */
		LLVMLabelTypeKind(7),
		/** < Arbitrary bit width integers */
		LLVMIntegerTypeKind(8),
		/** < Functions */
		LLVMFunctionTypeKind(9),
		/** < Structures */
		LLVMStructTypeKind(10),
		/** < Arrays */
		LLVMArrayTypeKind(11),
		/** < Pointers */
		LLVMPointerTypeKind(12),
		/** < SIMD 'packed' format, or other vector type */
		LLVMVectorTypeKind(13),
		/** < Metadata */
		LLVMMetadataTypeKind(14),
		/** < X86 MMX */
		LLVMX86_MMXTypeKind(15),
		/** < Tokens */
		LLVMTokenTypeKind(16);
		LLVMTypeKind(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMTypeKind > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMTypeKind > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/** enum values */
	public enum LLVMLinkage implements IntValuedEnum<LLVMLinkage > {
		/** < Externally visible function */
		LLVMExternalLinkage(0),
		LLVMAvailableExternallyLinkage(1),
		/** < Keep one copy of function when linking (inline) */
		LLVMLinkOnceAnyLinkage(2),
		/**
		 * < Same, but only replaced by something<br>
		 * equivalent.
		 */
		LLVMLinkOnceODRLinkage(3),
		/** < Obsolete */
		LLVMLinkOnceODRAutoHideLinkage(4),
		/** < Keep one copy of function when linking (weak) */
		LLVMWeakAnyLinkage(5),
		/**
		 * < Same, but only replaced by something<br>
		 * equivalent.
		 */
		LLVMWeakODRLinkage(6),
		/** < Special purpose, only applies to global arrays */
		LLVMAppendingLinkage(7),
		/**
		 * < Rename collisions when linking (static<br>
		 * functions)
		 */
		LLVMInternalLinkage(8),
		/** < Like Internal, but omit from symbol table */
		LLVMPrivateLinkage(9),
		/** < Obsolete */
		LLVMDLLImportLinkage(10),
		/** < Obsolete */
		LLVMDLLExportLinkage(11),
		/** < ExternalWeak linkage description */
		LLVMExternalWeakLinkage(12),
		/** < Obsolete */
		LLVMGhostLinkage(13),
		/** < Tentative definitions */
		LLVMCommonLinkage(14),
		/** < Like Private, but linker removes. */
		LLVMLinkerPrivateLinkage(15),
		/** < Like LinkerPrivate, but is weak. */
		LLVMLinkerPrivateWeakLinkage(16);
		LLVMLinkage(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMLinkage > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMLinkage > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/** enum values */
	public enum LLVMVisibility implements IntValuedEnum<LLVMVisibility > {
		/** < The GV is visible */
		LLVMDefaultVisibility(0),
		/** < The GV is hidden */
		LLVMHiddenVisibility(1),
		/** < The GV is protected */
		LLVMProtectedVisibility(2);
		LLVMVisibility(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMVisibility > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMVisibility > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/** enum values */
	public enum LLVMDLLStorageClass implements IntValuedEnum<LLVMDLLStorageClass > {
		LLVMDefaultStorageClass(0),
		/** < Function to be imported from DLL. */
		LLVMDLLImportStorageClass(1),
		/** < Function to be accessible from DLL. */
		LLVMDLLExportStorageClass(2);
		LLVMDLLStorageClass(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMDLLStorageClass > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMDLLStorageClass > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/** enum values */
	public enum LLVMCallConv implements IntValuedEnum<LLVMCallConv > {
		LLVMCCallConv(0),
		LLVMFastCallConv(8),
		LLVMColdCallConv(9),
		LLVMWebKitJSCallConv(12),
		LLVMAnyRegCallConv(13),
		LLVMX86StdcallCallConv(64),
		LLVMX86FastcallCallConv(65);
		LLVMCallConv(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMCallConv > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMCallConv > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/** enum values */
	public enum LLVMValueKind implements IntValuedEnum<LLVMValueKind > {
		LLVMArgumentValueKind(0),
		LLVMBasicBlockValueKind(1),
		LLVMMemoryUseValueKind(2),
		LLVMMemoryDefValueKind(3),
		LLVMMemoryPhiValueKind(4),
		LLVMFunctionValueKind(5),
		LLVMGlobalAliasValueKind(6),
		LLVMGlobalIFuncValueKind(7),
		LLVMGlobalVariableValueKind(8),
		LLVMBlockAddressValueKind(9),
		LLVMConstantExprValueKind(10),
		LLVMConstantArrayValueKind(11),
		LLVMConstantStructValueKind(12),
		LLVMConstantVectorValueKind(13),
		LLVMUndefValueValueKind(14),
		LLVMConstantAggregateZeroValueKind(15),
		LLVMConstantDataArrayValueKind(16),
		LLVMConstantDataVectorValueKind(17),
		LLVMConstantIntValueKind(18),
		LLVMConstantFPValueKind(19),
		LLVMConstantPointerNullValueKind(20),
		LLVMConstantTokenNoneValueKind(21),
		LLVMMetadataAsValueValueKind(22),
		LLVMInlineAsmValueKind(23),
		LLVMInstructionValueKind(24);
		LLVMValueKind(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMValueKind > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMValueKind > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/** enum values */
	public enum LLVMIntPredicate implements IntValuedEnum<LLVMIntPredicate > {
		/** < equal */
		LLVMIntEQ(32),
		/** < not equal */
		LLVMIntNE(33),
		/** < unsigned greater than */
		LLVMIntUGT(34),
		/** < unsigned greater or equal */
		LLVMIntUGE(35),
		/** < unsigned less than */
		LLVMIntULT(36),
		/** < unsigned less or equal */
		LLVMIntULE(37),
		/** < signed greater than */
		LLVMIntSGT(38),
		/** < signed greater or equal */
		LLVMIntSGE(39),
		/** < signed less than */
		LLVMIntSLT(40),
		/** < signed less or equal */
		LLVMIntSLE(41);
		LLVMIntPredicate(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMIntPredicate > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMIntPredicate > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/** enum values */
	public enum LLVMRealPredicate implements IntValuedEnum<LLVMRealPredicate > {
		/** < Always false (always folded) */
		LLVMRealPredicateFalse(0),
		/** < True if ordered and equal */
		LLVMRealOEQ(1),
		/** < True if ordered and greater than */
		LLVMRealOGT(2),
		/** < True if ordered and greater than or equal */
		LLVMRealOGE(3),
		/** < True if ordered and less than */
		LLVMRealOLT(4),
		/** < True if ordered and less than or equal */
		LLVMRealOLE(5),
		/** < True if ordered and operands are unequal */
		LLVMRealONE(6),
		/** < True if ordered (no nans) */
		LLVMRealORD(7),
		/** < True if unordered: isnan(X) | isnan(Y) */
		LLVMRealUNO(8),
		/** < True if unordered or equal */
		LLVMRealUEQ(9),
		/** < True if unordered or greater than */
		LLVMRealUGT(10),
		/** < True if unordered, greater than, or equal */
		LLVMRealUGE(11),
		/** < True if unordered or less than */
		LLVMRealULT(12),
		/** < True if unordered, less than, or equal */
		LLVMRealULE(13),
		/** < True if unordered or not equal */
		LLVMRealUNE(14),
		/** < Always true (always folded) */
		LLVMRealPredicateTrue(15);
		LLVMRealPredicate(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMRealPredicate > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMRealPredicate > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/** enum values */
	public enum LLVMLandingPadClauseTy implements IntValuedEnum<LLVMLandingPadClauseTy > {
		/** < A catch clause */
		LLVMLandingPadCatch(0),
		/** < A filter clause */
		LLVMLandingPadFilter(1);
		LLVMLandingPadClauseTy(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMLandingPadClauseTy > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMLandingPadClauseTy > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/** enum values */
	public enum LLVMThreadLocalMode implements IntValuedEnum<LLVMThreadLocalMode > {
		LLVMNotThreadLocal(0),
		LLVMGeneralDynamicTLSModel(1),
		LLVMLocalDynamicTLSModel(2),
		LLVMInitialExecTLSModel(3),
		LLVMLocalExecTLSModel(4);
		LLVMThreadLocalMode(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMThreadLocalMode > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMThreadLocalMode > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/** enum values */
	public enum LLVMAtomicOrdering implements IntValuedEnum<LLVMAtomicOrdering > {
		/** < A load or store which is not atomic */
		LLVMAtomicOrderingNotAtomic(0),
		/**
		 * < Lowest level of atomicity, guarantees<br>
		 * somewhat sane results, lock free.
		 */
		LLVMAtomicOrderingUnordered(1),
		/**
		 * < guarantees that if you take all the<br>
		 * operations affecting a specific address,<br>
		 * a consistent ordering exists
		 */
		LLVMAtomicOrderingMonotonic(2),
		/**
		 * < Acquire provides a barrier of the sort<br>
		 * necessary to acquire a lock to access other<br>
		 * memory with normal loads and stores.
		 */
		LLVMAtomicOrderingAcquire(4),
		/**
		 * < Release is similar to Acquire, but with<br>
		 * a barrier of the sort necessary to release<br>
		 * a lock.
		 */
		LLVMAtomicOrderingRelease(5),
		/**
		 * < provides both an Acquire and a<br>
		 * Release barrier (for fences and<br>
		 * operations which both read and write<br>
		 * memory).
		 */
		LLVMAtomicOrderingAcquireRelease(6),
		/**
		 * < provides Acquire semantics<br>
		 * for loads and Release<br>
		 * semantics for stores.<br>
		 * Additionally, it guarantees<br>
		 * that a total ordering exists<br>
		 * between all<br>
		 * SequentiallyConsistent<br>
		 * operations.
		 */
		LLVMAtomicOrderingSequentiallyConsistent(7);
		LLVMAtomicOrdering(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMAtomicOrdering > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMAtomicOrdering > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/** enum values */
	public enum LLVMAtomicRMWBinOp implements IntValuedEnum<LLVMAtomicRMWBinOp > {
		/** < Set the new value and return the one old */
		LLVMAtomicRMWBinOpXchg(0),
		/** < Add a value and return the old one */
		LLVMAtomicRMWBinOpAdd(1),
		/** < Subtract a value and return the old one */
		LLVMAtomicRMWBinOpSub(2),
		/** < And a value and return the old one */
		LLVMAtomicRMWBinOpAnd(3),
		/** < Not-And a value and return the old one */
		LLVMAtomicRMWBinOpNand(4),
		/** < OR a value and return the old one */
		LLVMAtomicRMWBinOpOr(5),
		/** < Xor a value and return the old one */
		LLVMAtomicRMWBinOpXor(6),
		/**
		 * < Sets the value if it's greater than the<br>
		 * original using a signed comparison and return<br>
		 * the old one
		 */
		LLVMAtomicRMWBinOpMax(7),
		/**
		 * < Sets the value if it's Smaller than the<br>
		 * original using a signed comparison and return<br>
		 * the old one
		 */
		LLVMAtomicRMWBinOpMin(8),
		/**
		 * < Sets the value if it's greater than the<br>
		 * original using an unsigned comparison and return<br>
		 * the old one
		 */
		LLVMAtomicRMWBinOpUMax(9),
		/**
		 * < Sets the value if it's greater than the<br>
		 * original using an unsigned comparison  and return<br>
		 * the old one
		 */
		LLVMAtomicRMWBinOpUMin(10);
		LLVMAtomicRMWBinOp(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMAtomicRMWBinOp > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMAtomicRMWBinOp > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/** enum values */
	public enum LLVMDiagnosticSeverity implements IntValuedEnum<LLVMDiagnosticSeverity > {
		LLVMDSError(0),
		LLVMDSWarning(1),
		LLVMDSRemark(2),
		LLVMDSNote(3);
		LLVMDiagnosticSeverity(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMDiagnosticSeverity > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMDiagnosticSeverity > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	public static final int LLVMAttributeReturnIndex = 0;
	public static final int LLVMAttributeFunctionIndex = -1;
	/** enum values */
	public enum LLVMVerifierFailureAction implements IntValuedEnum<LLVMVerifierFailureAction > {
		/** verifier will print to stderr and abort() */
		LLVMAbortProcessAction(0),
		/** verifier will print to stderr and return 1 */
		LLVMPrintMessageAction(1),
		/** verifier will just return 1 */
		LLVMReturnStatusAction(2);
		LLVMVerifierFailureAction(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMVerifierFailureAction > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMVerifierFailureAction > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/**
	 * @defgroup LLVMCTarget Target information<br>
	 * @ingroup LLVMC<br>
	 * @{<br>
	 * enum values
	 */
	public enum LLVMByteOrdering implements IntValuedEnum<LLVMByteOrdering > {
		LLVMBigEndian(0),
		LLVMLittleEndian(1);
		LLVMByteOrdering(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMByteOrdering > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMByteOrdering > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	public static abstract class LLVMDiagnosticHandler extends Callback<LLVMDiagnosticHandler > {
		public void apply(Pointer<? > voidPtr1) {
			apply(Pointer.getPeer(voidPtr1));
		}
		public void apply(@Ptr long voidPtr1) {
			apply(Pointer.pointerToAddress(voidPtr1));
		}
	};
	public static abstract class LLVMYieldCallback extends Callback<LLVMYieldCallback > {
		public void apply(Pointer<? > voidPtr1) {
			apply(Pointer.getPeer(voidPtr1));
		}
		public void apply(@Ptr long voidPtr1) {
			apply(Pointer.pointerToAddress(voidPtr1));
		}
	};
	/**
	 * See llvm::createArgumentPromotionPass function.<br>
	 * Original signature : <code>void LLVMAddArgumentPromotionPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddArgumentPromotionPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddArgumentPromotionPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddArgumentPromotionPass(@Ptr long PM);
	/**
	 * See llvm::createConstantMergePass function.<br>
	 * Original signature : <code>void LLVMAddConstantMergePass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddConstantMergePass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddConstantMergePass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddConstantMergePass(@Ptr long PM);
	/**
	 * See llvm::createDeadArgEliminationPass function.<br>
	 * Original signature : <code>void LLVMAddDeadArgEliminationPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddDeadArgEliminationPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddDeadArgEliminationPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddDeadArgEliminationPass(@Ptr long PM);
	/**
	 * See llvm::createFunctionAttrsPass function.<br>
	 * Original signature : <code>void LLVMAddFunctionAttrsPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddFunctionAttrsPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddFunctionAttrsPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddFunctionAttrsPass(@Ptr long PM);
	/**
	 * See llvm::createFunctionInliningPass function.<br>
	 * Original signature : <code>void LLVMAddFunctionInliningPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddFunctionInliningPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddFunctionInliningPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddFunctionInliningPass(@Ptr long PM);
	/**
	 * See llvm::createAlwaysInlinerPass function.<br>
	 * Original signature : <code>void LLVMAddAlwaysInlinerPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddAlwaysInlinerPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddAlwaysInlinerPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddAlwaysInlinerPass(@Ptr long PM);
	/**
	 * See llvm::createGlobalDCEPass function.<br>
	 * Original signature : <code>void LLVMAddGlobalDCEPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddGlobalDCEPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddGlobalDCEPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddGlobalDCEPass(@Ptr long PM);
	/**
	 * See llvm::createGlobalOptimizerPass function.<br>
	 * Original signature : <code>void LLVMAddGlobalOptimizerPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddGlobalOptimizerPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddGlobalOptimizerPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddGlobalOptimizerPass(@Ptr long PM);
	/**
	 * See llvm::createIPConstantPropagationPass function.<br>
	 * Original signature : <code>void LLVMAddIPConstantPropagationPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddIPConstantPropagationPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddIPConstantPropagationPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddIPConstantPropagationPass(@Ptr long PM);
	/**
	 * See llvm::createPruneEHPass function.<br>
	 * Original signature : <code>void LLVMAddPruneEHPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddPruneEHPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddPruneEHPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddPruneEHPass(@Ptr long PM);
	/**
	 * See llvm::createIPSCCPPass function.<br>
	 * Original signature : <code>void LLVMAddIPSCCPPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddIPSCCPPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddIPSCCPPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddIPSCCPPass(@Ptr long PM);
	/**
	 * See llvm::createInternalizePass function.<br>
	 * Original signature : <code>void LLVMAddInternalizePass(unsigned)</code>
	 */
	public static native void LLVMAddInternalizePass(int AllButMain);
	/**
	 * See llvm::createStripDeadPrototypesPass function.<br>
	 * Original signature : <code>void LLVMAddStripDeadPrototypesPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddStripDeadPrototypesPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddStripDeadPrototypesPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddStripDeadPrototypesPass(@Ptr long PM);
	/**
	 * See llvm::createStripSymbolsPass function.<br>
	 * Original signature : <code>void LLVMAddStripSymbolsPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddStripSymbolsPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddStripSymbolsPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddStripSymbolsPass(@Ptr long PM);
	/**
	 * See llvm::createAggressiveDCEPass function.<br>
	 * Original signature : <code>void LLVMAddAggressiveDCEPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddAggressiveDCEPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddAggressiveDCEPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddAggressiveDCEPass(@Ptr long PM);
	/**
	 * See llvm::createBitTrackingDCEPass function.<br>
	 * Original signature : <code>void LLVMAddBitTrackingDCEPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddBitTrackingDCEPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddBitTrackingDCEPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddBitTrackingDCEPass(@Ptr long PM);
	/**
	 * See llvm::createAlignmentFromAssumptionsPass function.<br>
	 * Original signature : <code>void LLVMAddAlignmentFromAssumptionsPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddAlignmentFromAssumptionsPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddAlignmentFromAssumptionsPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddAlignmentFromAssumptionsPass(@Ptr long PM);
	/**
	 * See llvm::createCFGSimplificationPass function.<br>
	 * Original signature : <code>void LLVMAddCFGSimplificationPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddCFGSimplificationPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddCFGSimplificationPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddCFGSimplificationPass(@Ptr long PM);
	/**
	 * See llvm::createDeadStoreEliminationPass function.<br>
	 * Original signature : <code>void LLVMAddDeadStoreEliminationPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddDeadStoreEliminationPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddDeadStoreEliminationPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddDeadStoreEliminationPass(@Ptr long PM);
	/**
	 * See llvm::createScalarizerPass function.<br>
	 * Original signature : <code>void LLVMAddScalarizerPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddScalarizerPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddScalarizerPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddScalarizerPass(@Ptr long PM);
	/**
	 * See llvm::createMergedLoadStoreMotionPass function.<br>
	 * Original signature : <code>void LLVMAddMergedLoadStoreMotionPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddMergedLoadStoreMotionPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddMergedLoadStoreMotionPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddMergedLoadStoreMotionPass(@Ptr long PM);
	/**
	 * See llvm::createGVNPass function.<br>
	 * Original signature : <code>void LLVMAddGVNPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddGVNPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddGVNPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddGVNPass(@Ptr long PM);
	/**
	 * See llvm::createIndVarSimplifyPass function.<br>
	 * Original signature : <code>void LLVMAddIndVarSimplifyPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddIndVarSimplifyPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddIndVarSimplifyPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddIndVarSimplifyPass(@Ptr long PM);
	/**
	 * See llvm::createInstructionCombiningPass function.<br>
	 * Original signature : <code>void LLVMAddInstructionCombiningPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddInstructionCombiningPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddInstructionCombiningPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddInstructionCombiningPass(@Ptr long PM);
	/**
	 * See llvm::createJumpThreadingPass function.<br>
	 * Original signature : <code>void LLVMAddJumpThreadingPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddJumpThreadingPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddJumpThreadingPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddJumpThreadingPass(@Ptr long PM);
	/**
	 * See llvm::createLICMPass function.<br>
	 * Original signature : <code>void LLVMAddLICMPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddLICMPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddLICMPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddLICMPass(@Ptr long PM);
	/**
	 * See llvm::createLoopDeletionPass function.<br>
	 * Original signature : <code>void LLVMAddLoopDeletionPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddLoopDeletionPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddLoopDeletionPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddLoopDeletionPass(@Ptr long PM);
	/**
	 * See llvm::createLoopIdiomPass function<br>
	 * Original signature : <code>void LLVMAddLoopIdiomPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddLoopIdiomPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddLoopIdiomPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddLoopIdiomPass(@Ptr long PM);
	/**
	 * See llvm::createLoopRotatePass function.<br>
	 * Original signature : <code>void LLVMAddLoopRotatePass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddLoopRotatePass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddLoopRotatePass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddLoopRotatePass(@Ptr long PM);
	/**
	 * See llvm::createLoopRerollPass function.<br>
	 * Original signature : <code>void LLVMAddLoopRerollPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddLoopRerollPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddLoopRerollPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddLoopRerollPass(@Ptr long PM);
	/**
	 * See llvm::createLoopUnrollPass function.<br>
	 * Original signature : <code>void LLVMAddLoopUnrollPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddLoopUnrollPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddLoopUnrollPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddLoopUnrollPass(@Ptr long PM);
	/**
	 * See llvm::createLoopUnswitchPass function.<br>
	 * Original signature : <code>void LLVMAddLoopUnswitchPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddLoopUnswitchPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddLoopUnswitchPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddLoopUnswitchPass(@Ptr long PM);
	/**
	 * See llvm::createMemCpyOptPass function.<br>
	 * Original signature : <code>void LLVMAddMemCpyOptPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddMemCpyOptPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddMemCpyOptPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddMemCpyOptPass(@Ptr long PM);
	/**
	 * See llvm::createPartiallyInlineLibCallsPass function.<br>
	 * Original signature : <code>void LLVMAddPartiallyInlineLibCallsPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddPartiallyInlineLibCallsPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddPartiallyInlineLibCallsPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddPartiallyInlineLibCallsPass(@Ptr long PM);
	/**
	 * See llvm::createLowerSwitchPass function.<br>
	 * Original signature : <code>void LLVMAddLowerSwitchPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddLowerSwitchPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddLowerSwitchPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddLowerSwitchPass(@Ptr long PM);
	/**
	 * See llvm::createPromoteMemoryToRegisterPass function.<br>
	 * Original signature : <code>void LLVMAddPromoteMemoryToRegisterPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddPromoteMemoryToRegisterPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddPromoteMemoryToRegisterPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddPromoteMemoryToRegisterPass(@Ptr long PM);
	/**
	 * See llvm::createReassociatePass function.<br>
	 * Original signature : <code>void LLVMAddReassociatePass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddReassociatePass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddReassociatePass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddReassociatePass(@Ptr long PM);
	/**
	 * See llvm::createSCCPPass function.<br>
	 * Original signature : <code>void LLVMAddSCCPPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddSCCPPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddSCCPPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddSCCPPass(@Ptr long PM);
	/**
	 * See llvm::createSROAPass function.<br>
	 * Original signature : <code>void LLVMAddScalarReplAggregatesPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddScalarReplAggregatesPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddScalarReplAggregatesPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddScalarReplAggregatesPass(@Ptr long PM);
	/**
	 * See llvm::createSROAPass function.<br>
	 * Original signature : <code>void LLVMAddScalarReplAggregatesPassSSA(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddScalarReplAggregatesPassSSA(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddScalarReplAggregatesPassSSA(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddScalarReplAggregatesPassSSA(@Ptr long PM);
	/**
	 * See llvm::createSROAPass function.<br>
	 * Original signature : <code>void LLVMAddScalarReplAggregatesPassWithThreshold(LLVMPassManagerRef, int)</code>
	 */
	public static void LLVMAddScalarReplAggregatesPassWithThreshold(LLVMLibrary.LLVMPassManagerRef PM, int Threshold) {
		LLVMAddScalarReplAggregatesPassWithThreshold(Pointer.getPeer(PM), Threshold);
	}
	protected native static void LLVMAddScalarReplAggregatesPassWithThreshold(@Ptr long PM, int Threshold);
	/**
	 * See llvm::createSimplifyLibCallsPass function.<br>
	 * Original signature : <code>void LLVMAddSimplifyLibCallsPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddSimplifyLibCallsPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddSimplifyLibCallsPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddSimplifyLibCallsPass(@Ptr long PM);
	/**
	 * See llvm::createTailCallEliminationPass function.<br>
	 * Original signature : <code>void LLVMAddTailCallEliminationPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddTailCallEliminationPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddTailCallEliminationPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddTailCallEliminationPass(@Ptr long PM);
	/**
	 * See llvm::createConstantPropagationPass function.<br>
	 * Original signature : <code>void LLVMAddConstantPropagationPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddConstantPropagationPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddConstantPropagationPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddConstantPropagationPass(@Ptr long PM);
	/**
	 * See llvm::demotePromoteMemoryToRegisterPass function.<br>
	 * Original signature : <code>void LLVMAddDemoteMemoryToRegisterPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddDemoteMemoryToRegisterPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddDemoteMemoryToRegisterPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddDemoteMemoryToRegisterPass(@Ptr long PM);
	/**
	 * See llvm::createVerifierPass function.<br>
	 * Original signature : <code>void LLVMAddVerifierPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddVerifierPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddVerifierPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddVerifierPass(@Ptr long PM);
	/**
	 * See llvm::createCorrelatedValuePropagationPass function<br>
	 * Original signature : <code>void LLVMAddCorrelatedValuePropagationPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddCorrelatedValuePropagationPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddCorrelatedValuePropagationPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddCorrelatedValuePropagationPass(@Ptr long PM);
	/**
	 * See llvm::createEarlyCSEPass function<br>
	 * Original signature : <code>void LLVMAddEarlyCSEPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddEarlyCSEPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddEarlyCSEPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddEarlyCSEPass(@Ptr long PM);
	/**
	 * See llvm::createLowerExpectIntrinsicPass function<br>
	 * Original signature : <code>void LLVMAddLowerExpectIntrinsicPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddLowerExpectIntrinsicPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddLowerExpectIntrinsicPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddLowerExpectIntrinsicPass(@Ptr long PM);
	/**
	 * See llvm::createTypeBasedAliasAnalysisPass function<br>
	 * Original signature : <code>void LLVMAddTypeBasedAliasAnalysisPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddTypeBasedAliasAnalysisPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddTypeBasedAliasAnalysisPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddTypeBasedAliasAnalysisPass(@Ptr long PM);
	/**
	 * See llvm::createScopedNoAliasAAPass function<br>
	 * Original signature : <code>void LLVMAddScopedNoAliasAAPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddScopedNoAliasAAPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddScopedNoAliasAAPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddScopedNoAliasAAPass(@Ptr long PM);
	/**
	 * See llvm::createBasicAliasAnalysisPass function<br>
	 * Original signature : <code>void LLVMAddBasicAliasAnalysisPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddBasicAliasAnalysisPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddBasicAliasAnalysisPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddBasicAliasAnalysisPass(@Ptr long PM);
	/**
	 * See llvm::PassManagerBuilder.<br>
	 * Original signature : <code>LLVMPassManagerBuilderRef LLVMPassManagerBuilderCreate()</code>
	 */
	public static LLVMLibrary.LLVMPassManagerBuilderRef LLVMPassManagerBuilderCreate() {
		return new LLVMLibrary.LLVMPassManagerBuilderRef(LLVMPassManagerBuilderCreate$2());
	}
	@Ptr 
	@Name("LLVMPassManagerBuilderCreate") 
	protected native static long LLVMPassManagerBuilderCreate$2();
	/** Original signature : <code>void LLVMPassManagerBuilderDispose(LLVMPassManagerBuilderRef)</code> */
	public static void LLVMPassManagerBuilderDispose(LLVMLibrary.LLVMPassManagerBuilderRef PMB) {
		LLVMPassManagerBuilderDispose(Pointer.getPeer(PMB));
	}
	protected native static void LLVMPassManagerBuilderDispose(@Ptr long PMB);
	/**
	 * See llvm::PassManagerBuilder::OptLevel.<br>
	 * Original signature : <code>void LLVMPassManagerBuilderSetOptLevel(LLVMPassManagerBuilderRef, unsigned)</code>
	 */
	public static void LLVMPassManagerBuilderSetOptLevel(LLVMLibrary.LLVMPassManagerBuilderRef PMB, int OptLevel) {
		LLVMPassManagerBuilderSetOptLevel(Pointer.getPeer(PMB), OptLevel);
	}
	protected native static void LLVMPassManagerBuilderSetOptLevel(@Ptr long PMB, int OptLevel);
	/**
	 * See llvm::PassManagerBuilder::SizeLevel.<br>
	 * Original signature : <code>void LLVMPassManagerBuilderSetSizeLevel(LLVMPassManagerBuilderRef, unsigned)</code>
	 */
	public static void LLVMPassManagerBuilderSetSizeLevel(LLVMLibrary.LLVMPassManagerBuilderRef PMB, int SizeLevel) {
		LLVMPassManagerBuilderSetSizeLevel(Pointer.getPeer(PMB), SizeLevel);
	}
	protected native static void LLVMPassManagerBuilderSetSizeLevel(@Ptr long PMB, int SizeLevel);
	/**
	 * See llvm::PassManagerBuilder::DisableUnitAtATime.<br>
	 * Original signature : <code>void LLVMPassManagerBuilderSetDisableUnitAtATime(LLVMPassManagerBuilderRef, LLVMBool)</code>
	 */
	public static void LLVMPassManagerBuilderSetDisableUnitAtATime(LLVMLibrary.LLVMPassManagerBuilderRef PMB, int Value) {
		LLVMPassManagerBuilderSetDisableUnitAtATime(Pointer.getPeer(PMB), Value);
	}
	protected native static void LLVMPassManagerBuilderSetDisableUnitAtATime(@Ptr long PMB, int Value);
	/**
	 * See llvm::PassManagerBuilder::DisableUnrollLoops.<br>
	 * Original signature : <code>void LLVMPassManagerBuilderSetDisableUnrollLoops(LLVMPassManagerBuilderRef, LLVMBool)</code>
	 */
	public static void LLVMPassManagerBuilderSetDisableUnrollLoops(LLVMLibrary.LLVMPassManagerBuilderRef PMB, int Value) {
		LLVMPassManagerBuilderSetDisableUnrollLoops(Pointer.getPeer(PMB), Value);
	}
	protected native static void LLVMPassManagerBuilderSetDisableUnrollLoops(@Ptr long PMB, int Value);
	/**
	 * See llvm::PassManagerBuilder::DisableSimplifyLibCalls<br>
	 * Original signature : <code>void LLVMPassManagerBuilderSetDisableSimplifyLibCalls(LLVMPassManagerBuilderRef, LLVMBool)</code>
	 */
	public static void LLVMPassManagerBuilderSetDisableSimplifyLibCalls(LLVMLibrary.LLVMPassManagerBuilderRef PMB, int Value) {
		LLVMPassManagerBuilderSetDisableSimplifyLibCalls(Pointer.getPeer(PMB), Value);
	}
	protected native static void LLVMPassManagerBuilderSetDisableSimplifyLibCalls(@Ptr long PMB, int Value);
	/**
	 * See llvm::PassManagerBuilder::Inliner.<br>
	 * Original signature : <code>void LLVMPassManagerBuilderUseInlinerWithThreshold(LLVMPassManagerBuilderRef, unsigned)</code>
	 */
	public static void LLVMPassManagerBuilderUseInlinerWithThreshold(LLVMLibrary.LLVMPassManagerBuilderRef PMB, int Threshold) {
		LLVMPassManagerBuilderUseInlinerWithThreshold(Pointer.getPeer(PMB), Threshold);
	}
	protected native static void LLVMPassManagerBuilderUseInlinerWithThreshold(@Ptr long PMB, int Threshold);
	/**
	 * See llvm::PassManagerBuilder::populateFunctionPassManager.<br>
	 * Original signature : <code>void LLVMPassManagerBuilderPopulateFunctionPassManager(LLVMPassManagerBuilderRef, LLVMPassManagerRef)</code>
	 */
	public static void LLVMPassManagerBuilderPopulateFunctionPassManager(LLVMLibrary.LLVMPassManagerBuilderRef PMB, LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMPassManagerBuilderPopulateFunctionPassManager(Pointer.getPeer(PMB), Pointer.getPeer(PM));
	}
	protected native static void LLVMPassManagerBuilderPopulateFunctionPassManager(@Ptr long PMB, @Ptr long PM);
	/**
	 * See llvm::PassManagerBuilder::populateModulePassManager.<br>
	 * Original signature : <code>void LLVMPassManagerBuilderPopulateModulePassManager(LLVMPassManagerBuilderRef, LLVMPassManagerRef)</code>
	 */
	public static void LLVMPassManagerBuilderPopulateModulePassManager(LLVMLibrary.LLVMPassManagerBuilderRef PMB, LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMPassManagerBuilderPopulateModulePassManager(Pointer.getPeer(PMB), Pointer.getPeer(PM));
	}
	protected native static void LLVMPassManagerBuilderPopulateModulePassManager(@Ptr long PMB, @Ptr long PM);
	/**
	 * See llvm::PassManagerBuilder::populateLTOPassManager.<br>
	 * Original signature : <code>void LLVMPassManagerBuilderPopulateLTOPassManager(LLVMPassManagerBuilderRef, LLVMPassManagerRef, LLVMBool, LLVMBool)</code>
	 */
	public static void LLVMPassManagerBuilderPopulateLTOPassManager(LLVMLibrary.LLVMPassManagerBuilderRef PMB, LLVMLibrary.LLVMPassManagerRef PM, int Internalize, int RunInliner) {
		LLVMPassManagerBuilderPopulateLTOPassManager(Pointer.getPeer(PMB), Pointer.getPeer(PM), Internalize, RunInliner);
	}
	protected native static void LLVMPassManagerBuilderPopulateLTOPassManager(@Ptr long PMB, @Ptr long PM, int Internalize, int RunInliner);
	/**
	 * See llvm::createBBVectorizePass function.<br>
	 * Original signature : <code>void LLVMAddBBVectorizePass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddBBVectorizePass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddBBVectorizePass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddBBVectorizePass(@Ptr long PM);
	/**
	 * See llvm::createLoopVectorizePass function.<br>
	 * Original signature : <code>void LLVMAddLoopVectorizePass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddLoopVectorizePass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddLoopVectorizePass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddLoopVectorizePass(@Ptr long PM);
	/**
	 * See llvm::createSLPVectorizerPass function.<br>
	 * Original signature : <code>void LLVMAddSLPVectorizePass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddSLPVectorizePass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddSLPVectorizePass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddSLPVectorizePass(@Ptr long PM);
	/**
	 * @}<br>
	 * Original signature : <code>void LLVMInitializeCore(LLVMPassRegistryRef)</code>
	 */
	public static void LLVMInitializeCore(LLVMLibrary.LLVMPassRegistryRef R) {
		LLVMInitializeCore(Pointer.getPeer(R));
	}
	protected native static void LLVMInitializeCore(@Ptr long R);
	/**
	 * Deallocate and destroy all ManagedStatic variables.<br>
	 * @see llvm::llvm_shutdown<br>
	 * @see ManagedStatic<br>
	 * Original signature : <code>void LLVMShutdown()</code>
	 */
	public static native void LLVMShutdown();
	/**
	 * ===-- Error handling ----------------------------------------------------===<br>
	 * Original signature : <code>char* LLVMCreateMessage(const char*)</code>
	 */
	public static Pointer<Byte > LLVMCreateMessage(Pointer<Byte > Message) {
		return (Pointer)Pointer.pointerToAddress(LLVMCreateMessage(Pointer.getPeer(Message)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMCreateMessage(@Ptr long Message);
	/** Original signature : <code>void LLVMDisposeMessage(char*)</code> */
	public static void LLVMDisposeMessage(Pointer<Byte > Message) {
		LLVMDisposeMessage(Pointer.getPeer(Message));
	}
	protected native static void LLVMDisposeMessage(@Ptr long Message);
	/**
	 * Create a new context.<br>
	 * Every call to this function should be paired with a call to<br>
	 * LLVMContextDispose() or the context will leak memory.<br>
	 * Original signature : <code>LLVMContextRef LLVMContextCreate()</code>
	 */
	public static LLVMLibrary.LLVMContextRef LLVMContextCreate() {
		return new LLVMLibrary.LLVMContextRef(LLVMContextCreate$2());
	}
	@Ptr 
	@Name("LLVMContextCreate") 
	protected native static long LLVMContextCreate$2();
	/**
	 * Obtain the global context instance.<br>
	 * Original signature : <code>LLVMContextRef LLVMGetGlobalContext()</code>
	 */
	public static LLVMLibrary.LLVMContextRef LLVMGetGlobalContext() {
		return new LLVMLibrary.LLVMContextRef(LLVMGetGlobalContext$2());
	}
	@Ptr 
	@Name("LLVMGetGlobalContext") 
	protected native static long LLVMGetGlobalContext$2();
	/**
	 * Set the diagnostic handler for this context.<br>
	 * Original signature : <code>void LLVMContextSetDiagnosticHandler(LLVMContextRef, LLVMDiagnosticHandler, void*)</code>
	 */
	public static void LLVMContextSetDiagnosticHandler(LLVMLibrary.LLVMContextRef C, Pointer<LLVMLibrary.LLVMDiagnosticHandler > Handler, Pointer<? > DiagnosticContext) {
		LLVMContextSetDiagnosticHandler(Pointer.getPeer(C), Pointer.getPeer(Handler), Pointer.getPeer(DiagnosticContext));
	}
	protected native static void LLVMContextSetDiagnosticHandler(@Ptr long C, @Ptr long Handler, @Ptr long DiagnosticContext);
	/**
	 * Get the diagnostic handler of this context.<br>
	 * Original signature : <code>LLVMDiagnosticHandler LLVMContextGetDiagnosticHandler(LLVMContextRef)</code>
	 */
	public static Pointer<LLVMLibrary.LLVMDiagnosticHandler > LLVMContextGetDiagnosticHandler(LLVMLibrary.LLVMContextRef C) {
		return (Pointer)Pointer.pointerToAddress(LLVMContextGetDiagnosticHandler(Pointer.getPeer(C)), LLVMLibrary.LLVMDiagnosticHandler.class);
	}
	@Ptr 
	protected native static long LLVMContextGetDiagnosticHandler(@Ptr long C);
	/**
	 * Get the diagnostic context of this context.<br>
	 * Original signature : <code>void* LLVMContextGetDiagnosticContext(LLVMContextRef)</code>
	 */
	public static Pointer<? > LLVMContextGetDiagnosticContext(LLVMLibrary.LLVMContextRef C) {
		return Pointer.pointerToAddress(LLVMContextGetDiagnosticContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMContextGetDiagnosticContext(@Ptr long C);
	/**
	 * Set the yield callback function for this context.<br>
	 * @see LLVMContext::setYieldCallback()<br>
	 * Original signature : <code>void LLVMContextSetYieldCallback(LLVMContextRef, LLVMYieldCallback, void*)</code>
	 */
	public static void LLVMContextSetYieldCallback(LLVMLibrary.LLVMContextRef C, Pointer<LLVMLibrary.LLVMYieldCallback > Callback, Pointer<? > OpaqueHandle) {
		LLVMContextSetYieldCallback(Pointer.getPeer(C), Pointer.getPeer(Callback), Pointer.getPeer(OpaqueHandle));
	}
	protected native static void LLVMContextSetYieldCallback(@Ptr long C, @Ptr long Callback, @Ptr long OpaqueHandle);
	/**
	 * Destroy a context instance.<br>
	 * This should be called for every call to LLVMContextCreate() or memory<br>
	 * will be leaked.<br>
	 * Original signature : <code>void LLVMContextDispose(LLVMContextRef)</code>
	 */
	public static void LLVMContextDispose(LLVMLibrary.LLVMContextRef C) {
		LLVMContextDispose(Pointer.getPeer(C));
	}
	protected native static void LLVMContextDispose(@Ptr long C);
	/**
	 * Return a string representation of the DiagnosticInfo. Use<br>
	 * LLVMDisposeMessage to free the string.<br>
	 * @see DiagnosticInfo::print()<br>
	 * Original signature : <code>char* LLVMGetDiagInfoDescription(LLVMDiagnosticInfoRef)</code>
	 */
	public static Pointer<Byte > LLVMGetDiagInfoDescription(LLVMLibrary.LLVMDiagnosticInfoRef DI) {
		return (Pointer)Pointer.pointerToAddress(LLVMGetDiagInfoDescription(Pointer.getPeer(DI)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetDiagInfoDescription(@Ptr long DI);
	/**
	 * Return an enum LLVMDiagnosticSeverity.<br>
	 * @see DiagnosticInfo::getSeverity()<br>
	 * Original signature : <code>LLVMDiagnosticSeverity LLVMGetDiagInfoSeverity(LLVMDiagnosticInfoRef)</code>
	 */
	public static IntValuedEnum<LLVMLibrary.LLVMDiagnosticSeverity > LLVMGetDiagInfoSeverity(LLVMLibrary.LLVMDiagnosticInfoRef DI) {
		return FlagSet.fromValue(LLVMGetDiagInfoSeverity(Pointer.getPeer(DI)), LLVMLibrary.LLVMDiagnosticSeverity.class);
	}
	protected native static int LLVMGetDiagInfoSeverity(@Ptr long DI);
	/** Original signature : <code>int LLVMGetMDKindIDInContext(LLVMContextRef, const char*, unsigned)</code> */
	public static int LLVMGetMDKindIDInContext(LLVMLibrary.LLVMContextRef C, Pointer<Byte > Name, int SLen) {
		return LLVMGetMDKindIDInContext(Pointer.getPeer(C), Pointer.getPeer(Name), SLen);
	}
	protected native static int LLVMGetMDKindIDInContext(@Ptr long C, @Ptr long Name, int SLen);
	/** Original signature : <code>int LLVMGetMDKindID(const char*, unsigned)</code> */
	public static int LLVMGetMDKindID(Pointer<Byte > Name, int SLen) {
		return LLVMGetMDKindID(Pointer.getPeer(Name), SLen);
	}
	protected native static int LLVMGetMDKindID(@Ptr long Name, int SLen);
	/**
	 * Return an unique id given the name of a enum attribute,<br>
	 * or 0 if no attribute by that name exists.<br>
	 * See http://llvm.org/docs/LangRef.html#parameter-attributes<br>
	 * and http://llvm.org/docs/LangRef.html#function-attributes<br>
	 * for the list of available attributes.<br>
	 * NB: Attribute names and/or id are subject to change without<br>
	 * going through the C API deprecation cycle.<br>
	 * Original signature : <code>int LLVMGetEnumAttributeKindForName(const char*, size_t)</code>
	 */
	public static int LLVMGetEnumAttributeKindForName(Pointer<Byte > Name, @Ptr long SLen) {
		return LLVMGetEnumAttributeKindForName(Pointer.getPeer(Name), SLen);
	}
	protected native static int LLVMGetEnumAttributeKindForName(@Ptr long Name, @Ptr long SLen);
	/** Original signature : <code>int LLVMGetLastEnumAttributeKind()</code> */
	public static native int LLVMGetLastEnumAttributeKind();
	/**
	 * Create an enum attribute.<br>
	 * Original signature : <code>LLVMAttributeRef LLVMCreateEnumAttribute(LLVMContextRef, unsigned, uint64_t)</code>
	 */
	public static LLVMLibrary.LLVMAttributeRef LLVMCreateEnumAttribute(LLVMLibrary.LLVMContextRef C, int KindID, long Val) {
		return new LLVMLibrary.LLVMAttributeRef(LLVMCreateEnumAttribute(Pointer.getPeer(C), KindID, Val));
	}
	@Ptr 
	protected native static long LLVMCreateEnumAttribute(@Ptr long C, int KindID, long Val);
	/**
	 * Get the unique id corresponding to the enum attribute<br>
	 * passed as argument.<br>
	 * Original signature : <code>int LLVMGetEnumAttributeKind(LLVMAttributeRef)</code>
	 */
	public static int LLVMGetEnumAttributeKind(LLVMLibrary.LLVMAttributeRef A) {
		return LLVMGetEnumAttributeKind(Pointer.getPeer(A));
	}
	protected native static int LLVMGetEnumAttributeKind(@Ptr long A);
	/**
	 * Get the enum attribute's value. 0 is returned if none exists.<br>
	 * Original signature : <code>uint64_t LLVMGetEnumAttributeValue(LLVMAttributeRef)</code>
	 */
	public static long LLVMGetEnumAttributeValue(LLVMLibrary.LLVMAttributeRef A) {
		return LLVMGetEnumAttributeValue(Pointer.getPeer(A));
	}
	protected native static long LLVMGetEnumAttributeValue(@Ptr long A);
	/**
	 * Create a string attribute.<br>
	 * Original signature : <code>LLVMAttributeRef LLVMCreateStringAttribute(LLVMContextRef, const char*, unsigned, const char*, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMAttributeRef LLVMCreateStringAttribute(LLVMLibrary.LLVMContextRef C, Pointer<Byte > K, int KLength, Pointer<Byte > V, int VLength) {
		return new LLVMLibrary.LLVMAttributeRef(LLVMCreateStringAttribute(Pointer.getPeer(C), Pointer.getPeer(K), KLength, Pointer.getPeer(V), VLength));
	}
	@Ptr 
	protected native static long LLVMCreateStringAttribute(@Ptr long C, @Ptr long K, int KLength, @Ptr long V, int VLength);
	/**
	 * Get the string attribute's kind.<br>
	 * Original signature : <code>char* LLVMGetStringAttributeKind(LLVMAttributeRef, unsigned*)</code>
	 */
	public static Pointer<Byte > LLVMGetStringAttributeKind(LLVMLibrary.LLVMAttributeRef A, Pointer<Integer > Length) {
		return (Pointer)Pointer.pointerToAddress(LLVMGetStringAttributeKind(Pointer.getPeer(A), Pointer.getPeer(Length)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetStringAttributeKind(@Ptr long A, @Ptr long Length);
	/**
	 * Get the string attribute's value.<br>
	 * Original signature : <code>char* LLVMGetStringAttributeValue(LLVMAttributeRef, unsigned*)</code>
	 */
	public static Pointer<Byte > LLVMGetStringAttributeValue(LLVMLibrary.LLVMAttributeRef A, Pointer<Integer > Length) {
		return (Pointer)Pointer.pointerToAddress(LLVMGetStringAttributeValue(Pointer.getPeer(A), Pointer.getPeer(Length)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetStringAttributeValue(@Ptr long A, @Ptr long Length);
	/**
	 * Check for the different types of attributes.<br>
	 * Original signature : <code>LLVMBool LLVMIsEnumAttribute(LLVMAttributeRef)</code>
	 */
	public static int LLVMIsEnumAttribute(LLVMLibrary.LLVMAttributeRef A) {
		return LLVMIsEnumAttribute(Pointer.getPeer(A));
	}
	protected native static int LLVMIsEnumAttribute(@Ptr long A);
	/** Original signature : <code>LLVMBool LLVMIsStringAttribute(LLVMAttributeRef)</code> */
	public static int LLVMIsStringAttribute(LLVMLibrary.LLVMAttributeRef A) {
		return LLVMIsStringAttribute(Pointer.getPeer(A));
	}
	protected native static int LLVMIsStringAttribute(@Ptr long A);
	/**
	 * Create a new, empty module in the global context.<br>
	 * This is equivalent to calling LLVMModuleCreateWithNameInContext with<br>
	 * LLVMGetGlobalContext() as the context parameter.<br>
	 * Every invocation should be paired with LLVMDisposeModule() or memory<br>
	 * will be leaked.<br>
	 * Original signature : <code>LLVMModuleRef LLVMModuleCreateWithName(const char*)</code>
	 */
	public static LLVMLibrary.LLVMModuleRef LLVMModuleCreateWithName(Pointer<Byte > ModuleID) {
		return new LLVMLibrary.LLVMModuleRef(LLVMModuleCreateWithName(Pointer.getPeer(ModuleID)));
	}
	@Ptr 
	protected native static long LLVMModuleCreateWithName(@Ptr long ModuleID);
	/**
	 * Create a new, empty module in a specific context.<br>
	 * Every invocation should be paired with LLVMDisposeModule() or memory<br>
	 * will be leaked.<br>
	 * Original signature : <code>LLVMModuleRef LLVMModuleCreateWithNameInContext(const char*, LLVMContextRef)</code>
	 */
	public static LLVMLibrary.LLVMModuleRef LLVMModuleCreateWithNameInContext(Pointer<Byte > ModuleID, LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMModuleRef(LLVMModuleCreateWithNameInContext(Pointer.getPeer(ModuleID), Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMModuleCreateWithNameInContext(@Ptr long ModuleID, @Ptr long C);
	/**
	 * Return an exact copy of the specified module.<br>
	 * Original signature : <code>LLVMModuleRef LLVMCloneModule(LLVMModuleRef)</code>
	 */
	public static LLVMLibrary.LLVMModuleRef LLVMCloneModule(LLVMLibrary.LLVMModuleRef M) {
		return new LLVMLibrary.LLVMModuleRef(LLVMCloneModule(Pointer.getPeer(M)));
	}
	@Ptr 
	protected native static long LLVMCloneModule(@Ptr long M);
	/**
	 * Destroy a module instance.<br>
	 * This must be called for every created module or memory will be<br>
	 * leaked.<br>
	 * Original signature : <code>void LLVMDisposeModule(LLVMModuleRef)</code>
	 */
	public static void LLVMDisposeModule(LLVMLibrary.LLVMModuleRef M) {
		LLVMDisposeModule(Pointer.getPeer(M));
	}
	protected native static void LLVMDisposeModule(@Ptr long M);
	/**
	 * Obtain the identifier of a module.<br>
	 * @param M Module to obtain identifier of<br>
	 * @param Len Out parameter which holds the length of the returned string.<br>
	 * @return The identifier of M.<br>
	 * @see Module::getModuleIdentifier()<br>
	 * Original signature : <code>char* LLVMGetModuleIdentifier(LLVMModuleRef, size_t*)</code>
	 */
	public static Pointer<Byte > LLVMGetModuleIdentifier(LLVMLibrary.LLVMModuleRef M, Pointer<SizeT > Len) {
		return (Pointer)Pointer.pointerToAddress(LLVMGetModuleIdentifier(Pointer.getPeer(M), Pointer.getPeer(Len)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetModuleIdentifier(@Ptr long M, @Ptr long Len);
	/**
	 * Set the identifier of a module to a string Ident with length Len.<br>
	 * @param M The module to set identifier<br>
	 * @param Ident The string to set M's identifier to<br>
	 * @param Len Length of Ident<br>
	 * @see Module::setModuleIdentifier()<br>
	 * Original signature : <code>void LLVMSetModuleIdentifier(LLVMModuleRef, const char*, size_t)</code>
	 */
	public static void LLVMSetModuleIdentifier(LLVMLibrary.LLVMModuleRef M, Pointer<Byte > Ident, @Ptr long Len) {
		LLVMSetModuleIdentifier(Pointer.getPeer(M), Pointer.getPeer(Ident), Len);
	}
	protected native static void LLVMSetModuleIdentifier(@Ptr long M, @Ptr long Ident, @Ptr long Len);
	/**
	 * Obtain the data layout for a module.<br>
	 * @see Module::getDataLayoutStr()<br>
	 * LLVMGetDataLayout is DEPRECATED, as the name is not only incorrect,<br>
	 * but match the name of another method on the module. Prefer the use<br>
	 * of LLVMGetDataLayoutStr, which is not ambiguous.<br>
	 * Original signature : <code>char* LLVMGetDataLayoutStr(LLVMModuleRef)</code>
	 */
	public static Pointer<Byte > LLVMGetDataLayoutStr(LLVMLibrary.LLVMModuleRef M) {
		return (Pointer)Pointer.pointerToAddress(LLVMGetDataLayoutStr(Pointer.getPeer(M)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetDataLayoutStr(@Ptr long M);
	/** Original signature : <code>char* LLVMGetDataLayout(LLVMModuleRef)</code> */
	public static Pointer<Byte > LLVMGetDataLayout(LLVMLibrary.LLVMModuleRef M) {
		return (Pointer)Pointer.pointerToAddress(LLVMGetDataLayout(Pointer.getPeer(M)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetDataLayout(@Ptr long M);
	/**
	 * Set the data layout for a module.<br>
	 * @see Module::setDataLayout()<br>
	 * Original signature : <code>void LLVMSetDataLayout(LLVMModuleRef, const char*)</code>
	 */
	public static void LLVMSetDataLayout(LLVMLibrary.LLVMModuleRef M, Pointer<Byte > DataLayoutStr) {
		LLVMSetDataLayout(Pointer.getPeer(M), Pointer.getPeer(DataLayoutStr));
	}
	protected native static void LLVMSetDataLayout(@Ptr long M, @Ptr long DataLayoutStr);
	/**
	 * Obtain the target triple for a module.<br>
	 * @see Module::getTargetTriple()<br>
	 * Original signature : <code>char* LLVMGetTarget(LLVMModuleRef)</code>
	 */
	public static Pointer<Byte > LLVMGetTarget(LLVMLibrary.LLVMModuleRef M) {
		return (Pointer)Pointer.pointerToAddress(LLVMGetTarget(Pointer.getPeer(M)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetTarget(@Ptr long M);
	/**
	 * Set the target triple for a module.<br>
	 * @see Module::setTargetTriple()<br>
	 * Original signature : <code>void LLVMSetTarget(LLVMModuleRef, const char*)</code>
	 */
	public static void LLVMSetTarget(LLVMLibrary.LLVMModuleRef M, Pointer<Byte > Triple) {
		LLVMSetTarget(Pointer.getPeer(M), Pointer.getPeer(Triple));
	}
	protected native static void LLVMSetTarget(@Ptr long M, @Ptr long Triple);
	/**
	 * Dump a representation of a module to stderr.<br>
	 * @see Module::dump()<br>
	 * Original signature : <code>void LLVMDumpModule(LLVMModuleRef)</code>
	 */
	public static void LLVMDumpModule(LLVMLibrary.LLVMModuleRef M) {
		LLVMDumpModule(Pointer.getPeer(M));
	}
	protected native static void LLVMDumpModule(@Ptr long M);
	/**
	 * Print a representation of a module to a file. The ErrorMessage needs to be<br>
	 * disposed with LLVMDisposeMessage. Returns 0 on success, 1 otherwise.<br>
	 * @see Module::print()<br>
	 * Original signature : <code>LLVMBool LLVMPrintModuleToFile(LLVMModuleRef, const char*, char**)</code>
	 */
	public static int LLVMPrintModuleToFile(LLVMLibrary.LLVMModuleRef M, Pointer<Byte > Filename, Pointer<Pointer<Byte > > ErrorMessage) {
		return LLVMPrintModuleToFile(Pointer.getPeer(M), Pointer.getPeer(Filename), Pointer.getPeer(ErrorMessage));
	}
	protected native static int LLVMPrintModuleToFile(@Ptr long M, @Ptr long Filename, @Ptr long ErrorMessage);
	/**
	 * Return a string representation of the module. Use<br>
	 * LLVMDisposeMessage to free the string.<br>
	 * @see Module::print()<br>
	 * Original signature : <code>char* LLVMPrintModuleToString(LLVMModuleRef)</code>
	 */
	public static Pointer<Byte > LLVMPrintModuleToString(LLVMLibrary.LLVMModuleRef M) {
		return (Pointer)Pointer.pointerToAddress(LLVMPrintModuleToString(Pointer.getPeer(M)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMPrintModuleToString(@Ptr long M);
	/**
	 * Set inline assembly for a module.<br>
	 * @see Module::setModuleInlineAsm()<br>
	 * Original signature : <code>void LLVMSetModuleInlineAsm(LLVMModuleRef, const char*)</code>
	 */
	public static void LLVMSetModuleInlineAsm(LLVMLibrary.LLVMModuleRef M, Pointer<Byte > Asm) {
		LLVMSetModuleInlineAsm(Pointer.getPeer(M), Pointer.getPeer(Asm));
	}
	protected native static void LLVMSetModuleInlineAsm(@Ptr long M, @Ptr long Asm);
	/**
	 * Obtain the context to which this module is associated.<br>
	 * @see Module::getContext()<br>
	 * Original signature : <code>LLVMContextRef LLVMGetModuleContext(LLVMModuleRef)</code>
	 */
	public static LLVMLibrary.LLVMContextRef LLVMGetModuleContext(LLVMLibrary.LLVMModuleRef M) {
		return new LLVMLibrary.LLVMContextRef(LLVMGetModuleContext(Pointer.getPeer(M)));
	}
	@Ptr 
	protected native static long LLVMGetModuleContext(@Ptr long M);
	/**
	 * Obtain a Type from a module by its registered name.<br>
	 * Original signature : <code>LLVMTypeRef LLVMGetTypeByName(LLVMModuleRef, const char*)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMGetTypeByName(LLVMLibrary.LLVMModuleRef M, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMTypeRef(LLVMGetTypeByName(Pointer.getPeer(M), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMGetTypeByName(@Ptr long M, @Ptr long Name);
	/**
	 * Obtain the number of operands for named metadata in a module.<br>
	 * @see llvm::Module::getNamedMetadata()<br>
	 * Original signature : <code>int LLVMGetNamedMetadataNumOperands(LLVMModuleRef, const char*)</code>
	 */
	public static int LLVMGetNamedMetadataNumOperands(LLVMLibrary.LLVMModuleRef M, Pointer<Byte > Name) {
		return LLVMGetNamedMetadataNumOperands(Pointer.getPeer(M), Pointer.getPeer(Name));
	}
	protected native static int LLVMGetNamedMetadataNumOperands(@Ptr long M, @Ptr long Name);
	/**
	 * Obtain the named metadata operands for a module.<br>
	 * The passed LLVMValueRef pointer should refer to an array of<br>
	 * LLVMValueRef at least LLVMGetNamedMetadataNumOperands long. This<br>
	 * array will be populated with the LLVMValueRef instances. Each<br>
	 * instance corresponds to a llvm::MDNode.<br>
	 * @see llvm::Module::getNamedMetadata()<br>
	 * @see llvm::MDNode::getOperand()<br>
	 * Original signature : <code>void LLVMGetNamedMetadataOperands(LLVMModuleRef, const char*, LLVMValueRef*)</code>
	 */
	public static void LLVMGetNamedMetadataOperands(LLVMLibrary.LLVMModuleRef M, Pointer<Byte > Name, Pointer<LLVMLibrary.LLVMValueRef > Dest) {
		LLVMGetNamedMetadataOperands(Pointer.getPeer(M), Pointer.getPeer(Name), Pointer.getPeer(Dest));
	}
	protected native static void LLVMGetNamedMetadataOperands(@Ptr long M, @Ptr long Name, @Ptr long Dest);
	/**
	 * Add an operand to named metadata.<br>
	 * @see llvm::Module::getNamedMetadata()<br>
	 * @see llvm::MDNode::addOperand()<br>
	 * Original signature : <code>void LLVMAddNamedMetadataOperand(LLVMModuleRef, const char*, LLVMValueRef)</code>
	 */
	public static void LLVMAddNamedMetadataOperand(LLVMLibrary.LLVMModuleRef M, Pointer<Byte > Name, LLVMLibrary.LLVMValueRef Val) {
		LLVMAddNamedMetadataOperand(Pointer.getPeer(M), Pointer.getPeer(Name), Pointer.getPeer(Val));
	}
	protected native static void LLVMAddNamedMetadataOperand(@Ptr long M, @Ptr long Name, @Ptr long Val);
	/**
	 * Add a function to a module under a specified name.<br>
	 * @see llvm::Function::Create()<br>
	 * Original signature : <code>LLVMValueRef LLVMAddFunction(LLVMModuleRef, const char*, LLVMTypeRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMAddFunction(LLVMLibrary.LLVMModuleRef M, Pointer<Byte > Name, LLVMLibrary.LLVMTypeRef FunctionTy) {
		return new LLVMLibrary.LLVMValueRef(LLVMAddFunction(Pointer.getPeer(M), Pointer.getPeer(Name), Pointer.getPeer(FunctionTy)));
	}
	@Ptr 
	protected native static long LLVMAddFunction(@Ptr long M, @Ptr long Name, @Ptr long FunctionTy);
	/**
	 * Obtain a Function value from a Module by its name.<br>
	 * The returned value corresponds to a llvm::Function value.<br>
	 * @see llvm::Module::getFunction()<br>
	 * Original signature : <code>LLVMValueRef LLVMGetNamedFunction(LLVMModuleRef, const char*)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetNamedFunction(LLVMLibrary.LLVMModuleRef M, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetNamedFunction(Pointer.getPeer(M), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMGetNamedFunction(@Ptr long M, @Ptr long Name);
	/**
	 * Obtain an iterator to the first Function in a Module.<br>
	 * @see llvm::Module::begin()<br>
	 * Original signature : <code>LLVMValueRef LLVMGetFirstFunction(LLVMModuleRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetFirstFunction(LLVMLibrary.LLVMModuleRef M) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetFirstFunction(Pointer.getPeer(M)));
	}
	@Ptr 
	protected native static long LLVMGetFirstFunction(@Ptr long M);
	/**
	 * Obtain an iterator to the last Function in a Module.<br>
	 * @see llvm::Module::end()<br>
	 * Original signature : <code>LLVMValueRef LLVMGetLastFunction(LLVMModuleRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetLastFunction(LLVMLibrary.LLVMModuleRef M) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetLastFunction(Pointer.getPeer(M)));
	}
	@Ptr 
	protected native static long LLVMGetLastFunction(@Ptr long M);
	/**
	 * Advance a Function iterator to the next Function.<br>
	 * Returns NULL if the iterator was already at the end and there are no more<br>
	 * functions.<br>
	 * Original signature : <code>LLVMValueRef LLVMGetNextFunction(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetNextFunction(LLVMLibrary.LLVMValueRef Fn) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetNextFunction(Pointer.getPeer(Fn)));
	}
	@Ptr 
	protected native static long LLVMGetNextFunction(@Ptr long Fn);
	/**
	 * Decrement a Function iterator to the previous Function.<br>
	 * Returns NULL if the iterator was already at the beginning and there are<br>
	 * no previous functions.<br>
	 * Original signature : <code>LLVMValueRef LLVMGetPreviousFunction(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetPreviousFunction(LLVMLibrary.LLVMValueRef Fn) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetPreviousFunction(Pointer.getPeer(Fn)));
	}
	@Ptr 
	protected native static long LLVMGetPreviousFunction(@Ptr long Fn);
	/**
	 * Obtain the enumerated type of a Type instance.<br>
	 * @see llvm::Type:getTypeID()<br>
	 * Original signature : <code>LLVMTypeKind LLVMGetTypeKind(LLVMTypeRef)</code>
	 */
	public static IntValuedEnum<LLVMLibrary.LLVMTypeKind > LLVMGetTypeKind(LLVMLibrary.LLVMTypeRef Ty) {
		return FlagSet.fromValue(LLVMGetTypeKind(Pointer.getPeer(Ty)), LLVMLibrary.LLVMTypeKind.class);
	}
	protected native static int LLVMGetTypeKind(@Ptr long Ty);
	/**
	 * Whether the type has a known size.<br>
	 * Things that don't have a size are abstract types, labels, and void.a<br>
	 * @see llvm::Type::isSized()<br>
	 * Original signature : <code>LLVMBool LLVMTypeIsSized(LLVMTypeRef)</code>
	 */
	public static int LLVMTypeIsSized(LLVMLibrary.LLVMTypeRef Ty) {
		return LLVMTypeIsSized(Pointer.getPeer(Ty));
	}
	protected native static int LLVMTypeIsSized(@Ptr long Ty);
	/**
	 * Obtain the context to which this type instance is associated.<br>
	 * @see llvm::Type::getContext()<br>
	 * Original signature : <code>LLVMContextRef LLVMGetTypeContext(LLVMTypeRef)</code>
	 */
	public static LLVMLibrary.LLVMContextRef LLVMGetTypeContext(LLVMLibrary.LLVMTypeRef Ty) {
		return new LLVMLibrary.LLVMContextRef(LLVMGetTypeContext(Pointer.getPeer(Ty)));
	}
	@Ptr 
	protected native static long LLVMGetTypeContext(@Ptr long Ty);
	/**
	 * Dump a representation of a type to stderr.<br>
	 * @see llvm::Type::dump()<br>
	 * Original signature : <code>void LLVMDumpType(LLVMTypeRef)</code>
	 */
	public static void LLVMDumpType(LLVMLibrary.LLVMTypeRef Val) {
		LLVMDumpType(Pointer.getPeer(Val));
	}
	protected native static void LLVMDumpType(@Ptr long Val);
	/**
	 * Return a string representation of the type. Use<br>
	 * LLVMDisposeMessage to free the string.<br>
	 * @see llvm::Type::print()<br>
	 * Original signature : <code>char* LLVMPrintTypeToString(LLVMTypeRef)</code>
	 */
	public static Pointer<Byte > LLVMPrintTypeToString(LLVMLibrary.LLVMTypeRef Val) {
		return (Pointer)Pointer.pointerToAddress(LLVMPrintTypeToString(Pointer.getPeer(Val)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMPrintTypeToString(@Ptr long Val);
	/**
	 * Obtain an integer type from a context with specified bit width.<br>
	 * Original signature : <code>LLVMTypeRef LLVMInt1TypeInContext(LLVMContextRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMInt1TypeInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMTypeRef(LLVMInt1TypeInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMInt1TypeInContext(@Ptr long C);
	/** Original signature : <code>LLVMTypeRef LLVMInt8TypeInContext(LLVMContextRef)</code> */
	public static LLVMLibrary.LLVMTypeRef LLVMInt8TypeInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMTypeRef(LLVMInt8TypeInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMInt8TypeInContext(@Ptr long C);
	/** Original signature : <code>LLVMTypeRef LLVMInt16TypeInContext(LLVMContextRef)</code> */
	public static LLVMLibrary.LLVMTypeRef LLVMInt16TypeInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMTypeRef(LLVMInt16TypeInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMInt16TypeInContext(@Ptr long C);
	/** Original signature : <code>LLVMTypeRef LLVMInt32TypeInContext(LLVMContextRef)</code> */
	public static LLVMLibrary.LLVMTypeRef LLVMInt32TypeInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMTypeRef(LLVMInt32TypeInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMInt32TypeInContext(@Ptr long C);
	/** Original signature : <code>LLVMTypeRef LLVMInt64TypeInContext(LLVMContextRef)</code> */
	public static LLVMLibrary.LLVMTypeRef LLVMInt64TypeInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMTypeRef(LLVMInt64TypeInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMInt64TypeInContext(@Ptr long C);
	/** Original signature : <code>LLVMTypeRef LLVMInt128TypeInContext(LLVMContextRef)</code> */
	public static LLVMLibrary.LLVMTypeRef LLVMInt128TypeInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMTypeRef(LLVMInt128TypeInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMInt128TypeInContext(@Ptr long C);
	/** Original signature : <code>LLVMTypeRef LLVMIntTypeInContext(LLVMContextRef, unsigned)</code> */
	public static LLVMLibrary.LLVMTypeRef LLVMIntTypeInContext(LLVMLibrary.LLVMContextRef C, int NumBits) {
		return new LLVMLibrary.LLVMTypeRef(LLVMIntTypeInContext(Pointer.getPeer(C), NumBits));
	}
	@Ptr 
	protected native static long LLVMIntTypeInContext(@Ptr long C, int NumBits);
	/**
	 * Obtain an integer type from the global context with a specified bit<br>
	 * width.<br>
	 * Original signature : <code>LLVMTypeRef LLVMInt1Type()</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMInt1Type() {
		return new LLVMLibrary.LLVMTypeRef(LLVMInt1Type$2());
	}
	@Ptr 
	@Name("LLVMInt1Type") 
	protected native static long LLVMInt1Type$2();
	/** Original signature : <code>LLVMTypeRef LLVMInt8Type()</code> */
	public static LLVMLibrary.LLVMTypeRef LLVMInt8Type() {
		return new LLVMLibrary.LLVMTypeRef(LLVMInt8Type$2());
	}
	@Ptr 
	@Name("LLVMInt8Type") 
	protected native static long LLVMInt8Type$2();
	/** Original signature : <code>LLVMTypeRef LLVMInt16Type()</code> */
	public static LLVMLibrary.LLVMTypeRef LLVMInt16Type() {
		return new LLVMLibrary.LLVMTypeRef(LLVMInt16Type$2());
	}
	@Ptr 
	@Name("LLVMInt16Type") 
	protected native static long LLVMInt16Type$2();
	/** Original signature : <code>LLVMTypeRef LLVMInt32Type()</code> */
	public static LLVMLibrary.LLVMTypeRef LLVMInt32Type() {
		return new LLVMLibrary.LLVMTypeRef(LLVMInt32Type$2());
	}
	@Ptr 
	@Name("LLVMInt32Type") 
	protected native static long LLVMInt32Type$2();
	/** Original signature : <code>LLVMTypeRef LLVMInt64Type()</code> */
	public static LLVMLibrary.LLVMTypeRef LLVMInt64Type() {
		return new LLVMLibrary.LLVMTypeRef(LLVMInt64Type$2());
	}
	@Ptr 
	@Name("LLVMInt64Type") 
	protected native static long LLVMInt64Type$2();
	/** Original signature : <code>LLVMTypeRef LLVMInt128Type()</code> */
	public static LLVMLibrary.LLVMTypeRef LLVMInt128Type() {
		return new LLVMLibrary.LLVMTypeRef(LLVMInt128Type$2());
	}
	@Ptr 
	@Name("LLVMInt128Type") 
	protected native static long LLVMInt128Type$2();
	/** Original signature : <code>LLVMTypeRef LLVMIntType(unsigned)</code> */
	public static LLVMLibrary.LLVMTypeRef LLVMIntType(int NumBits) {
		return new LLVMLibrary.LLVMTypeRef(LLVMIntType$2(NumBits));
	}
	@Ptr 
	@Name("LLVMIntType") 
	protected native static long LLVMIntType$2(int NumBits);
	/** Original signature : <code>int LLVMGetIntTypeWidth(LLVMTypeRef)</code> */
	public static int LLVMGetIntTypeWidth(LLVMLibrary.LLVMTypeRef IntegerTy) {
		return LLVMGetIntTypeWidth(Pointer.getPeer(IntegerTy));
	}
	protected native static int LLVMGetIntTypeWidth(@Ptr long IntegerTy);
	/**
	 * Obtain a 16-bit floating point type from a context.<br>
	 * Original signature : <code>LLVMTypeRef LLVMHalfTypeInContext(LLVMContextRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMHalfTypeInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMTypeRef(LLVMHalfTypeInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMHalfTypeInContext(@Ptr long C);
	/**
	 * Obtain a 32-bit floating point type from a context.<br>
	 * Original signature : <code>LLVMTypeRef LLVMFloatTypeInContext(LLVMContextRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMFloatTypeInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMTypeRef(LLVMFloatTypeInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMFloatTypeInContext(@Ptr long C);
	/**
	 * Obtain a 64-bit floating point type from a context.<br>
	 * Original signature : <code>LLVMTypeRef LLVMDoubleTypeInContext(LLVMContextRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMDoubleTypeInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMTypeRef(LLVMDoubleTypeInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMDoubleTypeInContext(@Ptr long C);
	/**
	 * Obtain a 80-bit floating point type (X87) from a context.<br>
	 * Original signature : <code>LLVMTypeRef LLVMX86FP80TypeInContext(LLVMContextRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMX86FP80TypeInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMTypeRef(LLVMX86FP80TypeInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMX86FP80TypeInContext(@Ptr long C);
	/**
	 * Obtain a 128-bit floating point type (112-bit mantissa) from a<br>
	 * context.<br>
	 * Original signature : <code>LLVMTypeRef LLVMFP128TypeInContext(LLVMContextRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMFP128TypeInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMTypeRef(LLVMFP128TypeInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMFP128TypeInContext(@Ptr long C);
	/**
	 * Obtain a 128-bit floating point type (two 64-bits) from a context.<br>
	 * Original signature : <code>LLVMTypeRef LLVMPPCFP128TypeInContext(LLVMContextRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMPPCFP128TypeInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMTypeRef(LLVMPPCFP128TypeInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMPPCFP128TypeInContext(@Ptr long C);
	/**
	 * Obtain a floating point type from the global context.<br>
	 * These map to the functions in this group of the same name.<br>
	 * Original signature : <code>LLVMTypeRef LLVMHalfType()</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMHalfType() {
		return new LLVMLibrary.LLVMTypeRef(LLVMHalfType$2());
	}
	@Ptr 
	@Name("LLVMHalfType") 
	protected native static long LLVMHalfType$2();
	/** Original signature : <code>LLVMTypeRef LLVMFloatType()</code> */
	public static LLVMLibrary.LLVMTypeRef LLVMFloatType() {
		return new LLVMLibrary.LLVMTypeRef(LLVMFloatType$2());
	}
	@Ptr 
	@Name("LLVMFloatType") 
	protected native static long LLVMFloatType$2();
	/** Original signature : <code>LLVMTypeRef LLVMDoubleType()</code> */
	public static LLVMLibrary.LLVMTypeRef LLVMDoubleType() {
		return new LLVMLibrary.LLVMTypeRef(LLVMDoubleType$2());
	}
	@Ptr 
	@Name("LLVMDoubleType") 
	protected native static long LLVMDoubleType$2();
	/** Original signature : <code>LLVMTypeRef LLVMX86FP80Type()</code> */
	public static LLVMLibrary.LLVMTypeRef LLVMX86FP80Type() {
		return new LLVMLibrary.LLVMTypeRef(LLVMX86FP80Type$2());
	}
	@Ptr 
	@Name("LLVMX86FP80Type") 
	protected native static long LLVMX86FP80Type$2();
	/** Original signature : <code>LLVMTypeRef LLVMFP128Type()</code> */
	public static LLVMLibrary.LLVMTypeRef LLVMFP128Type() {
		return new LLVMLibrary.LLVMTypeRef(LLVMFP128Type$2());
	}
	@Ptr 
	@Name("LLVMFP128Type") 
	protected native static long LLVMFP128Type$2();
	/** Original signature : <code>LLVMTypeRef LLVMPPCFP128Type()</code> */
	public static LLVMLibrary.LLVMTypeRef LLVMPPCFP128Type() {
		return new LLVMLibrary.LLVMTypeRef(LLVMPPCFP128Type$2());
	}
	@Ptr 
	@Name("LLVMPPCFP128Type") 
	protected native static long LLVMPPCFP128Type$2();
	/**
	 * Obtain a function type consisting of a specified signature.<br>
	 * The function is defined as a tuple of a return Type, a list of<br>
	 * parameter types, and whether the function is variadic.<br>
	 * Original signature : <code>LLVMTypeRef LLVMFunctionType(LLVMTypeRef, LLVMTypeRef*, unsigned, LLVMBool)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMFunctionType(LLVMLibrary.LLVMTypeRef ReturnType, Pointer<LLVMLibrary.LLVMTypeRef > ParamTypes, int ParamCount, int IsVarArg) {
		return new LLVMLibrary.LLVMTypeRef(LLVMFunctionType(Pointer.getPeer(ReturnType), Pointer.getPeer(ParamTypes), ParamCount, IsVarArg));
	}
	@Ptr 
	protected native static long LLVMFunctionType(@Ptr long ReturnType, @Ptr long ParamTypes, int ParamCount, int IsVarArg);
	/**
	 * Returns whether a function type is variadic.<br>
	 * Original signature : <code>LLVMBool LLVMIsFunctionVarArg(LLVMTypeRef)</code>
	 */
	public static int LLVMIsFunctionVarArg(LLVMLibrary.LLVMTypeRef FunctionTy) {
		return LLVMIsFunctionVarArg(Pointer.getPeer(FunctionTy));
	}
	protected native static int LLVMIsFunctionVarArg(@Ptr long FunctionTy);
	/**
	 * Obtain the Type this function Type returns.<br>
	 * Original signature : <code>LLVMTypeRef LLVMGetReturnType(LLVMTypeRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMGetReturnType(LLVMLibrary.LLVMTypeRef FunctionTy) {
		return new LLVMLibrary.LLVMTypeRef(LLVMGetReturnType(Pointer.getPeer(FunctionTy)));
	}
	@Ptr 
	protected native static long LLVMGetReturnType(@Ptr long FunctionTy);
	/**
	 * Obtain the number of parameters this function accepts.<br>
	 * Original signature : <code>int LLVMCountParamTypes(LLVMTypeRef)</code>
	 */
	public static int LLVMCountParamTypes(LLVMLibrary.LLVMTypeRef FunctionTy) {
		return LLVMCountParamTypes(Pointer.getPeer(FunctionTy));
	}
	protected native static int LLVMCountParamTypes(@Ptr long FunctionTy);
	/**
	 * Obtain the types of a function's parameters.<br>
	 * The Dest parameter should point to a pre-allocated array of<br>
	 * LLVMTypeRef at least LLVMCountParamTypes() large. On return, the<br>
	 * first LLVMCountParamTypes() entries in the array will be populated<br>
	 * with LLVMTypeRef instances.<br>
	 * @param FunctionTy The function type to operate on.<br>
	 * @param Dest Memory address of an array to be filled with result.<br>
	 * Original signature : <code>void LLVMGetParamTypes(LLVMTypeRef, LLVMTypeRef*)</code>
	 */
	public static void LLVMGetParamTypes(LLVMLibrary.LLVMTypeRef FunctionTy, Pointer<LLVMLibrary.LLVMTypeRef > Dest) {
		LLVMGetParamTypes(Pointer.getPeer(FunctionTy), Pointer.getPeer(Dest));
	}
	protected native static void LLVMGetParamTypes(@Ptr long FunctionTy, @Ptr long Dest);
	/**
	 * Create a new structure type in a context.<br>
	 * A structure is specified by a list of inner elements/types and<br>
	 * whether these can be packed together.<br>
	 * @see llvm::StructType::create()<br>
	 * Original signature : <code>LLVMTypeRef LLVMStructTypeInContext(LLVMContextRef, LLVMTypeRef*, unsigned, LLVMBool)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMStructTypeInContext(LLVMLibrary.LLVMContextRef C, Pointer<LLVMLibrary.LLVMTypeRef > ElementTypes, int ElementCount, int Packed) {
		return new LLVMLibrary.LLVMTypeRef(LLVMStructTypeInContext(Pointer.getPeer(C), Pointer.getPeer(ElementTypes), ElementCount, Packed));
	}
	@Ptr 
	protected native static long LLVMStructTypeInContext(@Ptr long C, @Ptr long ElementTypes, int ElementCount, int Packed);
	/**
	 * Create a new structure type in the global context.<br>
	 * @see llvm::StructType::create()<br>
	 * Original signature : <code>LLVMTypeRef LLVMStructType(LLVMTypeRef*, unsigned, LLVMBool)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMStructType(Pointer<LLVMLibrary.LLVMTypeRef > ElementTypes, int ElementCount, int Packed) {
		return new LLVMLibrary.LLVMTypeRef(LLVMStructType(Pointer.getPeer(ElementTypes), ElementCount, Packed));
	}
	@Ptr 
	protected native static long LLVMStructType(@Ptr long ElementTypes, int ElementCount, int Packed);
	/**
	 * Create an empty structure in a context having a specified name.<br>
	 * @see llvm::StructType::create()<br>
	 * Original signature : <code>LLVMTypeRef LLVMStructCreateNamed(LLVMContextRef, const char*)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMStructCreateNamed(LLVMLibrary.LLVMContextRef C, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMTypeRef(LLVMStructCreateNamed(Pointer.getPeer(C), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMStructCreateNamed(@Ptr long C, @Ptr long Name);
	/**
	 * Obtain the name of a structure.<br>
	 * @see llvm::StructType::getName()<br>
	 * Original signature : <code>char* LLVMGetStructName(LLVMTypeRef)</code>
	 */
	public static Pointer<Byte > LLVMGetStructName(LLVMLibrary.LLVMTypeRef Ty) {
		return (Pointer)Pointer.pointerToAddress(LLVMGetStructName(Pointer.getPeer(Ty)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetStructName(@Ptr long Ty);
	/**
	 * Set the contents of a structure type.<br>
	 * @see llvm::StructType::setBody()<br>
	 * Original signature : <code>void LLVMStructSetBody(LLVMTypeRef, LLVMTypeRef*, unsigned, LLVMBool)</code>
	 */
	public static void LLVMStructSetBody(LLVMLibrary.LLVMTypeRef StructTy, Pointer<LLVMLibrary.LLVMTypeRef > ElementTypes, int ElementCount, int Packed) {
		LLVMStructSetBody(Pointer.getPeer(StructTy), Pointer.getPeer(ElementTypes), ElementCount, Packed);
	}
	protected native static void LLVMStructSetBody(@Ptr long StructTy, @Ptr long ElementTypes, int ElementCount, int Packed);
	/**
	 * Get the number of elements defined inside the structure.<br>
	 * @see llvm::StructType::getNumElements()<br>
	 * Original signature : <code>int LLVMCountStructElementTypes(LLVMTypeRef)</code>
	 */
	public static int LLVMCountStructElementTypes(LLVMLibrary.LLVMTypeRef StructTy) {
		return LLVMCountStructElementTypes(Pointer.getPeer(StructTy));
	}
	protected native static int LLVMCountStructElementTypes(@Ptr long StructTy);
	/**
	 * Get the elements within a structure.<br>
	 * The function is passed the address of a pre-allocated array of<br>
	 * LLVMTypeRef at least LLVMCountStructElementTypes() long. After<br>
	 * invocation, this array will be populated with the structure's<br>
	 * elements. The objects in the destination array will have a lifetime<br>
	 * of the structure type itself, which is the lifetime of the context it<br>
	 * is contained in.<br>
	 * Original signature : <code>void LLVMGetStructElementTypes(LLVMTypeRef, LLVMTypeRef*)</code>
	 */
	public static void LLVMGetStructElementTypes(LLVMLibrary.LLVMTypeRef StructTy, Pointer<LLVMLibrary.LLVMTypeRef > Dest) {
		LLVMGetStructElementTypes(Pointer.getPeer(StructTy), Pointer.getPeer(Dest));
	}
	protected native static void LLVMGetStructElementTypes(@Ptr long StructTy, @Ptr long Dest);
	/**
	 * Get the type of the element at a given index in the structure.<br>
	 * @see llvm::StructType::getTypeAtIndex()<br>
	 * Original signature : <code>LLVMTypeRef LLVMStructGetTypeAtIndex(LLVMTypeRef, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMStructGetTypeAtIndex(LLVMLibrary.LLVMTypeRef StructTy, int i) {
		return new LLVMLibrary.LLVMTypeRef(LLVMStructGetTypeAtIndex(Pointer.getPeer(StructTy), i));
	}
	@Ptr 
	protected native static long LLVMStructGetTypeAtIndex(@Ptr long StructTy, int i);
	/**
	 * Determine whether a structure is packed.<br>
	 * @see llvm::StructType::isPacked()<br>
	 * Original signature : <code>LLVMBool LLVMIsPackedStruct(LLVMTypeRef)</code>
	 */
	public static int LLVMIsPackedStruct(LLVMLibrary.LLVMTypeRef StructTy) {
		return LLVMIsPackedStruct(Pointer.getPeer(StructTy));
	}
	protected native static int LLVMIsPackedStruct(@Ptr long StructTy);
	/**
	 * Determine whether a structure is opaque.<br>
	 * @see llvm::StructType::isOpaque()<br>
	 * Original signature : <code>LLVMBool LLVMIsOpaqueStruct(LLVMTypeRef)</code>
	 */
	public static int LLVMIsOpaqueStruct(LLVMLibrary.LLVMTypeRef StructTy) {
		return LLVMIsOpaqueStruct(Pointer.getPeer(StructTy));
	}
	protected native static int LLVMIsOpaqueStruct(@Ptr long StructTy);
	/**
	 * Obtain the type of elements within a sequential type.<br>
	 * This works on array, vector, and pointer types.<br>
	 * @see llvm::SequentialType::getElementType()<br>
	 * Original signature : <code>LLVMTypeRef LLVMGetElementType(LLVMTypeRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMGetElementType(LLVMLibrary.LLVMTypeRef Ty) {
		return new LLVMLibrary.LLVMTypeRef(LLVMGetElementType(Pointer.getPeer(Ty)));
	}
	@Ptr 
	protected native static long LLVMGetElementType(@Ptr long Ty);
	/**
	 * Create a fixed size array type that refers to a specific type.<br>
	 * The created type will exist in the context that its element type<br>
	 * exists in.<br>
	 * @see llvm::ArrayType::get()<br>
	 * Original signature : <code>LLVMTypeRef LLVMArrayType(LLVMTypeRef, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMArrayType(LLVMLibrary.LLVMTypeRef ElementType, int ElementCount) {
		return new LLVMLibrary.LLVMTypeRef(LLVMArrayType(Pointer.getPeer(ElementType), ElementCount));
	}
	@Ptr 
	protected native static long LLVMArrayType(@Ptr long ElementType, int ElementCount);
	/**
	 * Obtain the length of an array type.<br>
	 * This only works on types that represent arrays.<br>
	 * @see llvm::ArrayType::getNumElements()<br>
	 * Original signature : <code>int LLVMGetArrayLength(LLVMTypeRef)</code>
	 */
	public static int LLVMGetArrayLength(LLVMLibrary.LLVMTypeRef ArrayTy) {
		return LLVMGetArrayLength(Pointer.getPeer(ArrayTy));
	}
	protected native static int LLVMGetArrayLength(@Ptr long ArrayTy);
	/**
	 * Create a pointer type that points to a defined type.<br>
	 * The created type will exist in the context that its pointee type<br>
	 * exists in.<br>
	 * @see llvm::PointerType::get()<br>
	 * Original signature : <code>LLVMTypeRef LLVMPointerType(LLVMTypeRef, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMPointerType(LLVMLibrary.LLVMTypeRef ElementType, int AddressSpace) {
		return new LLVMLibrary.LLVMTypeRef(LLVMPointerType(Pointer.getPeer(ElementType), AddressSpace));
	}
	@Ptr 
	protected native static long LLVMPointerType(@Ptr long ElementType, int AddressSpace);
	/**
	 * Obtain the address space of a pointer type.<br>
	 * This only works on types that represent pointers.<br>
	 * @see llvm::PointerType::getAddressSpace()<br>
	 * Original signature : <code>int LLVMGetPointerAddressSpace(LLVMTypeRef)</code>
	 */
	public static int LLVMGetPointerAddressSpace(LLVMLibrary.LLVMTypeRef PointerTy) {
		return LLVMGetPointerAddressSpace(Pointer.getPeer(PointerTy));
	}
	protected native static int LLVMGetPointerAddressSpace(@Ptr long PointerTy);
	/**
	 * Create a vector type that contains a defined type and has a specific<br>
	 * number of elements.<br>
	 * The created type will exist in the context thats its element type<br>
	 * exists in.<br>
	 * @see llvm::VectorType::get()<br>
	 * Original signature : <code>LLVMTypeRef LLVMVectorType(LLVMTypeRef, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMVectorType(LLVMLibrary.LLVMTypeRef ElementType, int ElementCount) {
		return new LLVMLibrary.LLVMTypeRef(LLVMVectorType(Pointer.getPeer(ElementType), ElementCount));
	}
	@Ptr 
	protected native static long LLVMVectorType(@Ptr long ElementType, int ElementCount);
	/**
	 * Obtain the number of elements in a vector type.<br>
	 * This only works on types that represent vectors.<br>
	 * @see llvm::VectorType::getNumElements()<br>
	 * Original signature : <code>int LLVMGetVectorSize(LLVMTypeRef)</code>
	 */
	public static int LLVMGetVectorSize(LLVMLibrary.LLVMTypeRef VectorTy) {
		return LLVMGetVectorSize(Pointer.getPeer(VectorTy));
	}
	protected native static int LLVMGetVectorSize(@Ptr long VectorTy);
	/**
	 * Create a void type in a context.<br>
	 * Original signature : <code>LLVMTypeRef LLVMVoidTypeInContext(LLVMContextRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMVoidTypeInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMTypeRef(LLVMVoidTypeInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMVoidTypeInContext(@Ptr long C);
	/**
	 * Create a label type in a context.<br>
	 * Original signature : <code>LLVMTypeRef LLVMLabelTypeInContext(LLVMContextRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMLabelTypeInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMTypeRef(LLVMLabelTypeInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMLabelTypeInContext(@Ptr long C);
	/**
	 * Create a X86 MMX type in a context.<br>
	 * Original signature : <code>LLVMTypeRef LLVMX86MMXTypeInContext(LLVMContextRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMX86MMXTypeInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMTypeRef(LLVMX86MMXTypeInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMX86MMXTypeInContext(@Ptr long C);
	/**
	 * These are similar to the above functions except they operate on the<br>
	 * global context.<br>
	 * Original signature : <code>LLVMTypeRef LLVMVoidType()</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMVoidType() {
		return new LLVMLibrary.LLVMTypeRef(LLVMVoidType$2());
	}
	@Ptr 
	@Name("LLVMVoidType") 
	protected native static long LLVMVoidType$2();
	/** Original signature : <code>LLVMTypeRef LLVMLabelType()</code> */
	public static LLVMLibrary.LLVMTypeRef LLVMLabelType() {
		return new LLVMLibrary.LLVMTypeRef(LLVMLabelType$2());
	}
	@Ptr 
	@Name("LLVMLabelType") 
	protected native static long LLVMLabelType$2();
	/** Original signature : <code>LLVMTypeRef LLVMX86MMXType()</code> */
	public static LLVMLibrary.LLVMTypeRef LLVMX86MMXType() {
		return new LLVMLibrary.LLVMTypeRef(LLVMX86MMXType$2());
	}
	@Ptr 
	@Name("LLVMX86MMXType") 
	protected native static long LLVMX86MMXType$2();
	/**
	 * Obtain the type of a value.<br>
	 * @see llvm::Value::getType()<br>
	 * Original signature : <code>LLVMTypeRef LLVMTypeOf(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMTypeOf(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMTypeRef(LLVMTypeOf(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMTypeOf(@Ptr long Val);
	/**
	 * Obtain the enumerated type of a Value instance.<br>
	 * @see llvm::Value::getValueID()<br>
	 * Original signature : <code>LLVMValueKind LLVMGetValueKind(LLVMValueRef)</code>
	 */
	public static IntValuedEnum<LLVMLibrary.LLVMValueKind > LLVMGetValueKind(LLVMLibrary.LLVMValueRef Val) {
		return FlagSet.fromValue(LLVMGetValueKind(Pointer.getPeer(Val)), LLVMLibrary.LLVMValueKind.class);
	}
	protected native static int LLVMGetValueKind(@Ptr long Val);
	/**
	 * Obtain the string name of a value.<br>
	 * @see llvm::Value::getName()<br>
	 * Original signature : <code>char* LLVMGetValueName(LLVMValueRef)</code>
	 */
	public static Pointer<Byte > LLVMGetValueName(LLVMLibrary.LLVMValueRef Val) {
		return (Pointer)Pointer.pointerToAddress(LLVMGetValueName(Pointer.getPeer(Val)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetValueName(@Ptr long Val);
	/**
	 * Set the string name of a value.<br>
	 * @see llvm::Value::setName()<br>
	 * Original signature : <code>void LLVMSetValueName(LLVMValueRef, const char*)</code>
	 */
	public static void LLVMSetValueName(LLVMLibrary.LLVMValueRef Val, Pointer<Byte > Name) {
		LLVMSetValueName(Pointer.getPeer(Val), Pointer.getPeer(Name));
	}
	protected native static void LLVMSetValueName(@Ptr long Val, @Ptr long Name);
	/**
	 * Dump a representation of a value to stderr.<br>
	 * @see llvm::Value::dump()<br>
	 * Original signature : <code>void LLVMDumpValue(LLVMValueRef)</code>
	 */
	public static void LLVMDumpValue(LLVMLibrary.LLVMValueRef Val) {
		LLVMDumpValue(Pointer.getPeer(Val));
	}
	protected native static void LLVMDumpValue(@Ptr long Val);
	/**
	 * Return a string representation of the value. Use<br>
	 * LLVMDisposeMessage to free the string.<br>
	 * @see llvm::Value::print()<br>
	 * Original signature : <code>char* LLVMPrintValueToString(LLVMValueRef)</code>
	 */
	public static Pointer<Byte > LLVMPrintValueToString(LLVMLibrary.LLVMValueRef Val) {
		return (Pointer)Pointer.pointerToAddress(LLVMPrintValueToString(Pointer.getPeer(Val)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMPrintValueToString(@Ptr long Val);
	/**
	 * Replace all uses of a value with another one.<br>
	 * @see llvm::Value::replaceAllUsesWith()<br>
	 * Original signature : <code>void LLVMReplaceAllUsesWith(LLVMValueRef, LLVMValueRef)</code>
	 */
	public static void LLVMReplaceAllUsesWith(LLVMLibrary.LLVMValueRef OldVal, LLVMLibrary.LLVMValueRef NewVal) {
		LLVMReplaceAllUsesWith(Pointer.getPeer(OldVal), Pointer.getPeer(NewVal));
	}
	protected native static void LLVMReplaceAllUsesWith(@Ptr long OldVal, @Ptr long NewVal);
	/**
	 * Determine whether the specified value instance is constant.<br>
	 * Original signature : <code>LLVMBool LLVMIsConstant(LLVMValueRef)</code>
	 */
	public static int LLVMIsConstant(LLVMLibrary.LLVMValueRef Val) {
		return LLVMIsConstant(Pointer.getPeer(Val));
	}
	protected native static int LLVMIsConstant(@Ptr long Val);
	/**
	 * Determine whether a value instance is undefined.<br>
	 * Original signature : <code>LLVMBool LLVMIsUndef(LLVMValueRef)</code>
	 */
	public static int LLVMIsUndef(LLVMLibrary.LLVMValueRef Val) {
		return LLVMIsUndef(Pointer.getPeer(Val));
	}
	protected native static int LLVMIsUndef(@Ptr long Val);
	/**
	 * Convert value instances between types.<br>
	 * Internally, an LLVMValueRef is "pinned" to a specific type. This<br>
	 * series of functions allows you to cast an instance to a specific<br>
	 * type.<br>
	 * If the cast is not valid for the specified type, NULL is returned.<br>
	 * @see llvm::dyn_cast_or_null<><br>
	 * Original signature : <code>LLVMValueRef LLVMIsAArgument(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMIsAArgument(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAArgument(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAArgument(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsABasicBlock(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsABasicBlock(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsABasicBlock(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsABasicBlock(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAInlineAsm(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAInlineAsm(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAInlineAsm(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAInlineAsm(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAUser(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAUser(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAUser(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAUser(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAConstant(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAConstant(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAConstant(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAConstant(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsABlockAddress(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsABlockAddress(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsABlockAddress(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsABlockAddress(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAConstantAggregateZero(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAConstantAggregateZero(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAConstantAggregateZero(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAConstantAggregateZero(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAConstantArray(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAConstantArray(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAConstantArray(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAConstantArray(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAConstantDataSequential(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAConstantDataSequential(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAConstantDataSequential(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAConstantDataSequential(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAConstantDataArray(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAConstantDataArray(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAConstantDataArray(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAConstantDataArray(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAConstantDataVector(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAConstantDataVector(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAConstantDataVector(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAConstantDataVector(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAConstantExpr(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAConstantExpr(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAConstantExpr(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAConstantExpr(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAConstantFP(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAConstantFP(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAConstantFP(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAConstantFP(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAConstantInt(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAConstantInt(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAConstantInt(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAConstantInt(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAConstantPointerNull(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAConstantPointerNull(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAConstantPointerNull(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAConstantPointerNull(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAConstantStruct(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAConstantStruct(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAConstantStruct(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAConstantStruct(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAConstantTokenNone(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAConstantTokenNone(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAConstantTokenNone(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAConstantTokenNone(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAConstantVector(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAConstantVector(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAConstantVector(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAConstantVector(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAGlobalValue(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAGlobalValue(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAGlobalValue(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAGlobalValue(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAGlobalAlias(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAGlobalAlias(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAGlobalAlias(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAGlobalAlias(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAGlobalObject(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAGlobalObject(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAGlobalObject(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAGlobalObject(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAFunction(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAFunction(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAFunction(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAFunction(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAGlobalVariable(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAGlobalVariable(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAGlobalVariable(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAGlobalVariable(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAUndefValue(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAUndefValue(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAUndefValue(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAUndefValue(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAInstruction(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAInstruction(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAInstruction(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAInstruction(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsABinaryOperator(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsABinaryOperator(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsABinaryOperator(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsABinaryOperator(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsACallInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsACallInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsACallInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsACallInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAIntrinsicInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAIntrinsicInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAIntrinsicInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAIntrinsicInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsADbgInfoIntrinsic(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsADbgInfoIntrinsic(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsADbgInfoIntrinsic(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsADbgInfoIntrinsic(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsADbgDeclareInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsADbgDeclareInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsADbgDeclareInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsADbgDeclareInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAMemIntrinsic(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAMemIntrinsic(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAMemIntrinsic(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAMemIntrinsic(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAMemCpyInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAMemCpyInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAMemCpyInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAMemCpyInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAMemMoveInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAMemMoveInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAMemMoveInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAMemMoveInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAMemSetInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAMemSetInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAMemSetInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAMemSetInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsACmpInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsACmpInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsACmpInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsACmpInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAFCmpInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAFCmpInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAFCmpInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAFCmpInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAICmpInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAICmpInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAICmpInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAICmpInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAExtractElementInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAExtractElementInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAExtractElementInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAExtractElementInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAGetElementPtrInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAGetElementPtrInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAGetElementPtrInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAGetElementPtrInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAInsertElementInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAInsertElementInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAInsertElementInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAInsertElementInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAInsertValueInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAInsertValueInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAInsertValueInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAInsertValueInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsALandingPadInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsALandingPadInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsALandingPadInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsALandingPadInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAPHINode(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAPHINode(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAPHINode(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAPHINode(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsASelectInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsASelectInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsASelectInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsASelectInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAShuffleVectorInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAShuffleVectorInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAShuffleVectorInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAShuffleVectorInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAStoreInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAStoreInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAStoreInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAStoreInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsATerminatorInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsATerminatorInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsATerminatorInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsATerminatorInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsABranchInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsABranchInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsABranchInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsABranchInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAIndirectBrInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAIndirectBrInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAIndirectBrInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAIndirectBrInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAInvokeInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAInvokeInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAInvokeInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAInvokeInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAReturnInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAReturnInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAReturnInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAReturnInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsASwitchInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsASwitchInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsASwitchInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsASwitchInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAUnreachableInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAUnreachableInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAUnreachableInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAUnreachableInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAResumeInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAResumeInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAResumeInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAResumeInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsACleanupReturnInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsACleanupReturnInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsACleanupReturnInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsACleanupReturnInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsACatchReturnInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsACatchReturnInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsACatchReturnInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsACatchReturnInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAFuncletPadInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAFuncletPadInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAFuncletPadInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAFuncletPadInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsACatchPadInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsACatchPadInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsACatchPadInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsACatchPadInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsACleanupPadInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsACleanupPadInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsACleanupPadInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsACleanupPadInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAUnaryInstruction(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAUnaryInstruction(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAUnaryInstruction(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAUnaryInstruction(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAAllocaInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAAllocaInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAAllocaInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAAllocaInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsACastInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsACastInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsACastInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsACastInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAAddrSpaceCastInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAAddrSpaceCastInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAAddrSpaceCastInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAAddrSpaceCastInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsABitCastInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsABitCastInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsABitCastInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsABitCastInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAFPExtInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAFPExtInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAFPExtInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAFPExtInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAFPToSIInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAFPToSIInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAFPToSIInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAFPToSIInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAFPToUIInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAFPToUIInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAFPToUIInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAFPToUIInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAFPTruncInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAFPTruncInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAFPTruncInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAFPTruncInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAIntToPtrInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAIntToPtrInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAIntToPtrInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAIntToPtrInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAPtrToIntInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAPtrToIntInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAPtrToIntInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAPtrToIntInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsASExtInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsASExtInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsASExtInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsASExtInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsASIToFPInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsASIToFPInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsASIToFPInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsASIToFPInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsATruncInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsATruncInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsATruncInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsATruncInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAUIToFPInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAUIToFPInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAUIToFPInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAUIToFPInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAZExtInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAZExtInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAZExtInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAZExtInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAExtractValueInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAExtractValueInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAExtractValueInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAExtractValueInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsALoadInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsALoadInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsALoadInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsALoadInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAVAArgInst(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAVAArgInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAVAArgInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAVAArgInst(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAMDNode(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAMDNode(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAMDNode(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAMDNode(@Ptr long Val);
	/** Original signature : <code>LLVMValueRef LLVMIsAMDString(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMIsAMDString(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAMDString(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAMDString(@Ptr long Val);
	/**
	 * Obtain the first use of a value.<br>
	 * Uses are obtained in an iterator fashion. First, call this function<br>
	 * to obtain a reference to the first use. Then, call LLVMGetNextUse()<br>
	 * on that instance and all subsequently obtained instances until<br>
	 * LLVMGetNextUse() returns NULL.<br>
	 * @see llvm::Value::use_begin()<br>
	 * Original signature : <code>LLVMUseRef LLVMGetFirstUse(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMUseRef LLVMGetFirstUse(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMUseRef(LLVMGetFirstUse(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMGetFirstUse(@Ptr long Val);
	/**
	 * Obtain the next use of a value.<br>
	 * This effectively advances the iterator. It returns NULL if you are on<br>
	 * the final use and no more are available.<br>
	 * Original signature : <code>LLVMUseRef LLVMGetNextUse(LLVMUseRef)</code>
	 */
	public static LLVMLibrary.LLVMUseRef LLVMGetNextUse(LLVMLibrary.LLVMUseRef U) {
		return new LLVMLibrary.LLVMUseRef(LLVMGetNextUse(Pointer.getPeer(U)));
	}
	@Ptr 
	protected native static long LLVMGetNextUse(@Ptr long U);
	/**
	 * Obtain the user value for a user.<br>
	 * The returned value corresponds to a llvm::User type.<br>
	 * @see llvm::Use::getUser()<br>
	 * Original signature : <code>LLVMValueRef LLVMGetUser(LLVMUseRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetUser(LLVMLibrary.LLVMUseRef U) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetUser(Pointer.getPeer(U)));
	}
	@Ptr 
	protected native static long LLVMGetUser(@Ptr long U);
	/**
	 * Obtain the value this use corresponds to.<br>
	 * @see llvm::Use::get().<br>
	 * Original signature : <code>LLVMValueRef LLVMGetUsedValue(LLVMUseRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetUsedValue(LLVMLibrary.LLVMUseRef U) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetUsedValue(Pointer.getPeer(U)));
	}
	@Ptr 
	protected native static long LLVMGetUsedValue(@Ptr long U);
	/**
	 * Obtain an operand at a specific index in a llvm::User value.<br>
	 * @see llvm::User::getOperand()<br>
	 * Original signature : <code>LLVMValueRef LLVMGetOperand(LLVMValueRef, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetOperand(LLVMLibrary.LLVMValueRef Val, int Index) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetOperand(Pointer.getPeer(Val), Index));
	}
	@Ptr 
	protected native static long LLVMGetOperand(@Ptr long Val, int Index);
	/**
	 * Obtain the use of an operand at a specific index in a llvm::User value.<br>
	 * @see llvm::User::getOperandUse()<br>
	 * Original signature : <code>LLVMUseRef LLVMGetOperandUse(LLVMValueRef, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMUseRef LLVMGetOperandUse(LLVMLibrary.LLVMValueRef Val, int Index) {
		return new LLVMLibrary.LLVMUseRef(LLVMGetOperandUse(Pointer.getPeer(Val), Index));
	}
	@Ptr 
	protected native static long LLVMGetOperandUse(@Ptr long Val, int Index);
	/**
	 * Set an operand at a specific index in a llvm::User value.<br>
	 * @see llvm::User::setOperand()<br>
	 * Original signature : <code>void LLVMSetOperand(LLVMValueRef, unsigned, LLVMValueRef)</code>
	 */
	public static void LLVMSetOperand(LLVMLibrary.LLVMValueRef User, int Index, LLVMLibrary.LLVMValueRef Val) {
		LLVMSetOperand(Pointer.getPeer(User), Index, Pointer.getPeer(Val));
	}
	protected native static void LLVMSetOperand(@Ptr long User, int Index, @Ptr long Val);
	/**
	 * Obtain the number of operands in a llvm::User value.<br>
	 * @see llvm::User::getNumOperands()<br>
	 * Original signature : <code>int LLVMGetNumOperands(LLVMValueRef)</code>
	 */
	public static int LLVMGetNumOperands(LLVMLibrary.LLVMValueRef Val) {
		return LLVMGetNumOperands(Pointer.getPeer(Val));
	}
	protected native static int LLVMGetNumOperands(@Ptr long Val);
	/**
	 * Obtain a constant value referring to the null instance of a type.<br>
	 * @see llvm::Constant::getNullValue()<br>
	 * all zeroes<br>
	 * Original signature : <code>LLVMValueRef LLVMConstNull(LLVMTypeRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstNull(LLVMLibrary.LLVMTypeRef Ty) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstNull(Pointer.getPeer(Ty)));
	}
	@Ptr 
	protected native static long LLVMConstNull(@Ptr long Ty);
	/**
	 * Obtain a constant value referring to the instance of a type<br>
	 * consisting of all ones.<br>
	 * This is only valid for integer types.<br>
	 * @see llvm::Constant::getAllOnesValue()<br>
	 * Original signature : <code>LLVMValueRef LLVMConstAllOnes(LLVMTypeRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstAllOnes(LLVMLibrary.LLVMTypeRef Ty) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstAllOnes(Pointer.getPeer(Ty)));
	}
	@Ptr 
	protected native static long LLVMConstAllOnes(@Ptr long Ty);
	/**
	 * Obtain a constant value referring to an undefined value of a type.<br>
	 * @see llvm::UndefValue::get()<br>
	 * Original signature : <code>LLVMValueRef LLVMGetUndef(LLVMTypeRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetUndef(LLVMLibrary.LLVMTypeRef Ty) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetUndef(Pointer.getPeer(Ty)));
	}
	@Ptr 
	protected native static long LLVMGetUndef(@Ptr long Ty);
	/**
	 * Determine whether a value instance is null.<br>
	 * @see llvm::Constant::isNullValue()<br>
	 * Original signature : <code>LLVMBool LLVMIsNull(LLVMValueRef)</code>
	 */
	public static int LLVMIsNull(LLVMLibrary.LLVMValueRef Val) {
		return LLVMIsNull(Pointer.getPeer(Val));
	}
	protected native static int LLVMIsNull(@Ptr long Val);
	/**
	 * Obtain a constant that is a constant pointer pointing to NULL for a<br>
	 * specified type.<br>
	 * Original signature : <code>LLVMValueRef LLVMConstPointerNull(LLVMTypeRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstPointerNull(LLVMLibrary.LLVMTypeRef Ty) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstPointerNull(Pointer.getPeer(Ty)));
	}
	@Ptr 
	protected native static long LLVMConstPointerNull(@Ptr long Ty);
	/**
	 * Obtain a constant value for an integer type.<br>
	 * The returned value corresponds to a llvm::ConstantInt.<br>
	 * @see llvm::ConstantInt::get()<br>
	 * @param IntTy Integer type to obtain value of.<br>
	 * @param N The value the returned instance should refer to.<br>
	 * @param SignExtend Whether to sign extend the produced value.<br>
	 * Original signature : <code>LLVMValueRef LLVMConstInt(LLVMTypeRef, unsigned long long, LLVMBool)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstInt(LLVMLibrary.LLVMTypeRef IntTy, long N, int SignExtend) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstInt(Pointer.getPeer(IntTy), N, SignExtend));
	}
	@Ptr 
	protected native static long LLVMConstInt(@Ptr long IntTy, long N, int SignExtend);
	/**
	 * Obtain a constant value for an integer of arbitrary precision.<br>
	 * @see llvm::ConstantInt::get()<br>
	 * Original signature : <code>LLVMValueRef LLVMConstIntOfArbitraryPrecision(LLVMTypeRef, unsigned, const uint64_t[])</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstIntOfArbitraryPrecision(LLVMLibrary.LLVMTypeRef IntTy, int NumWords, Pointer<Long > Words) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstIntOfArbitraryPrecision(Pointer.getPeer(IntTy), NumWords, Pointer.getPeer(Words)));
	}
	@Ptr 
	protected native static long LLVMConstIntOfArbitraryPrecision(@Ptr long IntTy, int NumWords, @Ptr long Words);
	/**
	 * Obtain a constant value for an integer parsed from a string.<br>
	 * A similar API, LLVMConstIntOfStringAndSize is also available. If the<br>
	 * string's length is available, it is preferred to call that function<br>
	 * instead.<br>
	 * @see llvm::ConstantInt::get()<br>
	 * Original signature : <code>LLVMValueRef LLVMConstIntOfString(LLVMTypeRef, const char*, uint8_t)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstIntOfString(LLVMLibrary.LLVMTypeRef IntTy, Pointer<Byte > Text, byte Radix) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstIntOfString(Pointer.getPeer(IntTy), Pointer.getPeer(Text), Radix));
	}
	@Ptr 
	protected native static long LLVMConstIntOfString(@Ptr long IntTy, @Ptr long Text, byte Radix);
	/**
	 * Obtain a constant value for an integer parsed from a string with<br>
	 * specified length.<br>
	 * @see llvm::ConstantInt::get()<br>
	 * Original signature : <code>LLVMValueRef LLVMConstIntOfStringAndSize(LLVMTypeRef, const char*, unsigned, uint8_t)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstIntOfStringAndSize(LLVMLibrary.LLVMTypeRef IntTy, Pointer<Byte > Text, int SLen, byte Radix) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstIntOfStringAndSize(Pointer.getPeer(IntTy), Pointer.getPeer(Text), SLen, Radix));
	}
	@Ptr 
	protected native static long LLVMConstIntOfStringAndSize(@Ptr long IntTy, @Ptr long Text, int SLen, byte Radix);
	/**
	 * Obtain a constant value referring to a double floating point value.<br>
	 * Original signature : <code>LLVMValueRef LLVMConstReal(LLVMTypeRef, double)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstReal(LLVMLibrary.LLVMTypeRef RealTy, double N) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstReal(Pointer.getPeer(RealTy), N));
	}
	@Ptr 
	protected native static long LLVMConstReal(@Ptr long RealTy, double N);
	/**
	 * Obtain a constant for a floating point value parsed from a string.<br>
	 * A similar API, LLVMConstRealOfStringAndSize is also available. It<br>
	 * should be used if the input string's length is known.<br>
	 * Original signature : <code>LLVMValueRef LLVMConstRealOfString(LLVMTypeRef, const char*)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstRealOfString(LLVMLibrary.LLVMTypeRef RealTy, Pointer<Byte > Text) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstRealOfString(Pointer.getPeer(RealTy), Pointer.getPeer(Text)));
	}
	@Ptr 
	protected native static long LLVMConstRealOfString(@Ptr long RealTy, @Ptr long Text);
	/**
	 * Obtain a constant for a floating point value parsed from a string.<br>
	 * Original signature : <code>LLVMValueRef LLVMConstRealOfStringAndSize(LLVMTypeRef, const char*, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstRealOfStringAndSize(LLVMLibrary.LLVMTypeRef RealTy, Pointer<Byte > Text, int SLen) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstRealOfStringAndSize(Pointer.getPeer(RealTy), Pointer.getPeer(Text), SLen));
	}
	@Ptr 
	protected native static long LLVMConstRealOfStringAndSize(@Ptr long RealTy, @Ptr long Text, int SLen);
	/**
	 * Obtain the zero extended value for an integer constant value.<br>
	 * @see llvm::ConstantInt::getZExtValue()<br>
	 * Original signature : <code>long long LLVMConstIntGetZExtValue(LLVMValueRef)</code>
	 */
	public static long LLVMConstIntGetZExtValue(LLVMLibrary.LLVMValueRef ConstantVal) {
		return LLVMConstIntGetZExtValue(Pointer.getPeer(ConstantVal));
	}
	protected native static long LLVMConstIntGetZExtValue(@Ptr long ConstantVal);
	/**
	 * Obtain the sign extended value for an integer constant value.<br>
	 * @see llvm::ConstantInt::getSExtValue()<br>
	 * Original signature : <code>long long LLVMConstIntGetSExtValue(LLVMValueRef)</code>
	 */
	public static long LLVMConstIntGetSExtValue(LLVMLibrary.LLVMValueRef ConstantVal) {
		return LLVMConstIntGetSExtValue(Pointer.getPeer(ConstantVal));
	}
	protected native static long LLVMConstIntGetSExtValue(@Ptr long ConstantVal);
	/**
	 * Obtain the double value for an floating point constant value.<br>
	 * losesInfo indicates if some precision was lost in the conversion.<br>
	 * @see llvm::ConstantFP::getDoubleValue<br>
	 * Original signature : <code>double LLVMConstRealGetDouble(LLVMValueRef, LLVMBool*)</code>
	 */
	public static double LLVMConstRealGetDouble(LLVMLibrary.LLVMValueRef ConstantVal, Pointer<Integer > losesInfo) {
		return LLVMConstRealGetDouble(Pointer.getPeer(ConstantVal), Pointer.getPeer(losesInfo));
	}
	protected native static double LLVMConstRealGetDouble(@Ptr long ConstantVal, @Ptr long losesInfo);
	/**
	 * Create a ConstantDataSequential and initialize it with a string.<br>
	 * @see llvm::ConstantDataArray::getString()<br>
	 * Original signature : <code>LLVMValueRef LLVMConstStringInContext(LLVMContextRef, const char*, unsigned, LLVMBool)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstStringInContext(LLVMLibrary.LLVMContextRef C, Pointer<Byte > Str, int Length, int DontNullTerminate) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstStringInContext(Pointer.getPeer(C), Pointer.getPeer(Str), Length, DontNullTerminate));
	}
	@Ptr 
	protected native static long LLVMConstStringInContext(@Ptr long C, @Ptr long Str, int Length, int DontNullTerminate);
	/**
	 * Create a ConstantDataSequential with string content in the global context.<br>
	 * This is the same as LLVMConstStringInContext except it operates on the<br>
	 * global context.<br>
	 * @see LLVMConstStringInContext()<br>
	 * @see llvm::ConstantDataArray::getString()<br>
	 * Original signature : <code>LLVMValueRef LLVMConstString(const char*, unsigned, LLVMBool)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstString(Pointer<Byte > Str, int Length, int DontNullTerminate) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstString(Pointer.getPeer(Str), Length, DontNullTerminate));
	}
	@Ptr 
	protected native static long LLVMConstString(@Ptr long Str, int Length, int DontNullTerminate);
	/**
	 * Returns true if the specified constant is an array of i8.<br>
	 * @see ConstantDataSequential::getAsString()<br>
	 * Original signature : <code>LLVMBool LLVMIsConstantString(LLVMValueRef)</code>
	 */
	public static int LLVMIsConstantString(LLVMLibrary.LLVMValueRef c) {
		return LLVMIsConstantString(Pointer.getPeer(c));
	}
	protected native static int LLVMIsConstantString(@Ptr long c);
	/**
	 * Get the given constant data sequential as a string.<br>
	 * @see ConstantDataSequential::getAsString()<br>
	 * Original signature : <code>char* LLVMGetAsString(LLVMValueRef, size_t*)</code>
	 */
	public static Pointer<Byte > LLVMGetAsString(LLVMLibrary.LLVMValueRef c, Pointer<SizeT > Length) {
		return (Pointer)Pointer.pointerToAddress(LLVMGetAsString(Pointer.getPeer(c), Pointer.getPeer(Length)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetAsString(@Ptr long c, @Ptr long Length);
	/**
	 * Create an anonymous ConstantStruct with the specified values.<br>
	 * @see llvm::ConstantStruct::getAnon()<br>
	 * Original signature : <code>LLVMValueRef LLVMConstStructInContext(LLVMContextRef, LLVMValueRef*, unsigned, LLVMBool)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstStructInContext(LLVMLibrary.LLVMContextRef C, Pointer<LLVMLibrary.LLVMValueRef > ConstantVals, int Count, int Packed) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstStructInContext(Pointer.getPeer(C), Pointer.getPeer(ConstantVals), Count, Packed));
	}
	@Ptr 
	protected native static long LLVMConstStructInContext(@Ptr long C, @Ptr long ConstantVals, int Count, int Packed);
	/**
	 * Create a ConstantStruct in the global Context.<br>
	 * This is the same as LLVMConstStructInContext except it operates on the<br>
	 * global Context.<br>
	 * @see LLVMConstStructInContext()<br>
	 * Original signature : <code>LLVMValueRef LLVMConstStruct(LLVMValueRef*, unsigned, LLVMBool)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstStruct(Pointer<LLVMLibrary.LLVMValueRef > ConstantVals, int Count, int Packed) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstStruct(Pointer.getPeer(ConstantVals), Count, Packed));
	}
	@Ptr 
	protected native static long LLVMConstStruct(@Ptr long ConstantVals, int Count, int Packed);
	/**
	 * Create a ConstantArray from values.<br>
	 * @see llvm::ConstantArray::get()<br>
	 * Original signature : <code>LLVMValueRef LLVMConstArray(LLVMTypeRef, LLVMValueRef*, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstArray(LLVMLibrary.LLVMTypeRef ElementTy, Pointer<LLVMLibrary.LLVMValueRef > ConstantVals, int Length) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstArray(Pointer.getPeer(ElementTy), Pointer.getPeer(ConstantVals), Length));
	}
	@Ptr 
	protected native static long LLVMConstArray(@Ptr long ElementTy, @Ptr long ConstantVals, int Length);
	/**
	 * Create a non-anonymous ConstantStruct from values.<br>
	 * @see llvm::ConstantStruct::get()<br>
	 * Original signature : <code>LLVMValueRef LLVMConstNamedStruct(LLVMTypeRef, LLVMValueRef*, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstNamedStruct(LLVMLibrary.LLVMTypeRef StructTy, Pointer<LLVMLibrary.LLVMValueRef > ConstantVals, int Count) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstNamedStruct(Pointer.getPeer(StructTy), Pointer.getPeer(ConstantVals), Count));
	}
	@Ptr 
	protected native static long LLVMConstNamedStruct(@Ptr long StructTy, @Ptr long ConstantVals, int Count);
	/**
	 * Get an element at specified index as a constant.<br>
	 * @see ConstantDataSequential::getElementAsConstant()<br>
	 * Original signature : <code>LLVMValueRef LLVMGetElementAsConstant(LLVMValueRef, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetElementAsConstant(LLVMLibrary.LLVMValueRef C, int idx) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetElementAsConstant(Pointer.getPeer(C), idx));
	}
	@Ptr 
	protected native static long LLVMGetElementAsConstant(@Ptr long C, int idx);
	/**
	 * Create a ConstantVector from values.<br>
	 * @see llvm::ConstantVector::get()<br>
	 * Original signature : <code>LLVMValueRef LLVMConstVector(LLVMValueRef*, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstVector(Pointer<LLVMLibrary.LLVMValueRef > ScalarConstantVals, int Size) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstVector(Pointer.getPeer(ScalarConstantVals), Size));
	}
	@Ptr 
	protected native static long LLVMConstVector(@Ptr long ScalarConstantVals, int Size);
	/**
	 * @defgroup LLVMCCoreValueConstantExpressions Constant Expressions<br>
	 * Functions in this group correspond to APIs on llvm::ConstantExpr.<br>
	 * @see llvm::ConstantExpr.<br>
	 * @{<br>
	 * Original signature : <code>LLVMOpcode LLVMGetConstOpcode(LLVMValueRef)</code>
	 */
	public static IntValuedEnum<LLVMLibrary.LLVMOpcode > LLVMGetConstOpcode(LLVMLibrary.LLVMValueRef ConstantVal) {
		return FlagSet.fromValue(LLVMGetConstOpcode(Pointer.getPeer(ConstantVal)), LLVMLibrary.LLVMOpcode.class);
	}
	protected native static int LLVMGetConstOpcode(@Ptr long ConstantVal);
	/** Original signature : <code>LLVMValueRef LLVMAlignOf(LLVMTypeRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMAlignOf(LLVMLibrary.LLVMTypeRef Ty) {
		return new LLVMLibrary.LLVMValueRef(LLVMAlignOf(Pointer.getPeer(Ty)));
	}
	@Ptr 
	protected native static long LLVMAlignOf(@Ptr long Ty);
	/** Original signature : <code>LLVMValueRef LLVMSizeOf(LLVMTypeRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMSizeOf(LLVMLibrary.LLVMTypeRef Ty) {
		return new LLVMLibrary.LLVMValueRef(LLVMSizeOf(Pointer.getPeer(Ty)));
	}
	@Ptr 
	protected native static long LLVMSizeOf(@Ptr long Ty);
	/** Original signature : <code>LLVMValueRef LLVMConstNeg(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstNeg(LLVMLibrary.LLVMValueRef ConstantVal) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstNeg(Pointer.getPeer(ConstantVal)));
	}
	@Ptr 
	protected native static long LLVMConstNeg(@Ptr long ConstantVal);
	/** Original signature : <code>LLVMValueRef LLVMConstNSWNeg(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstNSWNeg(LLVMLibrary.LLVMValueRef ConstantVal) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstNSWNeg(Pointer.getPeer(ConstantVal)));
	}
	@Ptr 
	protected native static long LLVMConstNSWNeg(@Ptr long ConstantVal);
	/** Original signature : <code>LLVMValueRef LLVMConstNUWNeg(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstNUWNeg(LLVMLibrary.LLVMValueRef ConstantVal) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstNUWNeg(Pointer.getPeer(ConstantVal)));
	}
	@Ptr 
	protected native static long LLVMConstNUWNeg(@Ptr long ConstantVal);
	/** Original signature : <code>LLVMValueRef LLVMConstFNeg(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstFNeg(LLVMLibrary.LLVMValueRef ConstantVal) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstFNeg(Pointer.getPeer(ConstantVal)));
	}
	@Ptr 
	protected native static long LLVMConstFNeg(@Ptr long ConstantVal);
	/** Original signature : <code>LLVMValueRef LLVMConstNot(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstNot(LLVMLibrary.LLVMValueRef ConstantVal) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstNot(Pointer.getPeer(ConstantVal)));
	}
	@Ptr 
	protected native static long LLVMConstNot(@Ptr long ConstantVal);
	/** Original signature : <code>LLVMValueRef LLVMConstAdd(LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstAdd(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstAdd(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstAdd(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/** Original signature : <code>LLVMValueRef LLVMConstNSWAdd(LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstNSWAdd(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstNSWAdd(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstNSWAdd(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/** Original signature : <code>LLVMValueRef LLVMConstNUWAdd(LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstNUWAdd(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstNUWAdd(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstNUWAdd(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/** Original signature : <code>LLVMValueRef LLVMConstFAdd(LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstFAdd(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstFAdd(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstFAdd(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/** Original signature : <code>LLVMValueRef LLVMConstSub(LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstSub(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstSub(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstSub(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/** Original signature : <code>LLVMValueRef LLVMConstNSWSub(LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstNSWSub(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstNSWSub(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstNSWSub(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/** Original signature : <code>LLVMValueRef LLVMConstNUWSub(LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstNUWSub(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstNUWSub(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstNUWSub(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/** Original signature : <code>LLVMValueRef LLVMConstFSub(LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstFSub(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstFSub(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstFSub(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/** Original signature : <code>LLVMValueRef LLVMConstMul(LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstMul(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstMul(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstMul(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/** Original signature : <code>LLVMValueRef LLVMConstNSWMul(LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstNSWMul(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstNSWMul(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstNSWMul(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/** Original signature : <code>LLVMValueRef LLVMConstNUWMul(LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstNUWMul(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstNUWMul(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstNUWMul(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/** Original signature : <code>LLVMValueRef LLVMConstFMul(LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstFMul(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstFMul(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstFMul(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/** Original signature : <code>LLVMValueRef LLVMConstUDiv(LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstUDiv(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstUDiv(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstUDiv(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/** Original signature : <code>LLVMValueRef LLVMConstSDiv(LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstSDiv(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstSDiv(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstSDiv(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/** Original signature : <code>LLVMValueRef LLVMConstExactSDiv(LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstExactSDiv(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstExactSDiv(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstExactSDiv(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/** Original signature : <code>LLVMValueRef LLVMConstFDiv(LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstFDiv(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstFDiv(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstFDiv(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/** Original signature : <code>LLVMValueRef LLVMConstURem(LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstURem(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstURem(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstURem(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/** Original signature : <code>LLVMValueRef LLVMConstSRem(LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstSRem(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstSRem(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstSRem(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/** Original signature : <code>LLVMValueRef LLVMConstFRem(LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstFRem(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstFRem(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstFRem(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/** Original signature : <code>LLVMValueRef LLVMConstAnd(LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstAnd(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstAnd(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstAnd(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/** Original signature : <code>LLVMValueRef LLVMConstOr(LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstOr(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstOr(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstOr(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/** Original signature : <code>LLVMValueRef LLVMConstXor(LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstXor(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstXor(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstXor(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/** Original signature : <code>LLVMValueRef LLVMConstICmp(LLVMIntPredicate, LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstICmp(IntValuedEnum<LLVMLibrary.LLVMIntPredicate > Predicate, LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstICmp((int)Predicate.value(), Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstICmp(int Predicate, @Ptr long LHSConstant, @Ptr long RHSConstant);
	/** Original signature : <code>LLVMValueRef LLVMConstFCmp(LLVMRealPredicate, LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstFCmp(IntValuedEnum<LLVMLibrary.LLVMRealPredicate > Predicate, LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstFCmp((int)Predicate.value(), Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstFCmp(int Predicate, @Ptr long LHSConstant, @Ptr long RHSConstant);
	/** Original signature : <code>LLVMValueRef LLVMConstShl(LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstShl(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstShl(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstShl(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/** Original signature : <code>LLVMValueRef LLVMConstLShr(LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstLShr(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstLShr(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstLShr(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/** Original signature : <code>LLVMValueRef LLVMConstAShr(LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstAShr(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstAShr(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstAShr(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/** Original signature : <code>LLVMValueRef LLVMConstGEP(LLVMValueRef, LLVMValueRef*, unsigned)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstGEP(LLVMLibrary.LLVMValueRef ConstantVal, Pointer<LLVMLibrary.LLVMValueRef > ConstantIndices, int NumIndices) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstGEP(Pointer.getPeer(ConstantVal), Pointer.getPeer(ConstantIndices), NumIndices));
	}
	@Ptr 
	protected native static long LLVMConstGEP(@Ptr long ConstantVal, @Ptr long ConstantIndices, int NumIndices);
	/** Original signature : <code>LLVMValueRef LLVMConstInBoundsGEP(LLVMValueRef, LLVMValueRef*, unsigned)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstInBoundsGEP(LLVMLibrary.LLVMValueRef ConstantVal, Pointer<LLVMLibrary.LLVMValueRef > ConstantIndices, int NumIndices) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstInBoundsGEP(Pointer.getPeer(ConstantVal), Pointer.getPeer(ConstantIndices), NumIndices));
	}
	@Ptr 
	protected native static long LLVMConstInBoundsGEP(@Ptr long ConstantVal, @Ptr long ConstantIndices, int NumIndices);
	/** Original signature : <code>LLVMValueRef LLVMConstTrunc(LLVMValueRef, LLVMTypeRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstTrunc(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstTrunc(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstTrunc(@Ptr long ConstantVal, @Ptr long ToType);
	/** Original signature : <code>LLVMValueRef LLVMConstSExt(LLVMValueRef, LLVMTypeRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstSExt(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstSExt(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstSExt(@Ptr long ConstantVal, @Ptr long ToType);
	/** Original signature : <code>LLVMValueRef LLVMConstZExt(LLVMValueRef, LLVMTypeRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstZExt(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstZExt(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstZExt(@Ptr long ConstantVal, @Ptr long ToType);
	/** Original signature : <code>LLVMValueRef LLVMConstFPTrunc(LLVMValueRef, LLVMTypeRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstFPTrunc(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstFPTrunc(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstFPTrunc(@Ptr long ConstantVal, @Ptr long ToType);
	/** Original signature : <code>LLVMValueRef LLVMConstFPExt(LLVMValueRef, LLVMTypeRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstFPExt(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstFPExt(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstFPExt(@Ptr long ConstantVal, @Ptr long ToType);
	/** Original signature : <code>LLVMValueRef LLVMConstUIToFP(LLVMValueRef, LLVMTypeRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstUIToFP(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstUIToFP(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstUIToFP(@Ptr long ConstantVal, @Ptr long ToType);
	/** Original signature : <code>LLVMValueRef LLVMConstSIToFP(LLVMValueRef, LLVMTypeRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstSIToFP(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstSIToFP(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstSIToFP(@Ptr long ConstantVal, @Ptr long ToType);
	/** Original signature : <code>LLVMValueRef LLVMConstFPToUI(LLVMValueRef, LLVMTypeRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstFPToUI(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstFPToUI(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstFPToUI(@Ptr long ConstantVal, @Ptr long ToType);
	/** Original signature : <code>LLVMValueRef LLVMConstFPToSI(LLVMValueRef, LLVMTypeRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstFPToSI(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstFPToSI(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstFPToSI(@Ptr long ConstantVal, @Ptr long ToType);
	/** Original signature : <code>LLVMValueRef LLVMConstPtrToInt(LLVMValueRef, LLVMTypeRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstPtrToInt(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstPtrToInt(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstPtrToInt(@Ptr long ConstantVal, @Ptr long ToType);
	/** Original signature : <code>LLVMValueRef LLVMConstIntToPtr(LLVMValueRef, LLVMTypeRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstIntToPtr(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstIntToPtr(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstIntToPtr(@Ptr long ConstantVal, @Ptr long ToType);
	/** Original signature : <code>LLVMValueRef LLVMConstBitCast(LLVMValueRef, LLVMTypeRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstBitCast(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstBitCast(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstBitCast(@Ptr long ConstantVal, @Ptr long ToType);
	/** Original signature : <code>LLVMValueRef LLVMConstAddrSpaceCast(LLVMValueRef, LLVMTypeRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstAddrSpaceCast(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstAddrSpaceCast(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstAddrSpaceCast(@Ptr long ConstantVal, @Ptr long ToType);
	/** Original signature : <code>LLVMValueRef LLVMConstZExtOrBitCast(LLVMValueRef, LLVMTypeRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstZExtOrBitCast(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstZExtOrBitCast(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstZExtOrBitCast(@Ptr long ConstantVal, @Ptr long ToType);
	/** Original signature : <code>LLVMValueRef LLVMConstSExtOrBitCast(LLVMValueRef, LLVMTypeRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstSExtOrBitCast(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstSExtOrBitCast(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstSExtOrBitCast(@Ptr long ConstantVal, @Ptr long ToType);
	/** Original signature : <code>LLVMValueRef LLVMConstTruncOrBitCast(LLVMValueRef, LLVMTypeRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstTruncOrBitCast(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstTruncOrBitCast(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstTruncOrBitCast(@Ptr long ConstantVal, @Ptr long ToType);
	/** Original signature : <code>LLVMValueRef LLVMConstPointerCast(LLVMValueRef, LLVMTypeRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstPointerCast(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstPointerCast(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstPointerCast(@Ptr long ConstantVal, @Ptr long ToType);
	/** Original signature : <code>LLVMValueRef LLVMConstIntCast(LLVMValueRef, LLVMTypeRef, LLVMBool)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstIntCast(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType, int isSigned) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstIntCast(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType), isSigned));
	}
	@Ptr 
	protected native static long LLVMConstIntCast(@Ptr long ConstantVal, @Ptr long ToType, int isSigned);
	/** Original signature : <code>LLVMValueRef LLVMConstFPCast(LLVMValueRef, LLVMTypeRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstFPCast(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstFPCast(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstFPCast(@Ptr long ConstantVal, @Ptr long ToType);
	/** Original signature : <code>LLVMValueRef LLVMConstSelect(LLVMValueRef, LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstSelect(LLVMLibrary.LLVMValueRef ConstantCondition, LLVMLibrary.LLVMValueRef ConstantIfTrue, LLVMLibrary.LLVMValueRef ConstantIfFalse) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstSelect(Pointer.getPeer(ConstantCondition), Pointer.getPeer(ConstantIfTrue), Pointer.getPeer(ConstantIfFalse)));
	}
	@Ptr 
	protected native static long LLVMConstSelect(@Ptr long ConstantCondition, @Ptr long ConstantIfTrue, @Ptr long ConstantIfFalse);
	/** Original signature : <code>LLVMValueRef LLVMConstExtractElement(LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstExtractElement(LLVMLibrary.LLVMValueRef VectorConstant, LLVMLibrary.LLVMValueRef IndexConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstExtractElement(Pointer.getPeer(VectorConstant), Pointer.getPeer(IndexConstant)));
	}
	@Ptr 
	protected native static long LLVMConstExtractElement(@Ptr long VectorConstant, @Ptr long IndexConstant);
	/** Original signature : <code>LLVMValueRef LLVMConstInsertElement(LLVMValueRef, LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstInsertElement(LLVMLibrary.LLVMValueRef VectorConstant, LLVMLibrary.LLVMValueRef ElementValueConstant, LLVMLibrary.LLVMValueRef IndexConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstInsertElement(Pointer.getPeer(VectorConstant), Pointer.getPeer(ElementValueConstant), Pointer.getPeer(IndexConstant)));
	}
	@Ptr 
	protected native static long LLVMConstInsertElement(@Ptr long VectorConstant, @Ptr long ElementValueConstant, @Ptr long IndexConstant);
	/** Original signature : <code>LLVMValueRef LLVMConstShuffleVector(LLVMValueRef, LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstShuffleVector(LLVMLibrary.LLVMValueRef VectorAConstant, LLVMLibrary.LLVMValueRef VectorBConstant, LLVMLibrary.LLVMValueRef MaskConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstShuffleVector(Pointer.getPeer(VectorAConstant), Pointer.getPeer(VectorBConstant), Pointer.getPeer(MaskConstant)));
	}
	@Ptr 
	protected native static long LLVMConstShuffleVector(@Ptr long VectorAConstant, @Ptr long VectorBConstant, @Ptr long MaskConstant);
	/** Original signature : <code>LLVMValueRef LLVMConstExtractValue(LLVMValueRef, unsigned*, unsigned)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstExtractValue(LLVMLibrary.LLVMValueRef AggConstant, Pointer<Integer > IdxList, int NumIdx) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstExtractValue(Pointer.getPeer(AggConstant), Pointer.getPeer(IdxList), NumIdx));
	}
	@Ptr 
	protected native static long LLVMConstExtractValue(@Ptr long AggConstant, @Ptr long IdxList, int NumIdx);
	/** Original signature : <code>LLVMValueRef LLVMConstInsertValue(LLVMValueRef, LLVMValueRef, unsigned*, unsigned)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstInsertValue(LLVMLibrary.LLVMValueRef AggConstant, LLVMLibrary.LLVMValueRef ElementValueConstant, Pointer<Integer > IdxList, int NumIdx) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstInsertValue(Pointer.getPeer(AggConstant), Pointer.getPeer(ElementValueConstant), Pointer.getPeer(IdxList), NumIdx));
	}
	@Ptr 
	protected native static long LLVMConstInsertValue(@Ptr long AggConstant, @Ptr long ElementValueConstant, @Ptr long IdxList, int NumIdx);
	/** Original signature : <code>LLVMValueRef LLVMConstInlineAsm(LLVMTypeRef, const char*, const char*, LLVMBool, LLVMBool)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMConstInlineAsm(LLVMLibrary.LLVMTypeRef Ty, Pointer<Byte > AsmString, Pointer<Byte > Constraints, int HasSideEffects, int IsAlignStack) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstInlineAsm(Pointer.getPeer(Ty), Pointer.getPeer(AsmString), Pointer.getPeer(Constraints), HasSideEffects, IsAlignStack));
	}
	@Ptr 
	protected native static long LLVMConstInlineAsm(@Ptr long Ty, @Ptr long AsmString, @Ptr long Constraints, int HasSideEffects, int IsAlignStack);
	/** Original signature : <code>LLVMValueRef LLVMBlockAddress(LLVMValueRef, LLVMBasicBlockRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBlockAddress(LLVMLibrary.LLVMValueRef F, LLVMLibrary.LLVMBasicBlockRef BB) {
		return new LLVMLibrary.LLVMValueRef(LLVMBlockAddress(Pointer.getPeer(F), Pointer.getPeer(BB)));
	}
	@Ptr 
	protected native static long LLVMBlockAddress(@Ptr long F, @Ptr long BB);
	/**
	 * @defgroup LLVMCCoreValueConstantGlobals Global Values<br>
	 * This group contains functions that operate on global values. Functions in<br>
	 * this group relate to functions in the llvm::GlobalValue class tree.<br>
	 * @see llvm::GlobalValue<br>
	 * @{<br>
	 * Original signature : <code>LLVMModuleRef LLVMGetGlobalParent(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMModuleRef LLVMGetGlobalParent(LLVMLibrary.LLVMValueRef Global) {
		return new LLVMLibrary.LLVMModuleRef(LLVMGetGlobalParent(Pointer.getPeer(Global)));
	}
	@Ptr 
	protected native static long LLVMGetGlobalParent(@Ptr long Global);
	/** Original signature : <code>LLVMBool LLVMIsDeclaration(LLVMValueRef)</code> */
	public static int LLVMIsDeclaration(LLVMLibrary.LLVMValueRef Global) {
		return LLVMIsDeclaration(Pointer.getPeer(Global));
	}
	protected native static int LLVMIsDeclaration(@Ptr long Global);
	/** Original signature : <code>LLVMLinkage LLVMGetLinkage(LLVMValueRef)</code> */
	public static IntValuedEnum<LLVMLibrary.LLVMLinkage > LLVMGetLinkage(LLVMLibrary.LLVMValueRef Global) {
		return FlagSet.fromValue(LLVMGetLinkage(Pointer.getPeer(Global)), LLVMLibrary.LLVMLinkage.class);
	}
	protected native static int LLVMGetLinkage(@Ptr long Global);
	/** Original signature : <code>void LLVMSetLinkage(LLVMValueRef, LLVMLinkage)</code> */
	public static void LLVMSetLinkage(LLVMLibrary.LLVMValueRef Global, IntValuedEnum<LLVMLibrary.LLVMLinkage > Linkage) {
		LLVMSetLinkage(Pointer.getPeer(Global), (int)Linkage.value());
	}
	protected native static void LLVMSetLinkage(@Ptr long Global, int Linkage);
	/** Original signature : <code>char* LLVMGetSection(LLVMValueRef)</code> */
	public static Pointer<Byte > LLVMGetSection(LLVMLibrary.LLVMValueRef Global) {
		return (Pointer)Pointer.pointerToAddress(LLVMGetSection(Pointer.getPeer(Global)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetSection(@Ptr long Global);
	/** Original signature : <code>void LLVMSetSection(LLVMValueRef, const char*)</code> */
	public static void LLVMSetSection(LLVMLibrary.LLVMValueRef Global, Pointer<Byte > Section) {
		LLVMSetSection(Pointer.getPeer(Global), Pointer.getPeer(Section));
	}
	protected native static void LLVMSetSection(@Ptr long Global, @Ptr long Section);
	/** Original signature : <code>LLVMVisibility LLVMGetVisibility(LLVMValueRef)</code> */
	public static IntValuedEnum<LLVMLibrary.LLVMVisibility > LLVMGetVisibility(LLVMLibrary.LLVMValueRef Global) {
		return FlagSet.fromValue(LLVMGetVisibility(Pointer.getPeer(Global)), LLVMLibrary.LLVMVisibility.class);
	}
	protected native static int LLVMGetVisibility(@Ptr long Global);
	/** Original signature : <code>void LLVMSetVisibility(LLVMValueRef, LLVMVisibility)</code> */
	public static void LLVMSetVisibility(LLVMLibrary.LLVMValueRef Global, IntValuedEnum<LLVMLibrary.LLVMVisibility > Viz) {
		LLVMSetVisibility(Pointer.getPeer(Global), (int)Viz.value());
	}
	protected native static void LLVMSetVisibility(@Ptr long Global, int Viz);
	/** Original signature : <code>LLVMDLLStorageClass LLVMGetDLLStorageClass(LLVMValueRef)</code> */
	public static IntValuedEnum<LLVMLibrary.LLVMDLLStorageClass > LLVMGetDLLStorageClass(LLVMLibrary.LLVMValueRef Global) {
		return FlagSet.fromValue(LLVMGetDLLStorageClass(Pointer.getPeer(Global)), LLVMLibrary.LLVMDLLStorageClass.class);
	}
	protected native static int LLVMGetDLLStorageClass(@Ptr long Global);
	/** Original signature : <code>void LLVMSetDLLStorageClass(LLVMValueRef, LLVMDLLStorageClass)</code> */
	public static void LLVMSetDLLStorageClass(LLVMLibrary.LLVMValueRef Global, IntValuedEnum<LLVMLibrary.LLVMDLLStorageClass > Class) {
		LLVMSetDLLStorageClass(Pointer.getPeer(Global), (int)Class.value());
	}
	protected native static void LLVMSetDLLStorageClass(@Ptr long Global, int Class);
	/** Original signature : <code>LLVMBool LLVMHasUnnamedAddr(LLVMValueRef)</code> */
	public static int LLVMHasUnnamedAddr(LLVMLibrary.LLVMValueRef Global) {
		return LLVMHasUnnamedAddr(Pointer.getPeer(Global));
	}
	protected native static int LLVMHasUnnamedAddr(@Ptr long Global);
	/** Original signature : <code>void LLVMSetUnnamedAddr(LLVMValueRef, LLVMBool)</code> */
	public static void LLVMSetUnnamedAddr(LLVMLibrary.LLVMValueRef Global, int HasUnnamedAddr) {
		LLVMSetUnnamedAddr(Pointer.getPeer(Global), HasUnnamedAddr);
	}
	protected native static void LLVMSetUnnamedAddr(@Ptr long Global, int HasUnnamedAddr);
	/**
	 * Obtain the preferred alignment of the value.<br>
	 * @see llvm::AllocaInst::getAlignment()<br>
	 * @see llvm::LoadInst::getAlignment()<br>
	 * @see llvm::StoreInst::getAlignment()<br>
	 * @see llvm::GlobalValue::getAlignment()<br>
	 * Original signature : <code>int LLVMGetAlignment(LLVMValueRef)</code>
	 */
	public static int LLVMGetAlignment(LLVMLibrary.LLVMValueRef V) {
		return LLVMGetAlignment(Pointer.getPeer(V));
	}
	protected native static int LLVMGetAlignment(@Ptr long V);
	/**
	 * Set the preferred alignment of the value.<br>
	 * @see llvm::AllocaInst::setAlignment()<br>
	 * @see llvm::LoadInst::setAlignment()<br>
	 * @see llvm::StoreInst::setAlignment()<br>
	 * @see llvm::GlobalValue::setAlignment()<br>
	 * Original signature : <code>void LLVMSetAlignment(LLVMValueRef, unsigned)</code>
	 */
	public static void LLVMSetAlignment(LLVMLibrary.LLVMValueRef V, int Bytes) {
		LLVMSetAlignment(Pointer.getPeer(V), Bytes);
	}
	protected native static void LLVMSetAlignment(@Ptr long V, int Bytes);
	/**
	 * @defgroup LLVMCoreValueConstantGlobalVariable Global Variables<br>
	 * This group contains functions that operate on global variable values.<br>
	 * @see llvm::GlobalVariable<br>
	 * @{<br>
	 * Original signature : <code>LLVMValueRef LLVMAddGlobal(LLVMModuleRef, LLVMTypeRef, const char*)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMAddGlobal(LLVMLibrary.LLVMModuleRef M, LLVMLibrary.LLVMTypeRef Ty, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMAddGlobal(Pointer.getPeer(M), Pointer.getPeer(Ty), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMAddGlobal(@Ptr long M, @Ptr long Ty, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMAddGlobalInAddressSpace(LLVMModuleRef, LLVMTypeRef, const char*, unsigned)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMAddGlobalInAddressSpace(LLVMLibrary.LLVMModuleRef M, LLVMLibrary.LLVMTypeRef Ty, Pointer<Byte > Name, int AddressSpace) {
		return new LLVMLibrary.LLVMValueRef(LLVMAddGlobalInAddressSpace(Pointer.getPeer(M), Pointer.getPeer(Ty), Pointer.getPeer(Name), AddressSpace));
	}
	@Ptr 
	protected native static long LLVMAddGlobalInAddressSpace(@Ptr long M, @Ptr long Ty, @Ptr long Name, int AddressSpace);
	/** Original signature : <code>LLVMValueRef LLVMGetNamedGlobal(LLVMModuleRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMGetNamedGlobal(LLVMLibrary.LLVMModuleRef M, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetNamedGlobal(Pointer.getPeer(M), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMGetNamedGlobal(@Ptr long M, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMGetFirstGlobal(LLVMModuleRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMGetFirstGlobal(LLVMLibrary.LLVMModuleRef M) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetFirstGlobal(Pointer.getPeer(M)));
	}
	@Ptr 
	protected native static long LLVMGetFirstGlobal(@Ptr long M);
	/** Original signature : <code>LLVMValueRef LLVMGetLastGlobal(LLVMModuleRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMGetLastGlobal(LLVMLibrary.LLVMModuleRef M) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetLastGlobal(Pointer.getPeer(M)));
	}
	@Ptr 
	protected native static long LLVMGetLastGlobal(@Ptr long M);
	/** Original signature : <code>LLVMValueRef LLVMGetNextGlobal(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMGetNextGlobal(LLVMLibrary.LLVMValueRef GlobalVar) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetNextGlobal(Pointer.getPeer(GlobalVar)));
	}
	@Ptr 
	protected native static long LLVMGetNextGlobal(@Ptr long GlobalVar);
	/** Original signature : <code>LLVMValueRef LLVMGetPreviousGlobal(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMGetPreviousGlobal(LLVMLibrary.LLVMValueRef GlobalVar) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetPreviousGlobal(Pointer.getPeer(GlobalVar)));
	}
	@Ptr 
	protected native static long LLVMGetPreviousGlobal(@Ptr long GlobalVar);
	/** Original signature : <code>void LLVMDeleteGlobal(LLVMValueRef)</code> */
	public static void LLVMDeleteGlobal(LLVMLibrary.LLVMValueRef GlobalVar) {
		LLVMDeleteGlobal(Pointer.getPeer(GlobalVar));
	}
	protected native static void LLVMDeleteGlobal(@Ptr long GlobalVar);
	/** Original signature : <code>LLVMValueRef LLVMGetInitializer(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMGetInitializer(LLVMLibrary.LLVMValueRef GlobalVar) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetInitializer(Pointer.getPeer(GlobalVar)));
	}
	@Ptr 
	protected native static long LLVMGetInitializer(@Ptr long GlobalVar);
	/** Original signature : <code>void LLVMSetInitializer(LLVMValueRef, LLVMValueRef)</code> */
	public static void LLVMSetInitializer(LLVMLibrary.LLVMValueRef GlobalVar, LLVMLibrary.LLVMValueRef ConstantVal) {
		LLVMSetInitializer(Pointer.getPeer(GlobalVar), Pointer.getPeer(ConstantVal));
	}
	protected native static void LLVMSetInitializer(@Ptr long GlobalVar, @Ptr long ConstantVal);
	/** Original signature : <code>LLVMBool LLVMIsThreadLocal(LLVMValueRef)</code> */
	public static int LLVMIsThreadLocal(LLVMLibrary.LLVMValueRef GlobalVar) {
		return LLVMIsThreadLocal(Pointer.getPeer(GlobalVar));
	}
	protected native static int LLVMIsThreadLocal(@Ptr long GlobalVar);
	/** Original signature : <code>void LLVMSetThreadLocal(LLVMValueRef, LLVMBool)</code> */
	public static void LLVMSetThreadLocal(LLVMLibrary.LLVMValueRef GlobalVar, int IsThreadLocal) {
		LLVMSetThreadLocal(Pointer.getPeer(GlobalVar), IsThreadLocal);
	}
	protected native static void LLVMSetThreadLocal(@Ptr long GlobalVar, int IsThreadLocal);
	/** Original signature : <code>LLVMBool LLVMIsGlobalConstant(LLVMValueRef)</code> */
	public static int LLVMIsGlobalConstant(LLVMLibrary.LLVMValueRef GlobalVar) {
		return LLVMIsGlobalConstant(Pointer.getPeer(GlobalVar));
	}
	protected native static int LLVMIsGlobalConstant(@Ptr long GlobalVar);
	/** Original signature : <code>void LLVMSetGlobalConstant(LLVMValueRef, LLVMBool)</code> */
	public static void LLVMSetGlobalConstant(LLVMLibrary.LLVMValueRef GlobalVar, int IsConstant) {
		LLVMSetGlobalConstant(Pointer.getPeer(GlobalVar), IsConstant);
	}
	protected native static void LLVMSetGlobalConstant(@Ptr long GlobalVar, int IsConstant);
	/** Original signature : <code>LLVMThreadLocalMode LLVMGetThreadLocalMode(LLVMValueRef)</code> */
	public static IntValuedEnum<LLVMLibrary.LLVMThreadLocalMode > LLVMGetThreadLocalMode(LLVMLibrary.LLVMValueRef GlobalVar) {
		return FlagSet.fromValue(LLVMGetThreadLocalMode(Pointer.getPeer(GlobalVar)), LLVMLibrary.LLVMThreadLocalMode.class);
	}
	protected native static int LLVMGetThreadLocalMode(@Ptr long GlobalVar);
	/** Original signature : <code>void LLVMSetThreadLocalMode(LLVMValueRef, LLVMThreadLocalMode)</code> */
	public static void LLVMSetThreadLocalMode(LLVMLibrary.LLVMValueRef GlobalVar, IntValuedEnum<LLVMLibrary.LLVMThreadLocalMode > Mode) {
		LLVMSetThreadLocalMode(Pointer.getPeer(GlobalVar), (int)Mode.value());
	}
	protected native static void LLVMSetThreadLocalMode(@Ptr long GlobalVar, int Mode);
	/** Original signature : <code>LLVMBool LLVMIsExternallyInitialized(LLVMValueRef)</code> */
	public static int LLVMIsExternallyInitialized(LLVMLibrary.LLVMValueRef GlobalVar) {
		return LLVMIsExternallyInitialized(Pointer.getPeer(GlobalVar));
	}
	protected native static int LLVMIsExternallyInitialized(@Ptr long GlobalVar);
	/** Original signature : <code>void LLVMSetExternallyInitialized(LLVMValueRef, LLVMBool)</code> */
	public static void LLVMSetExternallyInitialized(LLVMLibrary.LLVMValueRef GlobalVar, int IsExtInit) {
		LLVMSetExternallyInitialized(Pointer.getPeer(GlobalVar), IsExtInit);
	}
	protected native static void LLVMSetExternallyInitialized(@Ptr long GlobalVar, int IsExtInit);
	/**
	 * @defgroup LLVMCoreValueConstantGlobalAlias Global Aliases<br>
	 * This group contains function that operate on global alias values.<br>
	 * @see llvm::GlobalAlias<br>
	 * @{<br>
	 * Original signature : <code>LLVMValueRef LLVMAddAlias(LLVMModuleRef, LLVMTypeRef, LLVMValueRef, const char*)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMAddAlias(LLVMLibrary.LLVMModuleRef M, LLVMLibrary.LLVMTypeRef Ty, LLVMLibrary.LLVMValueRef Aliasee, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMAddAlias(Pointer.getPeer(M), Pointer.getPeer(Ty), Pointer.getPeer(Aliasee), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMAddAlias(@Ptr long M, @Ptr long Ty, @Ptr long Aliasee, @Ptr long Name);
	/**
	 * Remove a function from its containing module and deletes it.<br>
	 * @see llvm::Function::eraseFromParent()<br>
	 * Original signature : <code>void LLVMDeleteFunction(LLVMValueRef)</code>
	 */
	public static void LLVMDeleteFunction(LLVMLibrary.LLVMValueRef Fn) {
		LLVMDeleteFunction(Pointer.getPeer(Fn));
	}
	protected native static void LLVMDeleteFunction(@Ptr long Fn);
	/**
	 * Check whether the given function has a personality function.<br>
	 * @see llvm::Function::hasPersonalityFn()<br>
	 * Original signature : <code>LLVMBool LLVMHasPersonalityFn(LLVMValueRef)</code>
	 */
	public static int LLVMHasPersonalityFn(LLVMLibrary.LLVMValueRef Fn) {
		return LLVMHasPersonalityFn(Pointer.getPeer(Fn));
	}
	protected native static int LLVMHasPersonalityFn(@Ptr long Fn);
	/**
	 * Obtain the personality function attached to the function.<br>
	 * @see llvm::Function::getPersonalityFn()<br>
	 * Original signature : <code>LLVMValueRef LLVMGetPersonalityFn(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetPersonalityFn(LLVMLibrary.LLVMValueRef Fn) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetPersonalityFn(Pointer.getPeer(Fn)));
	}
	@Ptr 
	protected native static long LLVMGetPersonalityFn(@Ptr long Fn);
	/**
	 * Set the personality function attached to the function.<br>
	 * @see llvm::Function::setPersonalityFn()<br>
	 * Original signature : <code>void LLVMSetPersonalityFn(LLVMValueRef, LLVMValueRef)</code>
	 */
	public static void LLVMSetPersonalityFn(LLVMLibrary.LLVMValueRef Fn, LLVMLibrary.LLVMValueRef PersonalityFn) {
		LLVMSetPersonalityFn(Pointer.getPeer(Fn), Pointer.getPeer(PersonalityFn));
	}
	protected native static void LLVMSetPersonalityFn(@Ptr long Fn, @Ptr long PersonalityFn);
	/**
	 * Obtain the ID number from a function instance.<br>
	 * @see llvm::Function::getIntrinsicID()<br>
	 * Original signature : <code>int LLVMGetIntrinsicID(LLVMValueRef)</code>
	 */
	public static int LLVMGetIntrinsicID(LLVMLibrary.LLVMValueRef Fn) {
		return LLVMGetIntrinsicID(Pointer.getPeer(Fn));
	}
	protected native static int LLVMGetIntrinsicID(@Ptr long Fn);
	/**
	 * Obtain the calling function of a function.<br>
	 * The returned value corresponds to the LLVMCallConv enumeration.<br>
	 * @see llvm::Function::getCallingConv()<br>
	 * Original signature : <code>int LLVMGetFunctionCallConv(LLVMValueRef)</code>
	 */
	public static int LLVMGetFunctionCallConv(LLVMLibrary.LLVMValueRef Fn) {
		return LLVMGetFunctionCallConv(Pointer.getPeer(Fn));
	}
	protected native static int LLVMGetFunctionCallConv(@Ptr long Fn);
	/**
	 * Set the calling convention of a function.<br>
	 * @see llvm::Function::setCallingConv()<br>
	 * @param Fn Function to operate on<br>
	 * @param CC LLVMCallConv to set calling convention to<br>
	 * Original signature : <code>void LLVMSetFunctionCallConv(LLVMValueRef, unsigned)</code>
	 */
	public static void LLVMSetFunctionCallConv(LLVMLibrary.LLVMValueRef Fn, int CC) {
		LLVMSetFunctionCallConv(Pointer.getPeer(Fn), CC);
	}
	protected native static void LLVMSetFunctionCallConv(@Ptr long Fn, int CC);
	/**
	 * Obtain the name of the garbage collector to use during code<br>
	 * generation.<br>
	 * @see llvm::Function::getGC()<br>
	 * Original signature : <code>char* LLVMGetGC(LLVMValueRef)</code>
	 */
	public static Pointer<Byte > LLVMGetGC(LLVMLibrary.LLVMValueRef Fn) {
		return (Pointer)Pointer.pointerToAddress(LLVMGetGC(Pointer.getPeer(Fn)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetGC(@Ptr long Fn);
	/**
	 * Define the garbage collector to use during code generation.<br>
	 * @see llvm::Function::setGC()<br>
	 * Original signature : <code>void LLVMSetGC(LLVMValueRef, const char*)</code>
	 */
	public static void LLVMSetGC(LLVMLibrary.LLVMValueRef Fn, Pointer<Byte > Name) {
		LLVMSetGC(Pointer.getPeer(Fn), Pointer.getPeer(Name));
	}
	protected native static void LLVMSetGC(@Ptr long Fn, @Ptr long Name);
	/**
	 * Add an attribute to a function.<br>
	 * @see llvm::Function::addAttribute()<br>
	 * Original signature : <code>void LLVMAddFunctionAttr(LLVMValueRef, LLVMAttribute)</code>
	 */
	public static void LLVMAddFunctionAttr(LLVMLibrary.LLVMValueRef Fn, IntValuedEnum<LLVMLibrary.LLVMAttribute > PA) {
		LLVMAddFunctionAttr(Pointer.getPeer(Fn), (int)PA.value());
	}
	protected native static void LLVMAddFunctionAttr(@Ptr long Fn, int PA);
	/** Original signature : <code>void LLVMAddAttributeAtIndex(LLVMValueRef, LLVMAttributeIndex, LLVMAttributeRef)</code> */
	public static void LLVMAddAttributeAtIndex(LLVMLibrary.LLVMValueRef F, int Idx, LLVMLibrary.LLVMAttributeRef A) {
		LLVMAddAttributeAtIndex(Pointer.getPeer(F), Idx, Pointer.getPeer(A));
	}
	protected native static void LLVMAddAttributeAtIndex(@Ptr long F, int Idx, @Ptr long A);
	/** Original signature : <code>int LLVMGetAttributeCountAtIndex(LLVMValueRef, LLVMAttributeIndex)</code> */
	public static int LLVMGetAttributeCountAtIndex(LLVMLibrary.LLVMValueRef F, int Idx) {
		return LLVMGetAttributeCountAtIndex(Pointer.getPeer(F), Idx);
	}
	protected native static int LLVMGetAttributeCountAtIndex(@Ptr long F, int Idx);
	/** Original signature : <code>void LLVMGetAttributesAtIndex(LLVMValueRef, LLVMAttributeIndex, LLVMAttributeRef*)</code> */
	public static void LLVMGetAttributesAtIndex(LLVMLibrary.LLVMValueRef F, int Idx, Pointer<LLVMLibrary.LLVMAttributeRef > Attrs) {
		LLVMGetAttributesAtIndex(Pointer.getPeer(F), Idx, Pointer.getPeer(Attrs));
	}
	protected native static void LLVMGetAttributesAtIndex(@Ptr long F, int Idx, @Ptr long Attrs);
	/** Original signature : <code>LLVMAttributeRef LLVMGetEnumAttributeAtIndex(LLVMValueRef, LLVMAttributeIndex, unsigned)</code> */
	public static LLVMLibrary.LLVMAttributeRef LLVMGetEnumAttributeAtIndex(LLVMLibrary.LLVMValueRef F, int Idx, int KindID) {
		return new LLVMLibrary.LLVMAttributeRef(LLVMGetEnumAttributeAtIndex(Pointer.getPeer(F), Idx, KindID));
	}
	@Ptr 
	protected native static long LLVMGetEnumAttributeAtIndex(@Ptr long F, int Idx, int KindID);
	/** Original signature : <code>LLVMAttributeRef LLVMGetStringAttributeAtIndex(LLVMValueRef, LLVMAttributeIndex, const char*, unsigned)</code> */
	public static LLVMLibrary.LLVMAttributeRef LLVMGetStringAttributeAtIndex(LLVMLibrary.LLVMValueRef F, int Idx, Pointer<Byte > K, int KLen) {
		return new LLVMLibrary.LLVMAttributeRef(LLVMGetStringAttributeAtIndex(Pointer.getPeer(F), Idx, Pointer.getPeer(K), KLen));
	}
	@Ptr 
	protected native static long LLVMGetStringAttributeAtIndex(@Ptr long F, int Idx, @Ptr long K, int KLen);
	/** Original signature : <code>void LLVMRemoveEnumAttributeAtIndex(LLVMValueRef, LLVMAttributeIndex, unsigned)</code> */
	public static void LLVMRemoveEnumAttributeAtIndex(LLVMLibrary.LLVMValueRef F, int Idx, int KindID) {
		LLVMRemoveEnumAttributeAtIndex(Pointer.getPeer(F), Idx, KindID);
	}
	protected native static void LLVMRemoveEnumAttributeAtIndex(@Ptr long F, int Idx, int KindID);
	/** Original signature : <code>void LLVMRemoveStringAttributeAtIndex(LLVMValueRef, LLVMAttributeIndex, const char*, unsigned)</code> */
	public static void LLVMRemoveStringAttributeAtIndex(LLVMLibrary.LLVMValueRef F, int Idx, Pointer<Byte > K, int KLen) {
		LLVMRemoveStringAttributeAtIndex(Pointer.getPeer(F), Idx, Pointer.getPeer(K), KLen);
	}
	protected native static void LLVMRemoveStringAttributeAtIndex(@Ptr long F, int Idx, @Ptr long K, int KLen);
	/**
	 * Add a target-dependent attribute to a function<br>
	 * @see llvm::AttrBuilder::addAttribute()<br>
	 * Original signature : <code>void LLVMAddTargetDependentFunctionAttr(LLVMValueRef, const char*, const char*)</code>
	 */
	public static void LLVMAddTargetDependentFunctionAttr(LLVMLibrary.LLVMValueRef Fn, Pointer<Byte > A, Pointer<Byte > V) {
		LLVMAddTargetDependentFunctionAttr(Pointer.getPeer(Fn), Pointer.getPeer(A), Pointer.getPeer(V));
	}
	protected native static void LLVMAddTargetDependentFunctionAttr(@Ptr long Fn, @Ptr long A, @Ptr long V);
	/**
	 * Obtain an attribute from a function.<br>
	 * @see llvm::Function::getAttributes()<br>
	 * Original signature : <code>LLVMAttribute LLVMGetFunctionAttr(LLVMValueRef)</code>
	 */
	public static IntValuedEnum<LLVMLibrary.LLVMAttribute > LLVMGetFunctionAttr(LLVMLibrary.LLVMValueRef Fn) {
		return FlagSet.fromValue(LLVMGetFunctionAttr(Pointer.getPeer(Fn)), LLVMLibrary.LLVMAttribute.class);
	}
	protected native static int LLVMGetFunctionAttr(@Ptr long Fn);
	/**
	 * Remove an attribute from a function.<br>
	 * Original signature : <code>void LLVMRemoveFunctionAttr(LLVMValueRef, LLVMAttribute)</code>
	 */
	public static void LLVMRemoveFunctionAttr(LLVMLibrary.LLVMValueRef Fn, IntValuedEnum<LLVMLibrary.LLVMAttribute > PA) {
		LLVMRemoveFunctionAttr(Pointer.getPeer(Fn), (int)PA.value());
	}
	protected native static void LLVMRemoveFunctionAttr(@Ptr long Fn, int PA);
	/**
	 * Obtain the number of parameters in a function.<br>
	 * @see llvm::Function::arg_size()<br>
	 * Original signature : <code>int LLVMCountParams(LLVMValueRef)</code>
	 */
	public static int LLVMCountParams(LLVMLibrary.LLVMValueRef Fn) {
		return LLVMCountParams(Pointer.getPeer(Fn));
	}
	protected native static int LLVMCountParams(@Ptr long Fn);
	/**
	 * Obtain the parameters in a function.<br>
	 * The takes a pointer to a pre-allocated array of LLVMValueRef that is<br>
	 * at least LLVMCountParams() long. This array will be filled with<br>
	 * LLVMValueRef instances which correspond to the parameters the<br>
	 * function receives. Each LLVMValueRef corresponds to a llvm::Argument<br>
	 * instance.<br>
	 * @see llvm::Function::arg_begin()<br>
	 * Original signature : <code>void LLVMGetParams(LLVMValueRef, LLVMValueRef*)</code>
	 */
	public static void LLVMGetParams(LLVMLibrary.LLVMValueRef Fn, Pointer<LLVMLibrary.LLVMValueRef > Params) {
		LLVMGetParams(Pointer.getPeer(Fn), Pointer.getPeer(Params));
	}
	protected native static void LLVMGetParams(@Ptr long Fn, @Ptr long Params);
	/**
	 * Obtain the parameter at the specified index.<br>
	 * Parameters are indexed from 0.<br>
	 * @see llvm::Function::arg_begin()<br>
	 * Original signature : <code>LLVMValueRef LLVMGetParam(LLVMValueRef, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetParam(LLVMLibrary.LLVMValueRef Fn, int Index) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetParam(Pointer.getPeer(Fn), Index));
	}
	@Ptr 
	protected native static long LLVMGetParam(@Ptr long Fn, int Index);
	/**
	 * Obtain the function to which this argument belongs.<br>
	 * Unlike other functions in this group, this one takes an LLVMValueRef<br>
	 * that corresponds to a llvm::Attribute.<br>
	 * The returned LLVMValueRef is the llvm::Function to which this<br>
	 * argument belongs.<br>
	 * Original signature : <code>LLVMValueRef LLVMGetParamParent(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetParamParent(LLVMLibrary.LLVMValueRef Inst) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetParamParent(Pointer.getPeer(Inst)));
	}
	@Ptr 
	protected native static long LLVMGetParamParent(@Ptr long Inst);
	/**
	 * Obtain the first parameter to a function.<br>
	 * @see llvm::Function::arg_begin()<br>
	 * Original signature : <code>LLVMValueRef LLVMGetFirstParam(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetFirstParam(LLVMLibrary.LLVMValueRef Fn) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetFirstParam(Pointer.getPeer(Fn)));
	}
	@Ptr 
	protected native static long LLVMGetFirstParam(@Ptr long Fn);
	/**
	 * Obtain the last parameter to a function.<br>
	 * @see llvm::Function::arg_end()<br>
	 * Original signature : <code>LLVMValueRef LLVMGetLastParam(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetLastParam(LLVMLibrary.LLVMValueRef Fn) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetLastParam(Pointer.getPeer(Fn)));
	}
	@Ptr 
	protected native static long LLVMGetLastParam(@Ptr long Fn);
	/**
	 * Obtain the next parameter to a function.<br>
	 * This takes an LLVMValueRef obtained from LLVMGetFirstParam() (which is<br>
	 * actually a wrapped iterator) and obtains the next parameter from the<br>
	 * underlying iterator.<br>
	 * Original signature : <code>LLVMValueRef LLVMGetNextParam(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetNextParam(LLVMLibrary.LLVMValueRef Arg) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetNextParam(Pointer.getPeer(Arg)));
	}
	@Ptr 
	protected native static long LLVMGetNextParam(@Ptr long Arg);
	/**
	 * Obtain the previous parameter to a function.<br>
	 * This is the opposite of LLVMGetNextParam().<br>
	 * Original signature : <code>LLVMValueRef LLVMGetPreviousParam(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetPreviousParam(LLVMLibrary.LLVMValueRef Arg) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetPreviousParam(Pointer.getPeer(Arg)));
	}
	@Ptr 
	protected native static long LLVMGetPreviousParam(@Ptr long Arg);
	/**
	 * Add an attribute to a function argument.<br>
	 * @see llvm::Argument::addAttr()<br>
	 * Original signature : <code>void LLVMAddAttribute(LLVMValueRef, LLVMAttribute)</code>
	 */
	public static void LLVMAddAttribute(LLVMLibrary.LLVMValueRef Arg, IntValuedEnum<LLVMLibrary.LLVMAttribute > PA) {
		LLVMAddAttribute(Pointer.getPeer(Arg), (int)PA.value());
	}
	protected native static void LLVMAddAttribute(@Ptr long Arg, int PA);
	/**
	 * Remove an attribute from a function argument.<br>
	 * @see llvm::Argument::removeAttr()<br>
	 * Original signature : <code>void LLVMRemoveAttribute(LLVMValueRef, LLVMAttribute)</code>
	 */
	public static void LLVMRemoveAttribute(LLVMLibrary.LLVMValueRef Arg, IntValuedEnum<LLVMLibrary.LLVMAttribute > PA) {
		LLVMRemoveAttribute(Pointer.getPeer(Arg), (int)PA.value());
	}
	protected native static void LLVMRemoveAttribute(@Ptr long Arg, int PA);
	/**
	 * Get an attribute from a function argument.<br>
	 * Original signature : <code>LLVMAttribute LLVMGetAttribute(LLVMValueRef)</code>
	 */
	public static IntValuedEnum<LLVMLibrary.LLVMAttribute > LLVMGetAttribute(LLVMLibrary.LLVMValueRef Arg) {
		return FlagSet.fromValue(LLVMGetAttribute(Pointer.getPeer(Arg)), LLVMLibrary.LLVMAttribute.class);
	}
	protected native static int LLVMGetAttribute(@Ptr long Arg);
	/**
	 * Set the alignment for a function parameter.<br>
	 * @see llvm::Argument::addAttr()<br>
	 * @see llvm::AttrBuilder::addAlignmentAttr()<br>
	 * Original signature : <code>void LLVMSetParamAlignment(LLVMValueRef, unsigned)</code>
	 */
	public static void LLVMSetParamAlignment(LLVMLibrary.LLVMValueRef Arg, int Align) {
		LLVMSetParamAlignment(Pointer.getPeer(Arg), Align);
	}
	protected native static void LLVMSetParamAlignment(@Ptr long Arg, int Align);
	/**
	 * Obtain a MDString value from a context.<br>
	 * The returned instance corresponds to the llvm::MDString class.<br>
	 * The instance is specified by string data of a specified length. The<br>
	 * string content is copied, so the backing memory can be freed after<br>
	 * this function returns.<br>
	 * Original signature : <code>LLVMValueRef LLVMMDStringInContext(LLVMContextRef, const char*, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMMDStringInContext(LLVMLibrary.LLVMContextRef C, Pointer<Byte > Str, int SLen) {
		return new LLVMLibrary.LLVMValueRef(LLVMMDStringInContext(Pointer.getPeer(C), Pointer.getPeer(Str), SLen));
	}
	@Ptr 
	protected native static long LLVMMDStringInContext(@Ptr long C, @Ptr long Str, int SLen);
	/**
	 * Obtain a MDString value from the global context.<br>
	 * Original signature : <code>LLVMValueRef LLVMMDString(const char*, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMMDString(Pointer<Byte > Str, int SLen) {
		return new LLVMLibrary.LLVMValueRef(LLVMMDString(Pointer.getPeer(Str), SLen));
	}
	@Ptr 
	protected native static long LLVMMDString(@Ptr long Str, int SLen);
	/**
	 * Obtain a MDNode value from a context.<br>
	 * The returned value corresponds to the llvm::MDNode class.<br>
	 * Original signature : <code>LLVMValueRef LLVMMDNodeInContext(LLVMContextRef, LLVMValueRef*, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMMDNodeInContext(LLVMLibrary.LLVMContextRef C, Pointer<LLVMLibrary.LLVMValueRef > Vals, int Count) {
		return new LLVMLibrary.LLVMValueRef(LLVMMDNodeInContext(Pointer.getPeer(C), Pointer.getPeer(Vals), Count));
	}
	@Ptr 
	protected native static long LLVMMDNodeInContext(@Ptr long C, @Ptr long Vals, int Count);
	/**
	 * Obtain a MDNode value from the global context.<br>
	 * Original signature : <code>LLVMValueRef LLVMMDNode(LLVMValueRef*, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMMDNode(Pointer<LLVMLibrary.LLVMValueRef > Vals, int Count) {
		return new LLVMLibrary.LLVMValueRef(LLVMMDNode(Pointer.getPeer(Vals), Count));
	}
	@Ptr 
	protected native static long LLVMMDNode(@Ptr long Vals, int Count);
	/**
	 * Obtain the underlying string from a MDString value.<br>
	 * @param V Instance to obtain string from.<br>
	 * @param Length Memory address which will hold length of returned string.<br>
	 * @return String data in MDString.<br>
	 * Original signature : <code>char* LLVMGetMDString(LLVMValueRef, unsigned*)</code>
	 */
	public static Pointer<Byte > LLVMGetMDString(LLVMLibrary.LLVMValueRef V, Pointer<Integer > Length) {
		return (Pointer)Pointer.pointerToAddress(LLVMGetMDString(Pointer.getPeer(V), Pointer.getPeer(Length)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetMDString(@Ptr long V, @Ptr long Length);
	/**
	 * Obtain the number of operands from an MDNode value.<br>
	 * @param V MDNode to get number of operands from.<br>
	 * @return Number of operands of the MDNode.<br>
	 * Original signature : <code>int LLVMGetMDNodeNumOperands(LLVMValueRef)</code>
	 */
	public static int LLVMGetMDNodeNumOperands(LLVMLibrary.LLVMValueRef V) {
		return LLVMGetMDNodeNumOperands(Pointer.getPeer(V));
	}
	protected native static int LLVMGetMDNodeNumOperands(@Ptr long V);
	/**
	 * Obtain the given MDNode's operands.<br>
	 * The passed LLVMValueRef pointer should point to enough memory to hold all of<br>
	 * the operands of the given MDNode (see LLVMGetMDNodeNumOperands) as<br>
	 * LLVMValueRefs. This memory will be populated with the LLVMValueRefs of the<br>
	 * MDNode's operands.<br>
	 * @param V MDNode to get the operands from.<br>
	 * @param Dest Destination array for operands.<br>
	 * Original signature : <code>void LLVMGetMDNodeOperands(LLVMValueRef, LLVMValueRef*)</code>
	 */
	public static void LLVMGetMDNodeOperands(LLVMLibrary.LLVMValueRef V, Pointer<LLVMLibrary.LLVMValueRef > Dest) {
		LLVMGetMDNodeOperands(Pointer.getPeer(V), Pointer.getPeer(Dest));
	}
	protected native static void LLVMGetMDNodeOperands(@Ptr long V, @Ptr long Dest);
	/**
	 * Convert a basic block instance to a value type.<br>
	 * Original signature : <code>LLVMValueRef LLVMBasicBlockAsValue(LLVMBasicBlockRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMBasicBlockAsValue(LLVMLibrary.LLVMBasicBlockRef BB) {
		return new LLVMLibrary.LLVMValueRef(LLVMBasicBlockAsValue(Pointer.getPeer(BB)));
	}
	@Ptr 
	protected native static long LLVMBasicBlockAsValue(@Ptr long BB);
	/**
	 * Determine whether an LLVMValueRef is itself a basic block.<br>
	 * Original signature : <code>LLVMBool LLVMValueIsBasicBlock(LLVMValueRef)</code>
	 */
	public static int LLVMValueIsBasicBlock(LLVMLibrary.LLVMValueRef Val) {
		return LLVMValueIsBasicBlock(Pointer.getPeer(Val));
	}
	protected native static int LLVMValueIsBasicBlock(@Ptr long Val);
	/**
	 * Convert an LLVMValueRef to an LLVMBasicBlockRef instance.<br>
	 * Original signature : <code>LLVMBasicBlockRef LLVMValueAsBasicBlock(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMBasicBlockRef LLVMValueAsBasicBlock(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMValueAsBasicBlock(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMValueAsBasicBlock(@Ptr long Val);
	/**
	 * Obtain the string name of a basic block.<br>
	 * Original signature : <code>char* LLVMGetBasicBlockName(LLVMBasicBlockRef)</code>
	 */
	public static Pointer<Byte > LLVMGetBasicBlockName(LLVMLibrary.LLVMBasicBlockRef BB) {
		return (Pointer)Pointer.pointerToAddress(LLVMGetBasicBlockName(Pointer.getPeer(BB)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetBasicBlockName(@Ptr long BB);
	/**
	 * Obtain the function to which a basic block belongs.<br>
	 * @see llvm::BasicBlock::getParent()<br>
	 * Original signature : <code>LLVMValueRef LLVMGetBasicBlockParent(LLVMBasicBlockRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetBasicBlockParent(LLVMLibrary.LLVMBasicBlockRef BB) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetBasicBlockParent(Pointer.getPeer(BB)));
	}
	@Ptr 
	protected native static long LLVMGetBasicBlockParent(@Ptr long BB);
	/**
	 * Obtain the terminator instruction for a basic block.<br>
	 * If the basic block does not have a terminator (it is not well-formed<br>
	 * if it doesn't), then NULL is returned.<br>
	 * The returned LLVMValueRef corresponds to a llvm::TerminatorInst.<br>
	 * @see llvm::BasicBlock::getTerminator()<br>
	 * Original signature : <code>LLVMValueRef LLVMGetBasicBlockTerminator(LLVMBasicBlockRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetBasicBlockTerminator(LLVMLibrary.LLVMBasicBlockRef BB) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetBasicBlockTerminator(Pointer.getPeer(BB)));
	}
	@Ptr 
	protected native static long LLVMGetBasicBlockTerminator(@Ptr long BB);
	/**
	 * Obtain the number of basic blocks in a function.<br>
	 * @param Fn Function value to operate on.<br>
	 * Original signature : <code>int LLVMCountBasicBlocks(LLVMValueRef)</code>
	 */
	public static int LLVMCountBasicBlocks(LLVMLibrary.LLVMValueRef Fn) {
		return LLVMCountBasicBlocks(Pointer.getPeer(Fn));
	}
	protected native static int LLVMCountBasicBlocks(@Ptr long Fn);
	/**
	 * Obtain all of the basic blocks in a function.<br>
	 * This operates on a function value. The BasicBlocks parameter is a<br>
	 * pointer to a pre-allocated array of LLVMBasicBlockRef of at least<br>
	 * LLVMCountBasicBlocks() in length. This array is populated with<br>
	 * LLVMBasicBlockRef instances.<br>
	 * Original signature : <code>void LLVMGetBasicBlocks(LLVMValueRef, LLVMBasicBlockRef*)</code>
	 */
	public static void LLVMGetBasicBlocks(LLVMLibrary.LLVMValueRef Fn, Pointer<LLVMLibrary.LLVMBasicBlockRef > BasicBlocks) {
		LLVMGetBasicBlocks(Pointer.getPeer(Fn), Pointer.getPeer(BasicBlocks));
	}
	protected native static void LLVMGetBasicBlocks(@Ptr long Fn, @Ptr long BasicBlocks);
	/**
	 * Obtain the first basic block in a function.<br>
	 * The returned basic block can be used as an iterator. You will likely<br>
	 * eventually call into LLVMGetNextBasicBlock() with it.<br>
	 * @see llvm::Function::begin()<br>
	 * Original signature : <code>LLVMBasicBlockRef LLVMGetFirstBasicBlock(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMBasicBlockRef LLVMGetFirstBasicBlock(LLVMLibrary.LLVMValueRef Fn) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMGetFirstBasicBlock(Pointer.getPeer(Fn)));
	}
	@Ptr 
	protected native static long LLVMGetFirstBasicBlock(@Ptr long Fn);
	/**
	 * Obtain the last basic block in a function.<br>
	 * @see llvm::Function::end()<br>
	 * Original signature : <code>LLVMBasicBlockRef LLVMGetLastBasicBlock(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMBasicBlockRef LLVMGetLastBasicBlock(LLVMLibrary.LLVMValueRef Fn) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMGetLastBasicBlock(Pointer.getPeer(Fn)));
	}
	@Ptr 
	protected native static long LLVMGetLastBasicBlock(@Ptr long Fn);
	/**
	 * Advance a basic block iterator.<br>
	 * Original signature : <code>LLVMBasicBlockRef LLVMGetNextBasicBlock(LLVMBasicBlockRef)</code>
	 */
	public static LLVMLibrary.LLVMBasicBlockRef LLVMGetNextBasicBlock(LLVMLibrary.LLVMBasicBlockRef BB) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMGetNextBasicBlock(Pointer.getPeer(BB)));
	}
	@Ptr 
	protected native static long LLVMGetNextBasicBlock(@Ptr long BB);
	/**
	 * Go backwards in a basic block iterator.<br>
	 * Original signature : <code>LLVMBasicBlockRef LLVMGetPreviousBasicBlock(LLVMBasicBlockRef)</code>
	 */
	public static LLVMLibrary.LLVMBasicBlockRef LLVMGetPreviousBasicBlock(LLVMLibrary.LLVMBasicBlockRef BB) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMGetPreviousBasicBlock(Pointer.getPeer(BB)));
	}
	@Ptr 
	protected native static long LLVMGetPreviousBasicBlock(@Ptr long BB);
	/**
	 * Obtain the basic block that corresponds to the entry point of a<br>
	 * function.<br>
	 * @see llvm::Function::getEntryBlock()<br>
	 * Original signature : <code>LLVMBasicBlockRef LLVMGetEntryBasicBlock(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMBasicBlockRef LLVMGetEntryBasicBlock(LLVMLibrary.LLVMValueRef Fn) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMGetEntryBasicBlock(Pointer.getPeer(Fn)));
	}
	@Ptr 
	protected native static long LLVMGetEntryBasicBlock(@Ptr long Fn);
	/**
	 * Append a basic block to the end of a function.<br>
	 * @see llvm::BasicBlock::Create()<br>
	 * Original signature : <code>LLVMBasicBlockRef LLVMAppendBasicBlockInContext(LLVMContextRef, LLVMValueRef, const char*)</code>
	 */
	public static LLVMLibrary.LLVMBasicBlockRef LLVMAppendBasicBlockInContext(LLVMLibrary.LLVMContextRef C, LLVMLibrary.LLVMValueRef Fn, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMAppendBasicBlockInContext(Pointer.getPeer(C), Pointer.getPeer(Fn), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMAppendBasicBlockInContext(@Ptr long C, @Ptr long Fn, @Ptr long Name);
	/**
	 * Append a basic block to the end of a function using the global<br>
	 * context.<br>
	 * @see llvm::BasicBlock::Create()<br>
	 * Original signature : <code>LLVMBasicBlockRef LLVMAppendBasicBlock(LLVMValueRef, const char*)</code>
	 */
	public static LLVMLibrary.LLVMBasicBlockRef LLVMAppendBasicBlock(LLVMLibrary.LLVMValueRef Fn, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMAppendBasicBlock(Pointer.getPeer(Fn), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMAppendBasicBlock(@Ptr long Fn, @Ptr long Name);
	/**
	 * Insert a basic block in a function before another basic block.<br>
	 * The function to add to is determined by the function of the<br>
	 * passed basic block.<br>
	 * @see llvm::BasicBlock::Create()<br>
	 * Original signature : <code>LLVMBasicBlockRef LLVMInsertBasicBlockInContext(LLVMContextRef, LLVMBasicBlockRef, const char*)</code>
	 */
	public static LLVMLibrary.LLVMBasicBlockRef LLVMInsertBasicBlockInContext(LLVMLibrary.LLVMContextRef C, LLVMLibrary.LLVMBasicBlockRef BB, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMInsertBasicBlockInContext(Pointer.getPeer(C), Pointer.getPeer(BB), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMInsertBasicBlockInContext(@Ptr long C, @Ptr long BB, @Ptr long Name);
	/**
	 * Insert a basic block in a function using the global context.<br>
	 * @see llvm::BasicBlock::Create()<br>
	 * Original signature : <code>LLVMBasicBlockRef LLVMInsertBasicBlock(LLVMBasicBlockRef, const char*)</code>
	 */
	public static LLVMLibrary.LLVMBasicBlockRef LLVMInsertBasicBlock(LLVMLibrary.LLVMBasicBlockRef InsertBeforeBB, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMInsertBasicBlock(Pointer.getPeer(InsertBeforeBB), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMInsertBasicBlock(@Ptr long InsertBeforeBB, @Ptr long Name);
	/**
	 * Remove a basic block from a function and delete it.<br>
	 * This deletes the basic block from its containing function and deletes<br>
	 * the basic block itself.<br>
	 * @see llvm::BasicBlock::eraseFromParent()<br>
	 * Original signature : <code>void LLVMDeleteBasicBlock(LLVMBasicBlockRef)</code>
	 */
	public static void LLVMDeleteBasicBlock(LLVMLibrary.LLVMBasicBlockRef BB) {
		LLVMDeleteBasicBlock(Pointer.getPeer(BB));
	}
	protected native static void LLVMDeleteBasicBlock(@Ptr long BB);
	/**
	 * Remove a basic block from a function.<br>
	 * This deletes the basic block from its containing function but keep<br>
	 * the basic block alive.<br>
	 * @see llvm::BasicBlock::removeFromParent()<br>
	 * Original signature : <code>void LLVMRemoveBasicBlockFromParent(LLVMBasicBlockRef)</code>
	 */
	public static void LLVMRemoveBasicBlockFromParent(LLVMLibrary.LLVMBasicBlockRef BB) {
		LLVMRemoveBasicBlockFromParent(Pointer.getPeer(BB));
	}
	protected native static void LLVMRemoveBasicBlockFromParent(@Ptr long BB);
	/**
	 * Move a basic block to before another one.<br>
	 * @see llvm::BasicBlock::moveBefore()<br>
	 * Original signature : <code>void LLVMMoveBasicBlockBefore(LLVMBasicBlockRef, LLVMBasicBlockRef)</code>
	 */
	public static void LLVMMoveBasicBlockBefore(LLVMLibrary.LLVMBasicBlockRef BB, LLVMLibrary.LLVMBasicBlockRef MovePos) {
		LLVMMoveBasicBlockBefore(Pointer.getPeer(BB), Pointer.getPeer(MovePos));
	}
	protected native static void LLVMMoveBasicBlockBefore(@Ptr long BB, @Ptr long MovePos);
	/**
	 * Move a basic block to after another one.<br>
	 * @see llvm::BasicBlock::moveAfter()<br>
	 * Original signature : <code>void LLVMMoveBasicBlockAfter(LLVMBasicBlockRef, LLVMBasicBlockRef)</code>
	 */
	public static void LLVMMoveBasicBlockAfter(LLVMLibrary.LLVMBasicBlockRef BB, LLVMLibrary.LLVMBasicBlockRef MovePos) {
		LLVMMoveBasicBlockAfter(Pointer.getPeer(BB), Pointer.getPeer(MovePos));
	}
	protected native static void LLVMMoveBasicBlockAfter(@Ptr long BB, @Ptr long MovePos);
	/**
	 * Obtain the first instruction in a basic block.<br>
	 * The returned LLVMValueRef corresponds to a llvm::Instruction<br>
	 * instance.<br>
	 * Original signature : <code>LLVMValueRef LLVMGetFirstInstruction(LLVMBasicBlockRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetFirstInstruction(LLVMLibrary.LLVMBasicBlockRef BB) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetFirstInstruction(Pointer.getPeer(BB)));
	}
	@Ptr 
	protected native static long LLVMGetFirstInstruction(@Ptr long BB);
	/**
	 * Obtain the last instruction in a basic block.<br>
	 * The returned LLVMValueRef corresponds to an LLVM:Instruction.<br>
	 * Original signature : <code>LLVMValueRef LLVMGetLastInstruction(LLVMBasicBlockRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetLastInstruction(LLVMLibrary.LLVMBasicBlockRef BB) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetLastInstruction(Pointer.getPeer(BB)));
	}
	@Ptr 
	protected native static long LLVMGetLastInstruction(@Ptr long BB);
	/**
	 * Determine whether an instruction has any metadata attached.<br>
	 * Original signature : <code>int LLVMHasMetadata(LLVMValueRef)</code>
	 */
	public static int LLVMHasMetadata(LLVMLibrary.LLVMValueRef Val) {
		return LLVMHasMetadata(Pointer.getPeer(Val));
	}
	protected native static int LLVMHasMetadata(@Ptr long Val);
	/**
	 * Return metadata associated with an instruction value.<br>
	 * Original signature : <code>LLVMValueRef LLVMGetMetadata(LLVMValueRef, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetMetadata(LLVMLibrary.LLVMValueRef Val, int KindID) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetMetadata(Pointer.getPeer(Val), KindID));
	}
	@Ptr 
	protected native static long LLVMGetMetadata(@Ptr long Val, int KindID);
	/**
	 * Set metadata associated with an instruction value.<br>
	 * Original signature : <code>void LLVMSetMetadata(LLVMValueRef, unsigned, LLVMValueRef)</code>
	 */
	public static void LLVMSetMetadata(LLVMLibrary.LLVMValueRef Val, int KindID, LLVMLibrary.LLVMValueRef Node) {
		LLVMSetMetadata(Pointer.getPeer(Val), KindID, Pointer.getPeer(Node));
	}
	protected native static void LLVMSetMetadata(@Ptr long Val, int KindID, @Ptr long Node);
	/**
	 * Obtain the basic block to which an instruction belongs.<br>
	 * @see llvm::Instruction::getParent()<br>
	 * Original signature : <code>LLVMBasicBlockRef LLVMGetInstructionParent(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMBasicBlockRef LLVMGetInstructionParent(LLVMLibrary.LLVMValueRef Inst) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMGetInstructionParent(Pointer.getPeer(Inst)));
	}
	@Ptr 
	protected native static long LLVMGetInstructionParent(@Ptr long Inst);
	/**
	 * Obtain the instruction that occurs after the one specified.<br>
	 * The next instruction will be from the same basic block.<br>
	 * If this is the last instruction in a basic block, NULL will be<br>
	 * returned.<br>
	 * Original signature : <code>LLVMValueRef LLVMGetNextInstruction(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetNextInstruction(LLVMLibrary.LLVMValueRef Inst) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetNextInstruction(Pointer.getPeer(Inst)));
	}
	@Ptr 
	protected native static long LLVMGetNextInstruction(@Ptr long Inst);
	/**
	 * Obtain the instruction that occurred before this one.<br>
	 * If the instruction is the first instruction in a basic block, NULL<br>
	 * will be returned.<br>
	 * Original signature : <code>LLVMValueRef LLVMGetPreviousInstruction(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetPreviousInstruction(LLVMLibrary.LLVMValueRef Inst) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetPreviousInstruction(Pointer.getPeer(Inst)));
	}
	@Ptr 
	protected native static long LLVMGetPreviousInstruction(@Ptr long Inst);
	/**
	 * Remove and delete an instruction.<br>
	 * The instruction specified is removed from its containing building<br>
	 * block but is kept alive.<br>
	 * @see llvm::Instruction::removeFromParent()<br>
	 * Original signature : <code>void LLVMInstructionRemoveFromParent(LLVMValueRef)</code>
	 */
	public static void LLVMInstructionRemoveFromParent(LLVMLibrary.LLVMValueRef Inst) {
		LLVMInstructionRemoveFromParent(Pointer.getPeer(Inst));
	}
	protected native static void LLVMInstructionRemoveFromParent(@Ptr long Inst);
	/**
	 * Remove and delete an instruction.<br>
	 * The instruction specified is removed from its containing building<br>
	 * block and then deleted.<br>
	 * @see llvm::Instruction::eraseFromParent()<br>
	 * Original signature : <code>void LLVMInstructionEraseFromParent(LLVMValueRef)</code>
	 */
	public static void LLVMInstructionEraseFromParent(LLVMLibrary.LLVMValueRef Inst) {
		LLVMInstructionEraseFromParent(Pointer.getPeer(Inst));
	}
	protected native static void LLVMInstructionEraseFromParent(@Ptr long Inst);
	/**
	 * Obtain the code opcode for an individual instruction.<br>
	 * @see llvm::Instruction::getOpCode()<br>
	 * Original signature : <code>LLVMOpcode LLVMGetInstructionOpcode(LLVMValueRef)</code>
	 */
	public static IntValuedEnum<LLVMLibrary.LLVMOpcode > LLVMGetInstructionOpcode(LLVMLibrary.LLVMValueRef Inst) {
		return FlagSet.fromValue(LLVMGetInstructionOpcode(Pointer.getPeer(Inst)), LLVMLibrary.LLVMOpcode.class);
	}
	protected native static int LLVMGetInstructionOpcode(@Ptr long Inst);
	/**
	 * Obtain the predicate of an instruction.<br>
	 * This is only valid for instructions that correspond to llvm::ICmpInst<br>
	 * or llvm::ConstantExpr whose opcode is llvm::Instruction::ICmp.<br>
	 * @see llvm::ICmpInst::getPredicate()<br>
	 * Original signature : <code>LLVMIntPredicate LLVMGetICmpPredicate(LLVMValueRef)</code>
	 */
	public static IntValuedEnum<LLVMLibrary.LLVMIntPredicate > LLVMGetICmpPredicate(LLVMLibrary.LLVMValueRef Inst) {
		return FlagSet.fromValue(LLVMGetICmpPredicate(Pointer.getPeer(Inst)), LLVMLibrary.LLVMIntPredicate.class);
	}
	protected native static int LLVMGetICmpPredicate(@Ptr long Inst);
	/**
	 * Obtain the float predicate of an instruction.<br>
	 * This is only valid for instructions that correspond to llvm::FCmpInst<br>
	 * or llvm::ConstantExpr whose opcode is llvm::Instruction::FCmp.<br>
	 * @see llvm::FCmpInst::getPredicate()<br>
	 * Original signature : <code>LLVMRealPredicate LLVMGetFCmpPredicate(LLVMValueRef)</code>
	 */
	public static IntValuedEnum<LLVMLibrary.LLVMRealPredicate > LLVMGetFCmpPredicate(LLVMLibrary.LLVMValueRef Inst) {
		return FlagSet.fromValue(LLVMGetFCmpPredicate(Pointer.getPeer(Inst)), LLVMLibrary.LLVMRealPredicate.class);
	}
	protected native static int LLVMGetFCmpPredicate(@Ptr long Inst);
	/**
	 * Create a copy of 'this' instruction that is identical in all ways<br>
	 * except the following:<br>
	 * The instruction has no parent<br>
	 * The instruction has no name<br>
	 * @see llvm::Instruction::clone()<br>
	 * Original signature : <code>LLVMValueRef LLVMInstructionClone(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMInstructionClone(LLVMLibrary.LLVMValueRef Inst) {
		return new LLVMLibrary.LLVMValueRef(LLVMInstructionClone(Pointer.getPeer(Inst)));
	}
	@Ptr 
	protected native static long LLVMInstructionClone(@Ptr long Inst);
	/**
	 * Obtain the argument count for a call instruction.<br>
	 * This expects an LLVMValueRef that corresponds to a llvm::CallInst or<br>
	 * llvm::InvokeInst.<br>
	 * @see llvm::CallInst::getNumArgOperands()<br>
	 * @see llvm::InvokeInst::getNumArgOperands()<br>
	 * Original signature : <code>int LLVMGetNumArgOperands(LLVMValueRef)</code>
	 */
	public static int LLVMGetNumArgOperands(LLVMLibrary.LLVMValueRef Instr) {
		return LLVMGetNumArgOperands(Pointer.getPeer(Instr));
	}
	protected native static int LLVMGetNumArgOperands(@Ptr long Instr);
	/**
	 * Set the calling convention for a call instruction.<br>
	 * This expects an LLVMValueRef that corresponds to a llvm::CallInst or<br>
	 * llvm::InvokeInst.<br>
	 * @see llvm::CallInst::setCallingConv()<br>
	 * @see llvm::InvokeInst::setCallingConv()<br>
	 * Original signature : <code>void LLVMSetInstructionCallConv(LLVMValueRef, unsigned)</code>
	 */
	public static void LLVMSetInstructionCallConv(LLVMLibrary.LLVMValueRef Instr, int CC) {
		LLVMSetInstructionCallConv(Pointer.getPeer(Instr), CC);
	}
	protected native static void LLVMSetInstructionCallConv(@Ptr long Instr, int CC);
	/**
	 * Obtain the calling convention for a call instruction.<br>
	 * This is the opposite of LLVMSetInstructionCallConv(). Reads its<br>
	 * usage.<br>
	 * @see LLVMSetInstructionCallConv()<br>
	 * Original signature : <code>int LLVMGetInstructionCallConv(LLVMValueRef)</code>
	 */
	public static int LLVMGetInstructionCallConv(LLVMLibrary.LLVMValueRef Instr) {
		return LLVMGetInstructionCallConv(Pointer.getPeer(Instr));
	}
	protected native static int LLVMGetInstructionCallConv(@Ptr long Instr);
	/** Original signature : <code>void LLVMAddInstrAttribute(LLVMValueRef, unsigned, LLVMAttribute)</code> */
	public static void LLVMAddInstrAttribute(LLVMLibrary.LLVMValueRef Instr, int index, IntValuedEnum<LLVMLibrary.LLVMAttribute > LLVMAttribute1) {
		LLVMAddInstrAttribute(Pointer.getPeer(Instr), index, (int)LLVMAttribute1.value());
	}
	protected native static void LLVMAddInstrAttribute(@Ptr long Instr, int index, int LLVMAttribute1);
	/** Original signature : <code>void LLVMRemoveInstrAttribute(LLVMValueRef, unsigned, LLVMAttribute)</code> */
	public static void LLVMRemoveInstrAttribute(LLVMLibrary.LLVMValueRef Instr, int index, IntValuedEnum<LLVMLibrary.LLVMAttribute > LLVMAttribute1) {
		LLVMRemoveInstrAttribute(Pointer.getPeer(Instr), index, (int)LLVMAttribute1.value());
	}
	protected native static void LLVMRemoveInstrAttribute(@Ptr long Instr, int index, int LLVMAttribute1);
	/** Original signature : <code>void LLVMSetInstrParamAlignment(LLVMValueRef, unsigned, unsigned)</code> */
	public static void LLVMSetInstrParamAlignment(LLVMLibrary.LLVMValueRef Instr, int index, int Align) {
		LLVMSetInstrParamAlignment(Pointer.getPeer(Instr), index, Align);
	}
	protected native static void LLVMSetInstrParamAlignment(@Ptr long Instr, int index, int Align);
	/** Original signature : <code>void LLVMAddCallSiteAttribute(LLVMValueRef, LLVMAttributeIndex, LLVMAttributeRef)</code> */
	public static void LLVMAddCallSiteAttribute(LLVMLibrary.LLVMValueRef C, int Idx, LLVMLibrary.LLVMAttributeRef A) {
		LLVMAddCallSiteAttribute(Pointer.getPeer(C), Idx, Pointer.getPeer(A));
	}
	protected native static void LLVMAddCallSiteAttribute(@Ptr long C, int Idx, @Ptr long A);
	/** Original signature : <code>int LLVMGetCallSiteAttributeCount(LLVMValueRef, LLVMAttributeIndex)</code> */
	public static int LLVMGetCallSiteAttributeCount(LLVMLibrary.LLVMValueRef C, int Idx) {
		return LLVMGetCallSiteAttributeCount(Pointer.getPeer(C), Idx);
	}
	protected native static int LLVMGetCallSiteAttributeCount(@Ptr long C, int Idx);
	/** Original signature : <code>void LLVMGetCallSiteAttributes(LLVMValueRef, LLVMAttributeIndex, LLVMAttributeRef*)</code> */
	public static void LLVMGetCallSiteAttributes(LLVMLibrary.LLVMValueRef C, int Idx, Pointer<LLVMLibrary.LLVMAttributeRef > Attrs) {
		LLVMGetCallSiteAttributes(Pointer.getPeer(C), Idx, Pointer.getPeer(Attrs));
	}
	protected native static void LLVMGetCallSiteAttributes(@Ptr long C, int Idx, @Ptr long Attrs);
	/** Original signature : <code>LLVMAttributeRef LLVMGetCallSiteEnumAttribute(LLVMValueRef, LLVMAttributeIndex, unsigned)</code> */
	public static LLVMLibrary.LLVMAttributeRef LLVMGetCallSiteEnumAttribute(LLVMLibrary.LLVMValueRef C, int Idx, int KindID) {
		return new LLVMLibrary.LLVMAttributeRef(LLVMGetCallSiteEnumAttribute(Pointer.getPeer(C), Idx, KindID));
	}
	@Ptr 
	protected native static long LLVMGetCallSiteEnumAttribute(@Ptr long C, int Idx, int KindID);
	/** Original signature : <code>LLVMAttributeRef LLVMGetCallSiteStringAttribute(LLVMValueRef, LLVMAttributeIndex, const char*, unsigned)</code> */
	public static LLVMLibrary.LLVMAttributeRef LLVMGetCallSiteStringAttribute(LLVMLibrary.LLVMValueRef C, int Idx, Pointer<Byte > K, int KLen) {
		return new LLVMLibrary.LLVMAttributeRef(LLVMGetCallSiteStringAttribute(Pointer.getPeer(C), Idx, Pointer.getPeer(K), KLen));
	}
	@Ptr 
	protected native static long LLVMGetCallSiteStringAttribute(@Ptr long C, int Idx, @Ptr long K, int KLen);
	/** Original signature : <code>void LLVMRemoveCallSiteEnumAttribute(LLVMValueRef, LLVMAttributeIndex, unsigned)</code> */
	public static void LLVMRemoveCallSiteEnumAttribute(LLVMLibrary.LLVMValueRef C, int Idx, int KindID) {
		LLVMRemoveCallSiteEnumAttribute(Pointer.getPeer(C), Idx, KindID);
	}
	protected native static void LLVMRemoveCallSiteEnumAttribute(@Ptr long C, int Idx, int KindID);
	/** Original signature : <code>void LLVMRemoveCallSiteStringAttribute(LLVMValueRef, LLVMAttributeIndex, const char*, unsigned)</code> */
	public static void LLVMRemoveCallSiteStringAttribute(LLVMLibrary.LLVMValueRef C, int Idx, Pointer<Byte > K, int KLen) {
		LLVMRemoveCallSiteStringAttribute(Pointer.getPeer(C), Idx, Pointer.getPeer(K), KLen);
	}
	protected native static void LLVMRemoveCallSiteStringAttribute(@Ptr long C, int Idx, @Ptr long K, int KLen);
	/**
	 * Obtain the pointer to the function invoked by this instruction.<br>
	 * This expects an LLVMValueRef that corresponds to a llvm::CallInst or<br>
	 * llvm::InvokeInst.<br>
	 * @see llvm::CallInst::getCalledValue()<br>
	 * @see llvm::InvokeInst::getCalledValue()<br>
	 * Original signature : <code>LLVMValueRef LLVMGetCalledValue(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetCalledValue(LLVMLibrary.LLVMValueRef Instr) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetCalledValue(Pointer.getPeer(Instr)));
	}
	@Ptr 
	protected native static long LLVMGetCalledValue(@Ptr long Instr);
	/**
	 * Obtain whether a call instruction is a tail call.<br>
	 * This only works on llvm::CallInst instructions.<br>
	 * @see llvm::CallInst::isTailCall()<br>
	 * Original signature : <code>LLVMBool LLVMIsTailCall(LLVMValueRef)</code>
	 */
	public static int LLVMIsTailCall(LLVMLibrary.LLVMValueRef CallInst) {
		return LLVMIsTailCall(Pointer.getPeer(CallInst));
	}
	protected native static int LLVMIsTailCall(@Ptr long CallInst);
	/**
	 * Set whether a call instruction is a tail call.<br>
	 * This only works on llvm::CallInst instructions.<br>
	 * @see llvm::CallInst::setTailCall()<br>
	 * Original signature : <code>void LLVMSetTailCall(LLVMValueRef, LLVMBool)</code>
	 */
	public static void LLVMSetTailCall(LLVMLibrary.LLVMValueRef CallInst, int IsTailCall) {
		LLVMSetTailCall(Pointer.getPeer(CallInst), IsTailCall);
	}
	protected native static void LLVMSetTailCall(@Ptr long CallInst, int IsTailCall);
	/**
	 * Return the normal destination basic block.<br>
	 * This only works on llvm::InvokeInst instructions.<br>
	 * @see llvm::InvokeInst::getNormalDest()<br>
	 * Original signature : <code>LLVMBasicBlockRef LLVMGetNormalDest(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMBasicBlockRef LLVMGetNormalDest(LLVMLibrary.LLVMValueRef InvokeInst) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMGetNormalDest(Pointer.getPeer(InvokeInst)));
	}
	@Ptr 
	protected native static long LLVMGetNormalDest(@Ptr long InvokeInst);
	/**
	 * Return the unwind destination basic block.<br>
	 * This only works on llvm::InvokeInst instructions.<br>
	 * @see llvm::InvokeInst::getUnwindDest()<br>
	 * Original signature : <code>LLVMBasicBlockRef LLVMGetUnwindDest(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMBasicBlockRef LLVMGetUnwindDest(LLVMLibrary.LLVMValueRef InvokeInst) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMGetUnwindDest(Pointer.getPeer(InvokeInst)));
	}
	@Ptr 
	protected native static long LLVMGetUnwindDest(@Ptr long InvokeInst);
	/**
	 * Set the normal destination basic block.<br>
	 * This only works on llvm::InvokeInst instructions.<br>
	 * @see llvm::InvokeInst::setNormalDest()<br>
	 * Original signature : <code>void LLVMSetNormalDest(LLVMValueRef, LLVMBasicBlockRef)</code>
	 */
	public static void LLVMSetNormalDest(LLVMLibrary.LLVMValueRef InvokeInst, LLVMLibrary.LLVMBasicBlockRef B) {
		LLVMSetNormalDest(Pointer.getPeer(InvokeInst), Pointer.getPeer(B));
	}
	protected native static void LLVMSetNormalDest(@Ptr long InvokeInst, @Ptr long B);
	/**
	 * Set the unwind destination basic block.<br>
	 * This only works on llvm::InvokeInst instructions.<br>
	 * @see llvm::InvokeInst::setUnwindDest()<br>
	 * Original signature : <code>void LLVMSetUnwindDest(LLVMValueRef, LLVMBasicBlockRef)</code>
	 */
	public static void LLVMSetUnwindDest(LLVMLibrary.LLVMValueRef InvokeInst, LLVMLibrary.LLVMBasicBlockRef B) {
		LLVMSetUnwindDest(Pointer.getPeer(InvokeInst), Pointer.getPeer(B));
	}
	protected native static void LLVMSetUnwindDest(@Ptr long InvokeInst, @Ptr long B);
	/**
	 * Return the number of successors that this terminator has.<br>
	 * @see llvm::TerminatorInst::getNumSuccessors<br>
	 * Original signature : <code>int LLVMGetNumSuccessors(LLVMValueRef)</code>
	 */
	public static int LLVMGetNumSuccessors(LLVMLibrary.LLVMValueRef Term) {
		return LLVMGetNumSuccessors(Pointer.getPeer(Term));
	}
	protected native static int LLVMGetNumSuccessors(@Ptr long Term);
	/**
	 * Return the specified successor.<br>
	 * @see llvm::TerminatorInst::getSuccessor<br>
	 * Original signature : <code>LLVMBasicBlockRef LLVMGetSuccessor(LLVMValueRef, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMBasicBlockRef LLVMGetSuccessor(LLVMLibrary.LLVMValueRef Term, int i) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMGetSuccessor(Pointer.getPeer(Term), i));
	}
	@Ptr 
	protected native static long LLVMGetSuccessor(@Ptr long Term, int i);
	/**
	 * Update the specified successor to point at the provided block.<br>
	 * @see llvm::TerminatorInst::setSuccessor<br>
	 * Original signature : <code>void LLVMSetSuccessor(LLVMValueRef, unsigned, LLVMBasicBlockRef)</code>
	 */
	public static void LLVMSetSuccessor(LLVMLibrary.LLVMValueRef Term, int i, LLVMLibrary.LLVMBasicBlockRef block) {
		LLVMSetSuccessor(Pointer.getPeer(Term), i, Pointer.getPeer(block));
	}
	protected native static void LLVMSetSuccessor(@Ptr long Term, int i, @Ptr long block);
	/**
	 * Return if a branch is conditional.<br>
	 * This only works on llvm::BranchInst instructions.<br>
	 * @see llvm::BranchInst::isConditional<br>
	 * Original signature : <code>LLVMBool LLVMIsConditional(LLVMValueRef)</code>
	 */
	public static int LLVMIsConditional(LLVMLibrary.LLVMValueRef Branch) {
		return LLVMIsConditional(Pointer.getPeer(Branch));
	}
	protected native static int LLVMIsConditional(@Ptr long Branch);
	/**
	 * Return the condition of a branch instruction.<br>
	 * This only works on llvm::BranchInst instructions.<br>
	 * @see llvm::BranchInst::getCondition<br>
	 * Original signature : <code>LLVMValueRef LLVMGetCondition(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetCondition(LLVMLibrary.LLVMValueRef Branch) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetCondition(Pointer.getPeer(Branch)));
	}
	@Ptr 
	protected native static long LLVMGetCondition(@Ptr long Branch);
	/**
	 * Set the condition of a branch instruction.<br>
	 * This only works on llvm::BranchInst instructions.<br>
	 * @see llvm::BranchInst::setCondition<br>
	 * Original signature : <code>void LLVMSetCondition(LLVMValueRef, LLVMValueRef)</code>
	 */
	public static void LLVMSetCondition(LLVMLibrary.LLVMValueRef Branch, LLVMLibrary.LLVMValueRef Cond) {
		LLVMSetCondition(Pointer.getPeer(Branch), Pointer.getPeer(Cond));
	}
	protected native static void LLVMSetCondition(@Ptr long Branch, @Ptr long Cond);
	/**
	 * Obtain the default destination basic block of a switch instruction.<br>
	 * This only works on llvm::SwitchInst instructions.<br>
	 * @see llvm::SwitchInst::getDefaultDest()<br>
	 * Original signature : <code>LLVMBasicBlockRef LLVMGetSwitchDefaultDest(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMBasicBlockRef LLVMGetSwitchDefaultDest(LLVMLibrary.LLVMValueRef SwitchInstr) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMGetSwitchDefaultDest(Pointer.getPeer(SwitchInstr)));
	}
	@Ptr 
	protected native static long LLVMGetSwitchDefaultDest(@Ptr long SwitchInstr);
	/**
	 * Obtain the type that is being allocated by the alloca instruction.<br>
	 * Original signature : <code>LLVMTypeRef LLVMGetAllocatedType(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMGetAllocatedType(LLVMLibrary.LLVMValueRef Alloca) {
		return new LLVMLibrary.LLVMTypeRef(LLVMGetAllocatedType(Pointer.getPeer(Alloca)));
	}
	@Ptr 
	protected native static long LLVMGetAllocatedType(@Ptr long Alloca);
	/**
	 * Check whether the given GEP instruction is inbounds.<br>
	 * Original signature : <code>LLVMBool LLVMIsInBounds(LLVMValueRef)</code>
	 */
	public static int LLVMIsInBounds(LLVMLibrary.LLVMValueRef GEP) {
		return LLVMIsInBounds(Pointer.getPeer(GEP));
	}
	protected native static int LLVMIsInBounds(@Ptr long GEP);
	/**
	 * Set the given GEP instruction to be inbounds or not.<br>
	 * Original signature : <code>void LLVMSetIsInBounds(LLVMValueRef, LLVMBool)</code>
	 */
	public static void LLVMSetIsInBounds(LLVMLibrary.LLVMValueRef GEP, int InBounds) {
		LLVMSetIsInBounds(Pointer.getPeer(GEP), InBounds);
	}
	protected native static void LLVMSetIsInBounds(@Ptr long GEP, int InBounds);
	/**
	 * Add an incoming value to the end of a PHI list.<br>
	 * Original signature : <code>void LLVMAddIncoming(LLVMValueRef, LLVMValueRef*, LLVMBasicBlockRef*, unsigned)</code>
	 */
	public static void LLVMAddIncoming(LLVMLibrary.LLVMValueRef PhiNode, Pointer<LLVMLibrary.LLVMValueRef > IncomingValues, Pointer<LLVMLibrary.LLVMBasicBlockRef > IncomingBlocks, int Count) {
		LLVMAddIncoming(Pointer.getPeer(PhiNode), Pointer.getPeer(IncomingValues), Pointer.getPeer(IncomingBlocks), Count);
	}
	protected native static void LLVMAddIncoming(@Ptr long PhiNode, @Ptr long IncomingValues, @Ptr long IncomingBlocks, int Count);
	/**
	 * Obtain the number of incoming basic blocks to a PHI node.<br>
	 * Original signature : <code>int LLVMCountIncoming(LLVMValueRef)</code>
	 */
	public static int LLVMCountIncoming(LLVMLibrary.LLVMValueRef PhiNode) {
		return LLVMCountIncoming(Pointer.getPeer(PhiNode));
	}
	protected native static int LLVMCountIncoming(@Ptr long PhiNode);
	/**
	 * Obtain an incoming value to a PHI node as an LLVMValueRef.<br>
	 * Original signature : <code>LLVMValueRef LLVMGetIncomingValue(LLVMValueRef, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetIncomingValue(LLVMLibrary.LLVMValueRef PhiNode, int Index) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetIncomingValue(Pointer.getPeer(PhiNode), Index));
	}
	@Ptr 
	protected native static long LLVMGetIncomingValue(@Ptr long PhiNode, int Index);
	/**
	 * Obtain an incoming value to a PHI node as an LLVMBasicBlockRef.<br>
	 * Original signature : <code>LLVMBasicBlockRef LLVMGetIncomingBlock(LLVMValueRef, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMBasicBlockRef LLVMGetIncomingBlock(LLVMLibrary.LLVMValueRef PhiNode, int Index) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMGetIncomingBlock(Pointer.getPeer(PhiNode), Index));
	}
	@Ptr 
	protected native static long LLVMGetIncomingBlock(@Ptr long PhiNode, int Index);
	/**
	 * Obtain the number of indices.<br>
	 * NB: This also works on GEP.<br>
	 * Original signature : <code>int LLVMGetNumIndices(LLVMValueRef)</code>
	 */
	public static int LLVMGetNumIndices(LLVMLibrary.LLVMValueRef Inst) {
		return LLVMGetNumIndices(Pointer.getPeer(Inst));
	}
	protected native static int LLVMGetNumIndices(@Ptr long Inst);
	/**
	 * Obtain the indices as an array.<br>
	 * Original signature : <code>* LLVMGetIndices(LLVMValueRef)</code>
	 */
	public static Pointer<? > LLVMGetIndices(LLVMLibrary.LLVMValueRef Inst) {
		return Pointer.pointerToAddress(LLVMGetIndices(Pointer.getPeer(Inst)));
	}
	@Ptr 
	protected native static long LLVMGetIndices(@Ptr long Inst);
	/**
	 * @defgroup LLVMCCoreInstructionBuilder Instruction Builders<br>
	 * An instruction builder represents a point within a basic block and is<br>
	 * the exclusive means of building instructions using the C interface.<br>
	 * @{<br>
	 * Original signature : <code>LLVMBuilderRef LLVMCreateBuilderInContext(LLVMContextRef)</code>
	 */
	public static LLVMLibrary.LLVMBuilderRef LLVMCreateBuilderInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMBuilderRef(LLVMCreateBuilderInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMCreateBuilderInContext(@Ptr long C);
	/** Original signature : <code>LLVMBuilderRef LLVMCreateBuilder()</code> */
	public static LLVMLibrary.LLVMBuilderRef LLVMCreateBuilder() {
		return new LLVMLibrary.LLVMBuilderRef(LLVMCreateBuilder$2());
	}
	@Ptr 
	@Name("LLVMCreateBuilder") 
	protected native static long LLVMCreateBuilder$2();
	/** Original signature : <code>void LLVMPositionBuilder(LLVMBuilderRef, LLVMBasicBlockRef, LLVMValueRef)</code> */
	public static void LLVMPositionBuilder(LLVMLibrary.LLVMBuilderRef Builder, LLVMLibrary.LLVMBasicBlockRef Block, LLVMLibrary.LLVMValueRef Instr) {
		LLVMPositionBuilder(Pointer.getPeer(Builder), Pointer.getPeer(Block), Pointer.getPeer(Instr));
	}
	protected native static void LLVMPositionBuilder(@Ptr long Builder, @Ptr long Block, @Ptr long Instr);
	/** Original signature : <code>void LLVMPositionBuilderBefore(LLVMBuilderRef, LLVMValueRef)</code> */
	public static void LLVMPositionBuilderBefore(LLVMLibrary.LLVMBuilderRef Builder, LLVMLibrary.LLVMValueRef Instr) {
		LLVMPositionBuilderBefore(Pointer.getPeer(Builder), Pointer.getPeer(Instr));
	}
	protected native static void LLVMPositionBuilderBefore(@Ptr long Builder, @Ptr long Instr);
	/** Original signature : <code>void LLVMPositionBuilderAtEnd(LLVMBuilderRef, LLVMBasicBlockRef)</code> */
	public static void LLVMPositionBuilderAtEnd(LLVMLibrary.LLVMBuilderRef Builder, LLVMLibrary.LLVMBasicBlockRef Block) {
		LLVMPositionBuilderAtEnd(Pointer.getPeer(Builder), Pointer.getPeer(Block));
	}
	protected native static void LLVMPositionBuilderAtEnd(@Ptr long Builder, @Ptr long Block);
	/** Original signature : <code>LLVMBasicBlockRef LLVMGetInsertBlock(LLVMBuilderRef)</code> */
	public static LLVMLibrary.LLVMBasicBlockRef LLVMGetInsertBlock(LLVMLibrary.LLVMBuilderRef Builder) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMGetInsertBlock(Pointer.getPeer(Builder)));
	}
	@Ptr 
	protected native static long LLVMGetInsertBlock(@Ptr long Builder);
	/** Original signature : <code>void LLVMClearInsertionPosition(LLVMBuilderRef)</code> */
	public static void LLVMClearInsertionPosition(LLVMLibrary.LLVMBuilderRef Builder) {
		LLVMClearInsertionPosition(Pointer.getPeer(Builder));
	}
	protected native static void LLVMClearInsertionPosition(@Ptr long Builder);
	/** Original signature : <code>void LLVMInsertIntoBuilder(LLVMBuilderRef, LLVMValueRef)</code> */
	public static void LLVMInsertIntoBuilder(LLVMLibrary.LLVMBuilderRef Builder, LLVMLibrary.LLVMValueRef Instr) {
		LLVMInsertIntoBuilder(Pointer.getPeer(Builder), Pointer.getPeer(Instr));
	}
	protected native static void LLVMInsertIntoBuilder(@Ptr long Builder, @Ptr long Instr);
	/** Original signature : <code>void LLVMInsertIntoBuilderWithName(LLVMBuilderRef, LLVMValueRef, const char*)</code> */
	public static void LLVMInsertIntoBuilderWithName(LLVMLibrary.LLVMBuilderRef Builder, LLVMLibrary.LLVMValueRef Instr, Pointer<Byte > Name) {
		LLVMInsertIntoBuilderWithName(Pointer.getPeer(Builder), Pointer.getPeer(Instr), Pointer.getPeer(Name));
	}
	protected native static void LLVMInsertIntoBuilderWithName(@Ptr long Builder, @Ptr long Instr, @Ptr long Name);
	/** Original signature : <code>void LLVMDisposeBuilder(LLVMBuilderRef)</code> */
	public static void LLVMDisposeBuilder(LLVMLibrary.LLVMBuilderRef Builder) {
		LLVMDisposeBuilder(Pointer.getPeer(Builder));
	}
	protected native static void LLVMDisposeBuilder(@Ptr long Builder);
	/**
	 * Metadata<br>
	 * Original signature : <code>void LLVMSetCurrentDebugLocation(LLVMBuilderRef, LLVMValueRef)</code>
	 */
	public static void LLVMSetCurrentDebugLocation(LLVMLibrary.LLVMBuilderRef Builder, LLVMLibrary.LLVMValueRef L) {
		LLVMSetCurrentDebugLocation(Pointer.getPeer(Builder), Pointer.getPeer(L));
	}
	protected native static void LLVMSetCurrentDebugLocation(@Ptr long Builder, @Ptr long L);
	/** Original signature : <code>LLVMValueRef LLVMGetCurrentDebugLocation(LLVMBuilderRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMGetCurrentDebugLocation(LLVMLibrary.LLVMBuilderRef Builder) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetCurrentDebugLocation(Pointer.getPeer(Builder)));
	}
	@Ptr 
	protected native static long LLVMGetCurrentDebugLocation(@Ptr long Builder);
	/** Original signature : <code>void LLVMSetInstDebugLocation(LLVMBuilderRef, LLVMValueRef)</code> */
	public static void LLVMSetInstDebugLocation(LLVMLibrary.LLVMBuilderRef Builder, LLVMLibrary.LLVMValueRef Inst) {
		LLVMSetInstDebugLocation(Pointer.getPeer(Builder), Pointer.getPeer(Inst));
	}
	protected native static void LLVMSetInstDebugLocation(@Ptr long Builder, @Ptr long Inst);
	/**
	 * Terminators<br>
	 * Original signature : <code>LLVMValueRef LLVMBuildRetVoid()</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMBuildRetVoid() {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildRetVoid$2());
	}
	@Ptr 
	@Name("LLVMBuildRetVoid") 
	protected native static long LLVMBuildRetVoid$2();
	/** Original signature : <code>LLVMValueRef LLVMBuildRet(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildRet(LLVMLibrary.LLVMValueRef V) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildRet(Pointer.getPeer(V)));
	}
	@Ptr 
	protected native static long LLVMBuildRet(@Ptr long V);
	/** Original signature : <code>LLVMValueRef LLVMBuildAggregateRet(LLVMValueRef*, unsigned)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildAggregateRet(Pointer<LLVMLibrary.LLVMValueRef > RetVals, int N) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildAggregateRet(Pointer.getPeer(RetVals), N));
	}
	@Ptr 
	protected native static long LLVMBuildAggregateRet(@Ptr long RetVals, int N);
	/** Original signature : <code>LLVMValueRef LLVMBuildBr(LLVMBasicBlockRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildBr(LLVMLibrary.LLVMBasicBlockRef Dest) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildBr(Pointer.getPeer(Dest)));
	}
	@Ptr 
	protected native static long LLVMBuildBr(@Ptr long Dest);
	/** Original signature : <code>LLVMValueRef LLVMBuildCondBr(LLVMValueRef, LLVMBasicBlockRef, LLVMBasicBlockRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildCondBr(LLVMLibrary.LLVMValueRef If, LLVMLibrary.LLVMBasicBlockRef Then, LLVMLibrary.LLVMBasicBlockRef Else) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildCondBr(Pointer.getPeer(If), Pointer.getPeer(Then), Pointer.getPeer(Else)));
	}
	@Ptr 
	protected native static long LLVMBuildCondBr(@Ptr long If, @Ptr long Then, @Ptr long Else);
	/** Original signature : <code>LLVMValueRef LLVMBuildSwitch(LLVMValueRef, LLVMBasicBlockRef, unsigned)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildSwitch(LLVMLibrary.LLVMValueRef V, LLVMLibrary.LLVMBasicBlockRef Else, int NumCases) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildSwitch(Pointer.getPeer(V), Pointer.getPeer(Else), NumCases));
	}
	@Ptr 
	protected native static long LLVMBuildSwitch(@Ptr long V, @Ptr long Else, int NumCases);
	/** Original signature : <code>LLVMValueRef LLVMBuildIndirectBr(LLVMBuilderRef, LLVMValueRef, unsigned)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildIndirectBr(LLVMLibrary.LLVMBuilderRef B, LLVMLibrary.LLVMValueRef Addr, int NumDests) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildIndirectBr(Pointer.getPeer(B), Pointer.getPeer(Addr), NumDests));
	}
	@Ptr 
	protected native static long LLVMBuildIndirectBr(@Ptr long B, @Ptr long Addr, int NumDests);
	/** Original signature : <code>LLVMValueRef LLVMBuildInvoke(LLVMValueRef, LLVMValueRef*, unsigned, LLVMBasicBlockRef, LLVMBasicBlockRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildInvoke(LLVMLibrary.LLVMValueRef Fn, Pointer<LLVMLibrary.LLVMValueRef > Args, int NumArgs, LLVMLibrary.LLVMBasicBlockRef Then, LLVMLibrary.LLVMBasicBlockRef Catch, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildInvoke(Pointer.getPeer(Fn), Pointer.getPeer(Args), NumArgs, Pointer.getPeer(Then), Pointer.getPeer(Catch), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildInvoke(@Ptr long Fn, @Ptr long Args, int NumArgs, @Ptr long Then, @Ptr long Catch, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildLandingPad(LLVMBuilderRef, LLVMTypeRef, LLVMValueRef, unsigned, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildLandingPad(LLVMLibrary.LLVMBuilderRef B, LLVMLibrary.LLVMTypeRef Ty, LLVMLibrary.LLVMValueRef PersFn, int NumClauses, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildLandingPad(Pointer.getPeer(B), Pointer.getPeer(Ty), Pointer.getPeer(PersFn), NumClauses, Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildLandingPad(@Ptr long B, @Ptr long Ty, @Ptr long PersFn, int NumClauses, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildResume(LLVMBuilderRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildResume(LLVMLibrary.LLVMBuilderRef B, LLVMLibrary.LLVMValueRef Exn) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildResume(Pointer.getPeer(B), Pointer.getPeer(Exn)));
	}
	@Ptr 
	protected native static long LLVMBuildResume(@Ptr long B, @Ptr long Exn);
	/** Original signature : <code>LLVMValueRef LLVMBuildUnreachable()</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildUnreachable() {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildUnreachable$2());
	}
	@Ptr 
	@Name("LLVMBuildUnreachable") 
	protected native static long LLVMBuildUnreachable$2();
	/**
	 * Add a case to the switch instruction<br>
	 * Original signature : <code>void LLVMAddCase(LLVMValueRef, LLVMValueRef, LLVMBasicBlockRef)</code>
	 */
	public static void LLVMAddCase(LLVMLibrary.LLVMValueRef Switch, LLVMLibrary.LLVMValueRef OnVal, LLVMLibrary.LLVMBasicBlockRef Dest) {
		LLVMAddCase(Pointer.getPeer(Switch), Pointer.getPeer(OnVal), Pointer.getPeer(Dest));
	}
	protected native static void LLVMAddCase(@Ptr long Switch, @Ptr long OnVal, @Ptr long Dest);
	/**
	 * Add a destination to the indirectbr instruction<br>
	 * Original signature : <code>void LLVMAddDestination(LLVMValueRef, LLVMBasicBlockRef)</code>
	 */
	public static void LLVMAddDestination(LLVMLibrary.LLVMValueRef IndirectBr, LLVMLibrary.LLVMBasicBlockRef Dest) {
		LLVMAddDestination(Pointer.getPeer(IndirectBr), Pointer.getPeer(Dest));
	}
	protected native static void LLVMAddDestination(@Ptr long IndirectBr, @Ptr long Dest);
	/**
	 * Get the number of clauses on the landingpad instruction<br>
	 * Original signature : <code>int LLVMGetNumClauses(LLVMValueRef)</code>
	 */
	public static int LLVMGetNumClauses(LLVMLibrary.LLVMValueRef LandingPad) {
		return LLVMGetNumClauses(Pointer.getPeer(LandingPad));
	}
	protected native static int LLVMGetNumClauses(@Ptr long LandingPad);
	/**
	 * Get the value of the clause at idnex Idx on the landingpad instruction<br>
	 * Original signature : <code>LLVMValueRef LLVMGetClause(LLVMValueRef, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetClause(LLVMLibrary.LLVMValueRef LandingPad, int Idx) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetClause(Pointer.getPeer(LandingPad), Idx));
	}
	@Ptr 
	protected native static long LLVMGetClause(@Ptr long LandingPad, int Idx);
	/**
	 * Add a catch or filter clause to the landingpad instruction<br>
	 * Original signature : <code>void LLVMAddClause(LLVMValueRef, LLVMValueRef)</code>
	 */
	public static void LLVMAddClause(LLVMLibrary.LLVMValueRef LandingPad, LLVMLibrary.LLVMValueRef ClauseVal) {
		LLVMAddClause(Pointer.getPeer(LandingPad), Pointer.getPeer(ClauseVal));
	}
	protected native static void LLVMAddClause(@Ptr long LandingPad, @Ptr long ClauseVal);
	/**
	 * Get the 'cleanup' flag in the landingpad instruction<br>
	 * Original signature : <code>LLVMBool LLVMIsCleanup(LLVMValueRef)</code>
	 */
	public static int LLVMIsCleanup(LLVMLibrary.LLVMValueRef LandingPad) {
		return LLVMIsCleanup(Pointer.getPeer(LandingPad));
	}
	protected native static int LLVMIsCleanup(@Ptr long LandingPad);
	/**
	 * Set the 'cleanup' flag in the landingpad instruction<br>
	 * Original signature : <code>void LLVMSetCleanup(LLVMValueRef, LLVMBool)</code>
	 */
	public static void LLVMSetCleanup(LLVMLibrary.LLVMValueRef LandingPad, int Val) {
		LLVMSetCleanup(Pointer.getPeer(LandingPad), Val);
	}
	protected native static void LLVMSetCleanup(@Ptr long LandingPad, int Val);
	/**
	 * Arithmetic<br>
	 * Original signature : <code>LLVMValueRef LLVMBuildAdd(LLVMValueRef, LLVMValueRef, const char*)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMBuildAdd(LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildAdd(Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildAdd(@Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildNSWAdd(LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildNSWAdd(LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildNSWAdd(Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildNSWAdd(@Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildNUWAdd(LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildNUWAdd(LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildNUWAdd(Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildNUWAdd(@Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildFAdd(LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildFAdd(LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildFAdd(Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildFAdd(@Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildSub(LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildSub(LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildSub(Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildSub(@Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildNSWSub(LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildNSWSub(LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildNSWSub(Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildNSWSub(@Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildNUWSub(LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildNUWSub(LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildNUWSub(Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildNUWSub(@Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildFSub(LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildFSub(LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildFSub(Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildFSub(@Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildMul(LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildMul(LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildMul(Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildMul(@Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildNSWMul(LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildNSWMul(LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildNSWMul(Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildNSWMul(@Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildNUWMul(LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildNUWMul(LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildNUWMul(Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildNUWMul(@Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildFMul(LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildFMul(LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildFMul(Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildFMul(@Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildUDiv(LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildUDiv(LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildUDiv(Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildUDiv(@Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildSDiv(LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildSDiv(LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildSDiv(Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildSDiv(@Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildExactSDiv(LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildExactSDiv(LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildExactSDiv(Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildExactSDiv(@Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildFDiv(LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildFDiv(LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildFDiv(Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildFDiv(@Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildURem(LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildURem(LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildURem(Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildURem(@Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildSRem(LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildSRem(LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildSRem(Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildSRem(@Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildFRem(LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildFRem(LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildFRem(Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildFRem(@Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildShl(LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildShl(LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildShl(Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildShl(@Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildLShr(LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildLShr(LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildLShr(Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildLShr(@Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildAShr(LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildAShr(LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildAShr(Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildAShr(@Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildAnd(LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildAnd(LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildAnd(Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildAnd(@Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildOr(LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildOr(LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildOr(Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildOr(@Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildXor(LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildXor(LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildXor(Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildXor(@Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildBinOp(LLVMBuilderRef, LLVMOpcode, LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildBinOp(LLVMLibrary.LLVMBuilderRef B, IntValuedEnum<LLVMLibrary.LLVMOpcode > Op, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildBinOp(Pointer.getPeer(B), (int)Op.value(), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildBinOp(@Ptr long B, int Op, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildNeg(LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildNeg(LLVMLibrary.LLVMValueRef V, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildNeg(Pointer.getPeer(V), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildNeg(@Ptr long V, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildNSWNeg(LLVMBuilderRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildNSWNeg(LLVMLibrary.LLVMBuilderRef B, LLVMLibrary.LLVMValueRef V, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildNSWNeg(Pointer.getPeer(B), Pointer.getPeer(V), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildNSWNeg(@Ptr long B, @Ptr long V, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildNUWNeg(LLVMBuilderRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildNUWNeg(LLVMLibrary.LLVMBuilderRef B, LLVMLibrary.LLVMValueRef V, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildNUWNeg(Pointer.getPeer(B), Pointer.getPeer(V), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildNUWNeg(@Ptr long B, @Ptr long V, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildFNeg(LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildFNeg(LLVMLibrary.LLVMValueRef V, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildFNeg(Pointer.getPeer(V), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildFNeg(@Ptr long V, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildNot(LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildNot(LLVMLibrary.LLVMValueRef V, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildNot(Pointer.getPeer(V), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildNot(@Ptr long V, @Ptr long Name);
	/**
	 * Memory<br>
	 * Original signature : <code>LLVMValueRef LLVMBuildMalloc(LLVMTypeRef, const char*)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMBuildMalloc(LLVMLibrary.LLVMTypeRef Ty, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildMalloc(Pointer.getPeer(Ty), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildMalloc(@Ptr long Ty, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildArrayMalloc(LLVMTypeRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildArrayMalloc(LLVMLibrary.LLVMTypeRef Ty, LLVMLibrary.LLVMValueRef Val, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildArrayMalloc(Pointer.getPeer(Ty), Pointer.getPeer(Val), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildArrayMalloc(@Ptr long Ty, @Ptr long Val, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildAlloca(LLVMTypeRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildAlloca(LLVMLibrary.LLVMTypeRef Ty, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildAlloca(Pointer.getPeer(Ty), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildAlloca(@Ptr long Ty, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildArrayAlloca(LLVMTypeRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildArrayAlloca(LLVMLibrary.LLVMTypeRef Ty, LLVMLibrary.LLVMValueRef Val, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildArrayAlloca(Pointer.getPeer(Ty), Pointer.getPeer(Val), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildArrayAlloca(@Ptr long Ty, @Ptr long Val, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildFree(LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildFree(LLVMLibrary.LLVMValueRef PointerVal) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildFree(Pointer.getPeer(PointerVal)));
	}
	@Ptr 
	protected native static long LLVMBuildFree(@Ptr long PointerVal);
	/** Original signature : <code>LLVMValueRef LLVMBuildLoad(LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildLoad(LLVMLibrary.LLVMValueRef PointerVal, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildLoad(Pointer.getPeer(PointerVal), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildLoad(@Ptr long PointerVal, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildStore(LLVMValueRef, LLVMValueRef)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildStore(LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMValueRef Ptr) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildStore(Pointer.getPeer(Val), Pointer.getPeer(Ptr)));
	}
	@Ptr 
	protected native static long LLVMBuildStore(@Ptr long Val, @Ptr long Ptr);
	/** Original signature : <code>LLVMValueRef LLVMBuildGEP(LLVMBuilderRef, LLVMValueRef, LLVMValueRef*, unsigned, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildGEP(LLVMLibrary.LLVMBuilderRef B, LLVMLibrary.LLVMValueRef Pointer, Pointer<LLVMLibrary.LLVMValueRef > Indices, int NumIndices, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildGEP(Pointer.getPeer(B), Pointer.getPeer(Pointer), Pointer.getPeer(Indices), NumIndices, Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildGEP(@Ptr long B, @Ptr long Pointer, @Ptr long Indices, int NumIndices, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildInBoundsGEP(LLVMBuilderRef, LLVMValueRef, LLVMValueRef*, unsigned, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildInBoundsGEP(LLVMLibrary.LLVMBuilderRef B, LLVMLibrary.LLVMValueRef Pointer, Pointer<LLVMLibrary.LLVMValueRef > Indices, int NumIndices, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildInBoundsGEP(Pointer.getPeer(B), Pointer.getPeer(Pointer), Pointer.getPeer(Indices), NumIndices, Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildInBoundsGEP(@Ptr long B, @Ptr long Pointer, @Ptr long Indices, int NumIndices, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildStructGEP(LLVMBuilderRef, LLVMValueRef, unsigned, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildStructGEP(LLVMLibrary.LLVMBuilderRef B, LLVMLibrary.LLVMValueRef Pointer, int Idx, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildStructGEP(Pointer.getPeer(B), Pointer.getPeer(Pointer), Idx, Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildStructGEP(@Ptr long B, @Ptr long Pointer, int Idx, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildGlobalString(LLVMBuilderRef, const char*, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildGlobalString(LLVMLibrary.LLVMBuilderRef B, Pointer<Byte > Str, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildGlobalString(Pointer.getPeer(B), Pointer.getPeer(Str), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildGlobalString(@Ptr long B, @Ptr long Str, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildGlobalStringPtr(LLVMBuilderRef, const char*, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildGlobalStringPtr(LLVMLibrary.LLVMBuilderRef B, Pointer<Byte > Str, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildGlobalStringPtr(Pointer.getPeer(B), Pointer.getPeer(Str), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildGlobalStringPtr(@Ptr long B, @Ptr long Str, @Ptr long Name);
	/** Original signature : <code>LLVMBool LLVMGetVolatile(LLVMValueRef)</code> */
	public static int LLVMGetVolatile(LLVMLibrary.LLVMValueRef MemoryAccessInst) {
		return LLVMGetVolatile(Pointer.getPeer(MemoryAccessInst));
	}
	protected native static int LLVMGetVolatile(@Ptr long MemoryAccessInst);
	/** Original signature : <code>void LLVMSetVolatile(LLVMValueRef, LLVMBool)</code> */
	public static void LLVMSetVolatile(LLVMLibrary.LLVMValueRef MemoryAccessInst, int IsVolatile) {
		LLVMSetVolatile(Pointer.getPeer(MemoryAccessInst), IsVolatile);
	}
	protected native static void LLVMSetVolatile(@Ptr long MemoryAccessInst, int IsVolatile);
	/** Original signature : <code>LLVMAtomicOrdering LLVMGetOrdering(LLVMValueRef)</code> */
	public static IntValuedEnum<LLVMLibrary.LLVMAtomicOrdering > LLVMGetOrdering(LLVMLibrary.LLVMValueRef MemoryAccessInst) {
		return FlagSet.fromValue(LLVMGetOrdering(Pointer.getPeer(MemoryAccessInst)), LLVMLibrary.LLVMAtomicOrdering.class);
	}
	protected native static int LLVMGetOrdering(@Ptr long MemoryAccessInst);
	/** Original signature : <code>void LLVMSetOrdering(LLVMValueRef, LLVMAtomicOrdering)</code> */
	public static void LLVMSetOrdering(LLVMLibrary.LLVMValueRef MemoryAccessInst, IntValuedEnum<LLVMLibrary.LLVMAtomicOrdering > Ordering) {
		LLVMSetOrdering(Pointer.getPeer(MemoryAccessInst), (int)Ordering.value());
	}
	protected native static void LLVMSetOrdering(@Ptr long MemoryAccessInst, int Ordering);
	/**
	 * Casts<br>
	 * Original signature : <code>LLVMValueRef LLVMBuildTrunc(LLVMValueRef, LLVMTypeRef, const char*)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMBuildTrunc(LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildTrunc(Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildTrunc(@Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildZExt(LLVMValueRef, LLVMTypeRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildZExt(LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildZExt(Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildZExt(@Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildSExt(LLVMValueRef, LLVMTypeRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildSExt(LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildSExt(Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildSExt(@Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildFPToUI(LLVMValueRef, LLVMTypeRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildFPToUI(LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildFPToUI(Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildFPToUI(@Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildFPToSI(LLVMValueRef, LLVMTypeRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildFPToSI(LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildFPToSI(Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildFPToSI(@Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildUIToFP(LLVMValueRef, LLVMTypeRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildUIToFP(LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildUIToFP(Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildUIToFP(@Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildSIToFP(LLVMValueRef, LLVMTypeRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildSIToFP(LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildSIToFP(Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildSIToFP(@Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildFPTrunc(LLVMValueRef, LLVMTypeRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildFPTrunc(LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildFPTrunc(Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildFPTrunc(@Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildFPExt(LLVMValueRef, LLVMTypeRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildFPExt(LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildFPExt(Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildFPExt(@Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildPtrToInt(LLVMValueRef, LLVMTypeRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildPtrToInt(LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildPtrToInt(Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildPtrToInt(@Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildIntToPtr(LLVMValueRef, LLVMTypeRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildIntToPtr(LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildIntToPtr(Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildIntToPtr(@Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildBitCast(LLVMValueRef, LLVMTypeRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildBitCast(LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildBitCast(Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildBitCast(@Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildAddrSpaceCast(LLVMValueRef, LLVMTypeRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildAddrSpaceCast(LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildAddrSpaceCast(Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildAddrSpaceCast(@Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildZExtOrBitCast(LLVMValueRef, LLVMTypeRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildZExtOrBitCast(LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildZExtOrBitCast(Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildZExtOrBitCast(@Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildSExtOrBitCast(LLVMValueRef, LLVMTypeRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildSExtOrBitCast(LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildSExtOrBitCast(Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildSExtOrBitCast(@Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildTruncOrBitCast(LLVMValueRef, LLVMTypeRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildTruncOrBitCast(LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildTruncOrBitCast(Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildTruncOrBitCast(@Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildCast(LLVMBuilderRef, LLVMOpcode, LLVMValueRef, LLVMTypeRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildCast(LLVMLibrary.LLVMBuilderRef B, IntValuedEnum<LLVMLibrary.LLVMOpcode > Op, LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildCast(Pointer.getPeer(B), (int)Op.value(), Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildCast(@Ptr long B, int Op, @Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildPointerCast(LLVMValueRef, LLVMTypeRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildPointerCast(LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildPointerCast(Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildPointerCast(@Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/**
	 * Signed cast!<br>
	 * Original signature : <code>LLVMValueRef LLVMBuildIntCast(LLVMValueRef, LLVMTypeRef, const char*)</code><br>
	 * @param Val Signed cast!
	 */
	public static LLVMLibrary.LLVMValueRef LLVMBuildIntCast(LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildIntCast(Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildIntCast(@Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildFPCast(LLVMValueRef, LLVMTypeRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildFPCast(LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildFPCast(Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildFPCast(@Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/**
	 * Comparisons<br>
	 * Original signature : <code>LLVMValueRef LLVMBuildICmp(LLVMIntPredicate, LLVMValueRef, LLVMValueRef, const char*)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMBuildICmp(IntValuedEnum<LLVMLibrary.LLVMIntPredicate > Op, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildICmp((int)Op.value(), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildICmp(int Op, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildFCmp(LLVMRealPredicate, LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildFCmp(IntValuedEnum<LLVMLibrary.LLVMRealPredicate > Op, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildFCmp((int)Op.value(), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildFCmp(int Op, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/**
	 * Miscellaneous instructions<br>
	 * Original signature : <code>LLVMValueRef LLVMBuildPhi(LLVMTypeRef, const char*)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMBuildPhi(LLVMLibrary.LLVMTypeRef Ty, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildPhi(Pointer.getPeer(Ty), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildPhi(@Ptr long Ty, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildCall(LLVMValueRef, LLVMValueRef*, unsigned, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildCall(LLVMLibrary.LLVMValueRef Fn, Pointer<LLVMLibrary.LLVMValueRef > Args, int NumArgs, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildCall(Pointer.getPeer(Fn), Pointer.getPeer(Args), NumArgs, Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildCall(@Ptr long Fn, @Ptr long Args, int NumArgs, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildSelect(LLVMValueRef, LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildSelect(LLVMLibrary.LLVMValueRef If, LLVMLibrary.LLVMValueRef Then, LLVMLibrary.LLVMValueRef Else, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildSelect(Pointer.getPeer(If), Pointer.getPeer(Then), Pointer.getPeer(Else), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildSelect(@Ptr long If, @Ptr long Then, @Ptr long Else, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildVAArg(LLVMValueRef, LLVMTypeRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildVAArg(LLVMLibrary.LLVMValueRef List, LLVMLibrary.LLVMTypeRef Ty, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildVAArg(Pointer.getPeer(List), Pointer.getPeer(Ty), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildVAArg(@Ptr long List, @Ptr long Ty, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildExtractElement(LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildExtractElement(LLVMLibrary.LLVMValueRef VecVal, LLVMLibrary.LLVMValueRef Index, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildExtractElement(Pointer.getPeer(VecVal), Pointer.getPeer(Index), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildExtractElement(@Ptr long VecVal, @Ptr long Index, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildInsertElement(LLVMValueRef, LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildInsertElement(LLVMLibrary.LLVMValueRef VecVal, LLVMLibrary.LLVMValueRef EltVal, LLVMLibrary.LLVMValueRef Index, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildInsertElement(Pointer.getPeer(VecVal), Pointer.getPeer(EltVal), Pointer.getPeer(Index), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildInsertElement(@Ptr long VecVal, @Ptr long EltVal, @Ptr long Index, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildShuffleVector(LLVMValueRef, LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildShuffleVector(LLVMLibrary.LLVMValueRef V1, LLVMLibrary.LLVMValueRef V2, LLVMLibrary.LLVMValueRef Mask, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildShuffleVector(Pointer.getPeer(V1), Pointer.getPeer(V2), Pointer.getPeer(Mask), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildShuffleVector(@Ptr long V1, @Ptr long V2, @Ptr long Mask, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildExtractValue(LLVMValueRef, unsigned, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildExtractValue(LLVMLibrary.LLVMValueRef AggVal, int Index, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildExtractValue(Pointer.getPeer(AggVal), Index, Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildExtractValue(@Ptr long AggVal, int Index, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildInsertValue(LLVMValueRef, LLVMValueRef, unsigned, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildInsertValue(LLVMLibrary.LLVMValueRef AggVal, LLVMLibrary.LLVMValueRef EltVal, int Index, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildInsertValue(Pointer.getPeer(AggVal), Pointer.getPeer(EltVal), Index, Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildInsertValue(@Ptr long AggVal, @Ptr long EltVal, int Index, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildIsNull(LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildIsNull(LLVMLibrary.LLVMValueRef Val, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildIsNull(Pointer.getPeer(Val), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildIsNull(@Ptr long Val, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildIsNotNull(LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildIsNotNull(LLVMLibrary.LLVMValueRef Val, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildIsNotNull(Pointer.getPeer(Val), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildIsNotNull(@Ptr long Val, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildPtrDiff(LLVMValueRef, LLVMValueRef, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildPtrDiff(LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildPtrDiff(Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildPtrDiff(@Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildFence(LLVMBuilderRef, LLVMAtomicOrdering, LLVMBool, const char*)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildFence(LLVMLibrary.LLVMBuilderRef B, IntValuedEnum<LLVMLibrary.LLVMAtomicOrdering > ordering, int singleThread, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildFence(Pointer.getPeer(B), (int)ordering.value(), singleThread, Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildFence(@Ptr long B, int ordering, int singleThread, @Ptr long Name);
	/** Original signature : <code>LLVMValueRef LLVMBuildAtomicRMW(LLVMBuilderRef, LLVMAtomicRMWBinOp, LLVMValueRef, LLVMValueRef, LLVMAtomicOrdering, LLVMBool)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildAtomicRMW(LLVMLibrary.LLVMBuilderRef B, IntValuedEnum<LLVMLibrary.LLVMAtomicRMWBinOp > op, LLVMLibrary.LLVMValueRef PTR, LLVMLibrary.LLVMValueRef Val, IntValuedEnum<LLVMLibrary.LLVMAtomicOrdering > ordering, int singleThread) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildAtomicRMW(Pointer.getPeer(B), (int)op.value(), Pointer.getPeer(PTR), Pointer.getPeer(Val), (int)ordering.value(), singleThread));
	}
	@Ptr 
	protected native static long LLVMBuildAtomicRMW(@Ptr long B, int op, @Ptr long PTR, @Ptr long Val, int ordering, int singleThread);
	/** Original signature : <code>LLVMValueRef LLVMBuildAtomicCmpXchg(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, LLVMValueRef, LLVMAtomicOrdering, LLVMAtomicOrdering, LLVMBool)</code> */
	public static LLVMLibrary.LLVMValueRef LLVMBuildAtomicCmpXchg(LLVMLibrary.LLVMBuilderRef B, LLVMLibrary.LLVMValueRef Ptr, LLVMLibrary.LLVMValueRef Cmp, LLVMLibrary.LLVMValueRef New, IntValuedEnum<LLVMLibrary.LLVMAtomicOrdering > SuccessOrdering, IntValuedEnum<LLVMLibrary.LLVMAtomicOrdering > FailureOrdering, int SingleThread) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildAtomicCmpXchg(Pointer.getPeer(B), Pointer.getPeer(Ptr), Pointer.getPeer(Cmp), Pointer.getPeer(New), (int)SuccessOrdering.value(), (int)FailureOrdering.value(), SingleThread));
	}
	@Ptr 
	protected native static long LLVMBuildAtomicCmpXchg(@Ptr long B, @Ptr long Ptr, @Ptr long Cmp, @Ptr long New, int SuccessOrdering, int FailureOrdering, int SingleThread);
	/** Original signature : <code>LLVMBool LLVMIsAtomicSingleThread(LLVMValueRef)</code> */
	public static int LLVMIsAtomicSingleThread(LLVMLibrary.LLVMValueRef AtomicInst) {
		return LLVMIsAtomicSingleThread(Pointer.getPeer(AtomicInst));
	}
	protected native static int LLVMIsAtomicSingleThread(@Ptr long AtomicInst);
	/** Original signature : <code>void LLVMSetAtomicSingleThread(LLVMValueRef, LLVMBool)</code> */
	public static void LLVMSetAtomicSingleThread(LLVMLibrary.LLVMValueRef AtomicInst, int SingleThread) {
		LLVMSetAtomicSingleThread(Pointer.getPeer(AtomicInst), SingleThread);
	}
	protected native static void LLVMSetAtomicSingleThread(@Ptr long AtomicInst, int SingleThread);
	/** Original signature : <code>LLVMAtomicOrdering LLVMGetCmpXchgSuccessOrdering(LLVMValueRef)</code> */
	public static IntValuedEnum<LLVMLibrary.LLVMAtomicOrdering > LLVMGetCmpXchgSuccessOrdering(LLVMLibrary.LLVMValueRef CmpXchgInst) {
		return FlagSet.fromValue(LLVMGetCmpXchgSuccessOrdering(Pointer.getPeer(CmpXchgInst)), LLVMLibrary.LLVMAtomicOrdering.class);
	}
	protected native static int LLVMGetCmpXchgSuccessOrdering(@Ptr long CmpXchgInst);
	/** Original signature : <code>void LLVMSetCmpXchgSuccessOrdering(LLVMValueRef, LLVMAtomicOrdering)</code> */
	public static void LLVMSetCmpXchgSuccessOrdering(LLVMLibrary.LLVMValueRef CmpXchgInst, IntValuedEnum<LLVMLibrary.LLVMAtomicOrdering > Ordering) {
		LLVMSetCmpXchgSuccessOrdering(Pointer.getPeer(CmpXchgInst), (int)Ordering.value());
	}
	protected native static void LLVMSetCmpXchgSuccessOrdering(@Ptr long CmpXchgInst, int Ordering);
	/** Original signature : <code>LLVMAtomicOrdering LLVMGetCmpXchgFailureOrdering(LLVMValueRef)</code> */
	public static IntValuedEnum<LLVMLibrary.LLVMAtomicOrdering > LLVMGetCmpXchgFailureOrdering(LLVMLibrary.LLVMValueRef CmpXchgInst) {
		return FlagSet.fromValue(LLVMGetCmpXchgFailureOrdering(Pointer.getPeer(CmpXchgInst)), LLVMLibrary.LLVMAtomicOrdering.class);
	}
	protected native static int LLVMGetCmpXchgFailureOrdering(@Ptr long CmpXchgInst);
	/** Original signature : <code>void LLVMSetCmpXchgFailureOrdering(LLVMValueRef, LLVMAtomicOrdering)</code> */
	public static void LLVMSetCmpXchgFailureOrdering(LLVMLibrary.LLVMValueRef CmpXchgInst, IntValuedEnum<LLVMLibrary.LLVMAtomicOrdering > Ordering) {
		LLVMSetCmpXchgFailureOrdering(Pointer.getPeer(CmpXchgInst), (int)Ordering.value());
	}
	protected native static void LLVMSetCmpXchgFailureOrdering(@Ptr long CmpXchgInst, int Ordering);
	/**
	 * Changes the type of M so it can be passed to FunctionPassManagers and the<br>
	 * JIT.  They take ModuleProviders for historical reasons.<br>
	 * Original signature : <code>LLVMModuleProviderRef LLVMCreateModuleProviderForExistingModule(LLVMModuleRef)</code>
	 */
	public static LLVMLibrary.LLVMModuleProviderRef LLVMCreateModuleProviderForExistingModule(LLVMLibrary.LLVMModuleRef M) {
		return new LLVMLibrary.LLVMModuleProviderRef(LLVMCreateModuleProviderForExistingModule(Pointer.getPeer(M)));
	}
	@Ptr 
	protected native static long LLVMCreateModuleProviderForExistingModule(@Ptr long M);
	/**
	 * Destroys the module M.<br>
	 * Original signature : <code>void LLVMDisposeModuleProvider(LLVMModuleProviderRef)</code>
	 */
	public static void LLVMDisposeModuleProvider(LLVMLibrary.LLVMModuleProviderRef M) {
		LLVMDisposeModuleProvider(Pointer.getPeer(M));
	}
	protected native static void LLVMDisposeModuleProvider(@Ptr long M);
	/**
	 * @defgroup LLVMCCoreMemoryBuffers Memory Buffers<br>
	 * @{<br>
	 * Original signature : <code>LLVMBool LLVMCreateMemoryBufferWithContentsOfFile(const char*, LLVMMemoryBufferRef*, char**)</code>
	 */
	public static int LLVMCreateMemoryBufferWithContentsOfFile(Pointer<Byte > Path, Pointer<LLVMLibrary.LLVMMemoryBufferRef > OutMemBuf, Pointer<Pointer<Byte > > OutMessage) {
		return LLVMCreateMemoryBufferWithContentsOfFile(Pointer.getPeer(Path), Pointer.getPeer(OutMemBuf), Pointer.getPeer(OutMessage));
	}
	protected native static int LLVMCreateMemoryBufferWithContentsOfFile(@Ptr long Path, @Ptr long OutMemBuf, @Ptr long OutMessage);
	/** Original signature : <code>LLVMBool LLVMCreateMemoryBufferWithSTDIN(LLVMMemoryBufferRef*, char**)</code> */
	public static int LLVMCreateMemoryBufferWithSTDIN(Pointer<LLVMLibrary.LLVMMemoryBufferRef > OutMemBuf, Pointer<Pointer<Byte > > OutMessage) {
		return LLVMCreateMemoryBufferWithSTDIN(Pointer.getPeer(OutMemBuf), Pointer.getPeer(OutMessage));
	}
	protected native static int LLVMCreateMemoryBufferWithSTDIN(@Ptr long OutMemBuf, @Ptr long OutMessage);
	/** Original signature : <code>LLVMMemoryBufferRef LLVMCreateMemoryBufferWithMemoryRange(const char*, size_t, const char*, LLVMBool)</code> */
	public static LLVMLibrary.LLVMMemoryBufferRef LLVMCreateMemoryBufferWithMemoryRange(Pointer<Byte > InputData, @Ptr long InputDataLength, Pointer<Byte > BufferName, int RequiresNullTerminator) {
		return new LLVMLibrary.LLVMMemoryBufferRef(LLVMCreateMemoryBufferWithMemoryRange(Pointer.getPeer(InputData), InputDataLength, Pointer.getPeer(BufferName), RequiresNullTerminator));
	}
	@Ptr 
	protected native static long LLVMCreateMemoryBufferWithMemoryRange(@Ptr long InputData, @Ptr long InputDataLength, @Ptr long BufferName, int RequiresNullTerminator);
	/** Original signature : <code>LLVMMemoryBufferRef LLVMCreateMemoryBufferWithMemoryRangeCopy(const char*, size_t, const char*)</code> */
	public static LLVMLibrary.LLVMMemoryBufferRef LLVMCreateMemoryBufferWithMemoryRangeCopy(Pointer<Byte > InputData, @Ptr long InputDataLength, Pointer<Byte > BufferName) {
		return new LLVMLibrary.LLVMMemoryBufferRef(LLVMCreateMemoryBufferWithMemoryRangeCopy(Pointer.getPeer(InputData), InputDataLength, Pointer.getPeer(BufferName)));
	}
	@Ptr 
	protected native static long LLVMCreateMemoryBufferWithMemoryRangeCopy(@Ptr long InputData, @Ptr long InputDataLength, @Ptr long BufferName);
	/** Original signature : <code>char* LLVMGetBufferStart(LLVMMemoryBufferRef)</code> */
	public static Pointer<Byte > LLVMGetBufferStart(LLVMLibrary.LLVMMemoryBufferRef MemBuf) {
		return (Pointer)Pointer.pointerToAddress(LLVMGetBufferStart(Pointer.getPeer(MemBuf)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetBufferStart(@Ptr long MemBuf);
	/** Original signature : <code>size_t LLVMGetBufferSize(LLVMMemoryBufferRef)</code> */
	@Ptr 
	public static long LLVMGetBufferSize(LLVMLibrary.LLVMMemoryBufferRef MemBuf) {
		return LLVMGetBufferSize(Pointer.getPeer(MemBuf));
	}
	@Ptr 
	protected native static long LLVMGetBufferSize(@Ptr long MemBuf);
	/** Original signature : <code>void LLVMDisposeMemoryBuffer(LLVMMemoryBufferRef)</code> */
	public static void LLVMDisposeMemoryBuffer(LLVMLibrary.LLVMMemoryBufferRef MemBuf) {
		LLVMDisposeMemoryBuffer(Pointer.getPeer(MemBuf));
	}
	protected native static void LLVMDisposeMemoryBuffer(@Ptr long MemBuf);
	/**
	 * Return the global pass registry, for use with initialization functions.<br>
	 * @see llvm::PassRegistry::getPassRegistry<br>
	 * Original signature : <code>LLVMPassRegistryRef LLVMGetGlobalPassRegistry()</code>
	 */
	public static LLVMLibrary.LLVMPassRegistryRef LLVMGetGlobalPassRegistry() {
		return new LLVMLibrary.LLVMPassRegistryRef(LLVMGetGlobalPassRegistry$2());
	}
	@Ptr 
	@Name("LLVMGetGlobalPassRegistry") 
	protected native static long LLVMGetGlobalPassRegistry$2();
	/**
	 * Constructs a new whole-module pass pipeline. This type of pipeline is<br>
	 * suitable for link-time optimization and whole-module transformations.<br>
	 * @see llvm::PassManager::PassManager<br>
	 * Original signature : <code>LLVMPassManagerRef LLVMCreatePassManager()</code>
	 */
	public static LLVMLibrary.LLVMPassManagerRef LLVMCreatePassManager() {
		return new LLVMLibrary.LLVMPassManagerRef(LLVMCreatePassManager$2());
	}
	@Ptr 
	@Name("LLVMCreatePassManager") 
	protected native static long LLVMCreatePassManager$2();
	/**
	 * Constructs a new function-by-function pass pipeline over the module<br>
	 * provider. It does not take ownership of the module provider. This type of<br>
	 * pipeline is suitable for code generation and JIT compilation tasks.<br>
	 * @see llvm::FunctionPassManager::FunctionPassManager<br>
	 * Original signature : <code>LLVMPassManagerRef LLVMCreateFunctionPassManagerForModule(LLVMModuleRef)</code>
	 */
	public static LLVMLibrary.LLVMPassManagerRef LLVMCreateFunctionPassManagerForModule(LLVMLibrary.LLVMModuleRef M) {
		return new LLVMLibrary.LLVMPassManagerRef(LLVMCreateFunctionPassManagerForModule(Pointer.getPeer(M)));
	}
	@Ptr 
	protected native static long LLVMCreateFunctionPassManagerForModule(@Ptr long M);
	/**
	 * Deprecated: Use LLVMCreateFunctionPassManagerForModule instead.<br>
	 * Original signature : <code>LLVMPassManagerRef LLVMCreateFunctionPassManager(LLVMModuleProviderRef)</code>
	 */
	public static LLVMLibrary.LLVMPassManagerRef LLVMCreateFunctionPassManager(LLVMLibrary.LLVMModuleProviderRef MP) {
		return new LLVMLibrary.LLVMPassManagerRef(LLVMCreateFunctionPassManager(Pointer.getPeer(MP)));
	}
	@Ptr 
	protected native static long LLVMCreateFunctionPassManager(@Ptr long MP);
	/**
	 * Initializes, executes on the provided module, and finalizes all of the<br>
	 * passes scheduled in the pass manager. Returns 1 if any of the passes<br>
	 * modified the module, 0 otherwise.<br>
	 * @see llvm::PassManager::run(Module&)<br>
	 * Original signature : <code>LLVMBool LLVMRunPassManager(LLVMPassManagerRef, LLVMModuleRef)</code>
	 */
	public static int LLVMRunPassManager(LLVMLibrary.LLVMPassManagerRef PM, LLVMLibrary.LLVMModuleRef M) {
		return LLVMRunPassManager(Pointer.getPeer(PM), Pointer.getPeer(M));
	}
	protected native static int LLVMRunPassManager(@Ptr long PM, @Ptr long M);
	/**
	 * Initializes all of the function passes scheduled in the function pass<br>
	 * manager. Returns 1 if any of the passes modified the module, 0 otherwise.<br>
	 * @see llvm::FunctionPassManager::doInitialization<br>
	 * Original signature : <code>LLVMBool LLVMInitializeFunctionPassManager(LLVMPassManagerRef)</code>
	 */
	public static int LLVMInitializeFunctionPassManager(LLVMLibrary.LLVMPassManagerRef FPM) {
		return LLVMInitializeFunctionPassManager(Pointer.getPeer(FPM));
	}
	protected native static int LLVMInitializeFunctionPassManager(@Ptr long FPM);
	/**
	 * Executes all of the function passes scheduled in the function pass manager<br>
	 * on the provided function. Returns 1 if any of the passes modified the<br>
	 * function, false otherwise.<br>
	 * @see llvm::FunctionPassManager::run(Function&)<br>
	 * Original signature : <code>LLVMBool LLVMRunFunctionPassManager(LLVMPassManagerRef, LLVMValueRef)</code>
	 */
	public static int LLVMRunFunctionPassManager(LLVMLibrary.LLVMPassManagerRef FPM, LLVMLibrary.LLVMValueRef F) {
		return LLVMRunFunctionPassManager(Pointer.getPeer(FPM), Pointer.getPeer(F));
	}
	protected native static int LLVMRunFunctionPassManager(@Ptr long FPM, @Ptr long F);
	/**
	 * Finalizes all of the function passes scheduled in in the function pass<br>
	 * manager. Returns 1 if any of the passes modified the module, 0 otherwise.<br>
	 * @see llvm::FunctionPassManager::doFinalization<br>
	 * Original signature : <code>LLVMBool LLVMFinalizeFunctionPassManager(LLVMPassManagerRef)</code>
	 */
	public static int LLVMFinalizeFunctionPassManager(LLVMLibrary.LLVMPassManagerRef FPM) {
		return LLVMFinalizeFunctionPassManager(Pointer.getPeer(FPM));
	}
	protected native static int LLVMFinalizeFunctionPassManager(@Ptr long FPM);
	/**
	 * Frees the memory of a pass pipeline. For function pipelines, does not free<br>
	 * the module provider.<br>
	 * @see llvm::PassManagerBase::~PassManagerBase.<br>
	 * Original signature : <code>void LLVMDisposePassManager(LLVMPassManagerRef)</code>
	 */
	public static void LLVMDisposePassManager(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMDisposePassManager(Pointer.getPeer(PM));
	}
	protected native static void LLVMDisposePassManager(@Ptr long PM);
	/**
	 * Deprecated: Multi-threading can only be enabled/disabled with the compile<br>
	 * time define LLVM_ENABLE_THREADS.  This function always returns<br>
	 * LLVMIsMultithreaded().<br>
	 * Original signature : <code>LLVMBool LLVMStartMultithreaded()</code>
	 */
	public static native int LLVMStartMultithreaded();
	/**
	 * Deprecated: Multi-threading can only be enabled/disabled with the compile<br>
	 * time define LLVM_ENABLE_THREADS.<br>
	 * Original signature : <code>void LLVMStopMultithreaded()</code>
	 */
	public static native void LLVMStopMultithreaded();
	/**
	 * Check whether LLVM is executing in thread-safe mode or not.<br>
	 * @see llvm::llvm_is_multithreaded<br>
	 * Original signature : <code>LLVMBool LLVMIsMultithreaded()</code>
	 */
	public static native int LLVMIsMultithreaded();
	/**
	 * Verifies that a module is valid, taking the specified action if not.<br>
	 * Optionally returns a human-readable description of any invalid constructs.<br>
	 * OutMessage must be disposed with LLVMDisposeMessage.<br>
	 * Original signature : <code>LLVMBool LLVMVerifyModule(LLVMModuleRef, LLVMVerifierFailureAction, char**)</code>
	 */
	public static int LLVMVerifyModule(LLVMLibrary.LLVMModuleRef M, IntValuedEnum<LLVMLibrary.LLVMVerifierFailureAction > Action, Pointer<Pointer<Byte > > OutMessage) {
		return LLVMVerifyModule(Pointer.getPeer(M), (int)Action.value(), Pointer.getPeer(OutMessage));
	}
	protected native static int LLVMVerifyModule(@Ptr long M, int Action, @Ptr long OutMessage);
	/**
	 * Verifies that a single function is valid, taking the specified action. Useful<br>
	 * for debugging.<br>
	 * Original signature : <code>LLVMBool LLVMVerifyFunction(LLVMValueRef, LLVMVerifierFailureAction)</code>
	 */
	public static int LLVMVerifyFunction(LLVMLibrary.LLVMValueRef Fn, IntValuedEnum<LLVMLibrary.LLVMVerifierFailureAction > Action) {
		return LLVMVerifyFunction(Pointer.getPeer(Fn), (int)Action.value());
	}
	protected native static int LLVMVerifyFunction(@Ptr long Fn, int Action);
	/**
	 * Open up a ghostview window that displays the CFG of the current function.<br>
	 * Useful for debugging.<br>
	 * Original signature : <code>void LLVMViewFunctionCFG(LLVMValueRef)</code>
	 */
	public static void LLVMViewFunctionCFG(LLVMLibrary.LLVMValueRef Fn) {
		LLVMViewFunctionCFG(Pointer.getPeer(Fn));
	}
	protected native static void LLVMViewFunctionCFG(@Ptr long Fn);
	/** Original signature : <code>void LLVMViewFunctionCFGOnly(LLVMValueRef)</code> */
	public static void LLVMViewFunctionCFGOnly(LLVMLibrary.LLVMValueRef Fn) {
		LLVMViewFunctionCFGOnly(Pointer.getPeer(Fn));
	}
	protected native static void LLVMViewFunctionCFGOnly(@Ptr long Fn);
	/**
	 * Writes a module to the specified path. Returns 0 on success.<br>
	 * Original signature : <code>int LLVMWriteBitcodeToFile(LLVMModuleRef, const char*)</code>
	 */
	public static int LLVMWriteBitcodeToFile(LLVMLibrary.LLVMModuleRef M, Pointer<Byte > Path) {
		return LLVMWriteBitcodeToFile(Pointer.getPeer(M), Pointer.getPeer(Path));
	}
	protected native static int LLVMWriteBitcodeToFile(@Ptr long M, @Ptr long Path);
	/**
	 * Writes a module to an open file descriptor. Returns 0 on success.<br>
	 * Original signature : <code>int LLVMWriteBitcodeToFD(LLVMModuleRef, int, int, int)</code>
	 */
	public static int LLVMWriteBitcodeToFD(LLVMLibrary.LLVMModuleRef M, int FD, int ShouldClose, int Unbuffered) {
		return LLVMWriteBitcodeToFD(Pointer.getPeer(M), FD, ShouldClose, Unbuffered);
	}
	protected native static int LLVMWriteBitcodeToFD(@Ptr long M, int FD, int ShouldClose, int Unbuffered);
	/**
	 * Deprecated for LLVMWriteBitcodeToFD. Writes a module to an open file<br>
	 * descriptor. Returns 0 on success. Closes the Handle.<br>
	 * Original signature : <code>int LLVMWriteBitcodeToFileHandle(LLVMModuleRef, int)</code>
	 */
	public static int LLVMWriteBitcodeToFileHandle(LLVMLibrary.LLVMModuleRef M, int Handle) {
		return LLVMWriteBitcodeToFileHandle(Pointer.getPeer(M), Handle);
	}
	protected native static int LLVMWriteBitcodeToFileHandle(@Ptr long M, int Handle);
	/**
	 * Writes a module to a new memory buffer and returns it.<br>
	 * Original signature : <code>LLVMMemoryBufferRef LLVMWriteBitcodeToMemoryBuffer(LLVMModuleRef)</code>
	 */
	public static LLVMLibrary.LLVMMemoryBufferRef LLVMWriteBitcodeToMemoryBuffer(LLVMLibrary.LLVMModuleRef M) {
		return new LLVMLibrary.LLVMMemoryBufferRef(LLVMWriteBitcodeToMemoryBuffer(Pointer.getPeer(M)));
	}
	@Ptr 
	protected native static long LLVMWriteBitcodeToMemoryBuffer(@Ptr long M);
	/**
	 * @defgroup LLVMCInitialization Initialization Routines<br>
	 * @ingroup LLVMC<br>
	 * This module contains routines used to initialize the LLVM system.<br>
	 * @{<br>
	 * Original signature : <code>void LLVMInitializeCore(LLVMPassRegistryRef)</code>
	 */
	public static void LLVMInitializeCore$2(LLVMLibrary.LLVMPassRegistryRef R) {
		LLVMInitializeCore$2(Pointer.getPeer(R));
	}
	protected native static void LLVMInitializeCore$2(@Ptr long R);
	/** Original signature : <code>void LLVMInitializeTransformUtils(LLVMPassRegistryRef)</code> */
	public static void LLVMInitializeTransformUtils(LLVMLibrary.LLVMPassRegistryRef R) {
		LLVMInitializeTransformUtils(Pointer.getPeer(R));
	}
	protected native static void LLVMInitializeTransformUtils(@Ptr long R);
	/** Original signature : <code>void LLVMInitializeScalarOpts(LLVMPassRegistryRef)</code> */
	public static void LLVMInitializeScalarOpts(LLVMLibrary.LLVMPassRegistryRef R) {
		LLVMInitializeScalarOpts(Pointer.getPeer(R));
	}
	protected native static void LLVMInitializeScalarOpts(@Ptr long R);
	/** Original signature : <code>void LLVMInitializeObjCARCOpts(LLVMPassRegistryRef)</code> */
	public static void LLVMInitializeObjCARCOpts(LLVMLibrary.LLVMPassRegistryRef R) {
		LLVMInitializeObjCARCOpts(Pointer.getPeer(R));
	}
	protected native static void LLVMInitializeObjCARCOpts(@Ptr long R);
	/** Original signature : <code>void LLVMInitializeVectorization(LLVMPassRegistryRef)</code> */
	public static void LLVMInitializeVectorization(LLVMLibrary.LLVMPassRegistryRef R) {
		LLVMInitializeVectorization(Pointer.getPeer(R));
	}
	protected native static void LLVMInitializeVectorization(@Ptr long R);
	/** Original signature : <code>void LLVMInitializeInstCombine(LLVMPassRegistryRef)</code> */
	public static void LLVMInitializeInstCombine(LLVMLibrary.LLVMPassRegistryRef R) {
		LLVMInitializeInstCombine(Pointer.getPeer(R));
	}
	protected native static void LLVMInitializeInstCombine(@Ptr long R);
	/** Original signature : <code>void LLVMInitializeIPO(LLVMPassRegistryRef)</code> */
	public static void LLVMInitializeIPO(LLVMLibrary.LLVMPassRegistryRef R) {
		LLVMInitializeIPO(Pointer.getPeer(R));
	}
	protected native static void LLVMInitializeIPO(@Ptr long R);
	/** Original signature : <code>void LLVMInitializeInstrumentation(LLVMPassRegistryRef)</code> */
	public static void LLVMInitializeInstrumentation(LLVMLibrary.LLVMPassRegistryRef R) {
		LLVMInitializeInstrumentation(Pointer.getPeer(R));
	}
	protected native static void LLVMInitializeInstrumentation(@Ptr long R);
	/** Original signature : <code>void LLVMInitializeAnalysis(LLVMPassRegistryRef)</code> */
	public static void LLVMInitializeAnalysis(LLVMLibrary.LLVMPassRegistryRef R) {
		LLVMInitializeAnalysis(Pointer.getPeer(R));
	}
	protected native static void LLVMInitializeAnalysis(@Ptr long R);
	/** Original signature : <code>void LLVMInitializeIPA(LLVMPassRegistryRef)</code> */
	public static void LLVMInitializeIPA(LLVMLibrary.LLVMPassRegistryRef R) {
		LLVMInitializeIPA(Pointer.getPeer(R));
	}
	protected native static void LLVMInitializeIPA(@Ptr long R);
	/** Original signature : <code>void LLVMInitializeCodeGen(LLVMPassRegistryRef)</code> */
	public static void LLVMInitializeCodeGen(LLVMLibrary.LLVMPassRegistryRef R) {
		LLVMInitializeCodeGen(Pointer.getPeer(R));
	}
	protected native static void LLVMInitializeCodeGen(@Ptr long R);
	/** Original signature : <code>void LLVMInitializeTarget(LLVMPassRegistryRef)</code> */
	public static void LLVMInitializeTarget(LLVMLibrary.LLVMPassRegistryRef R) {
		LLVMInitializeTarget(Pointer.getPeer(R));
	}
	protected native static void LLVMInitializeTarget(@Ptr long R);
	/**
	 * ObjectFile creation<br>
	 * Original signature : <code>LLVMObjectFileRef LLVMCreateObjectFile(LLVMMemoryBufferRef)</code>
	 */
	public static LLVMLibrary.LLVMObjectFileRef LLVMCreateObjectFile(LLVMLibrary.LLVMMemoryBufferRef MemBuf) {
		return new LLVMLibrary.LLVMObjectFileRef(LLVMCreateObjectFile(Pointer.getPeer(MemBuf)));
	}
	@Ptr 
	protected native static long LLVMCreateObjectFile(@Ptr long MemBuf);
	/** Original signature : <code>void LLVMDisposeObjectFile(LLVMObjectFileRef)</code> */
	public static void LLVMDisposeObjectFile(LLVMLibrary.LLVMObjectFileRef ObjectFile) {
		LLVMDisposeObjectFile(Pointer.getPeer(ObjectFile));
	}
	protected native static void LLVMDisposeObjectFile(@Ptr long ObjectFile);
	/**
	 * ObjectFile Section iterators<br>
	 * Original signature : <code>LLVMSectionIteratorRef LLVMGetSections(LLVMObjectFileRef)</code>
	 */
	public static LLVMLibrary.LLVMSectionIteratorRef LLVMGetSections(LLVMLibrary.LLVMObjectFileRef ObjectFile) {
		return new LLVMLibrary.LLVMSectionIteratorRef(LLVMGetSections(Pointer.getPeer(ObjectFile)));
	}
	@Ptr 
	protected native static long LLVMGetSections(@Ptr long ObjectFile);
	/** Original signature : <code>void LLVMDisposeSectionIterator(LLVMSectionIteratorRef)</code> */
	public static void LLVMDisposeSectionIterator(LLVMLibrary.LLVMSectionIteratorRef SI) {
		LLVMDisposeSectionIterator(Pointer.getPeer(SI));
	}
	protected native static void LLVMDisposeSectionIterator(@Ptr long SI);
	/** Original signature : <code>LLVMBool LLVMIsSectionIteratorAtEnd(LLVMObjectFileRef, LLVMSectionIteratorRef)</code> */
	public static int LLVMIsSectionIteratorAtEnd(LLVMLibrary.LLVMObjectFileRef ObjectFile, LLVMLibrary.LLVMSectionIteratorRef SI) {
		return LLVMIsSectionIteratorAtEnd(Pointer.getPeer(ObjectFile), Pointer.getPeer(SI));
	}
	protected native static int LLVMIsSectionIteratorAtEnd(@Ptr long ObjectFile, @Ptr long SI);
	/** Original signature : <code>void LLVMMoveToNextSection(LLVMSectionIteratorRef)</code> */
	public static void LLVMMoveToNextSection(LLVMLibrary.LLVMSectionIteratorRef SI) {
		LLVMMoveToNextSection(Pointer.getPeer(SI));
	}
	protected native static void LLVMMoveToNextSection(@Ptr long SI);
	/** Original signature : <code>void LLVMMoveToContainingSection(LLVMSectionIteratorRef, LLVMSymbolIteratorRef)</code> */
	public static void LLVMMoveToContainingSection(LLVMLibrary.LLVMSectionIteratorRef Sect, LLVMLibrary.LLVMSymbolIteratorRef Sym) {
		LLVMMoveToContainingSection(Pointer.getPeer(Sect), Pointer.getPeer(Sym));
	}
	protected native static void LLVMMoveToContainingSection(@Ptr long Sect, @Ptr long Sym);
	/**
	 * ObjectFile Symbol iterators<br>
	 * Original signature : <code>LLVMSymbolIteratorRef LLVMGetSymbols(LLVMObjectFileRef)</code>
	 */
	public static LLVMLibrary.LLVMSymbolIteratorRef LLVMGetSymbols(LLVMLibrary.LLVMObjectFileRef ObjectFile) {
		return new LLVMLibrary.LLVMSymbolIteratorRef(LLVMGetSymbols(Pointer.getPeer(ObjectFile)));
	}
	@Ptr 
	protected native static long LLVMGetSymbols(@Ptr long ObjectFile);
	/** Original signature : <code>void LLVMDisposeSymbolIterator(LLVMSymbolIteratorRef)</code> */
	public static void LLVMDisposeSymbolIterator(LLVMLibrary.LLVMSymbolIteratorRef SI) {
		LLVMDisposeSymbolIterator(Pointer.getPeer(SI));
	}
	protected native static void LLVMDisposeSymbolIterator(@Ptr long SI);
	/** Original signature : <code>LLVMBool LLVMIsSymbolIteratorAtEnd(LLVMObjectFileRef, LLVMSymbolIteratorRef)</code> */
	public static int LLVMIsSymbolIteratorAtEnd(LLVMLibrary.LLVMObjectFileRef ObjectFile, LLVMLibrary.LLVMSymbolIteratorRef SI) {
		return LLVMIsSymbolIteratorAtEnd(Pointer.getPeer(ObjectFile), Pointer.getPeer(SI));
	}
	protected native static int LLVMIsSymbolIteratorAtEnd(@Ptr long ObjectFile, @Ptr long SI);
	/** Original signature : <code>void LLVMMoveToNextSymbol(LLVMSymbolIteratorRef)</code> */
	public static void LLVMMoveToNextSymbol(LLVMLibrary.LLVMSymbolIteratorRef SI) {
		LLVMMoveToNextSymbol(Pointer.getPeer(SI));
	}
	protected native static void LLVMMoveToNextSymbol(@Ptr long SI);
	/**
	 * SectionRef accessors<br>
	 * Original signature : <code>char* LLVMGetSectionName(LLVMSectionIteratorRef)</code>
	 */
	public static Pointer<Byte > LLVMGetSectionName(LLVMLibrary.LLVMSectionIteratorRef SI) {
		return (Pointer)Pointer.pointerToAddress(LLVMGetSectionName(Pointer.getPeer(SI)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetSectionName(@Ptr long SI);
	/** Original signature : <code>uint64_t LLVMGetSectionSize(LLVMSectionIteratorRef)</code> */
	public static long LLVMGetSectionSize(LLVMLibrary.LLVMSectionIteratorRef SI) {
		return LLVMGetSectionSize(Pointer.getPeer(SI));
	}
	protected native static long LLVMGetSectionSize(@Ptr long SI);
	/** Original signature : <code>char* LLVMGetSectionContents(LLVMSectionIteratorRef)</code> */
	public static Pointer<Byte > LLVMGetSectionContents(LLVMLibrary.LLVMSectionIteratorRef SI) {
		return (Pointer)Pointer.pointerToAddress(LLVMGetSectionContents(Pointer.getPeer(SI)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetSectionContents(@Ptr long SI);
	/** Original signature : <code>uint64_t LLVMGetSectionAddress(LLVMSectionIteratorRef)</code> */
	public static long LLVMGetSectionAddress(LLVMLibrary.LLVMSectionIteratorRef SI) {
		return LLVMGetSectionAddress(Pointer.getPeer(SI));
	}
	protected native static long LLVMGetSectionAddress(@Ptr long SI);
	/** Original signature : <code>LLVMBool LLVMGetSectionContainsSymbol(LLVMSectionIteratorRef, LLVMSymbolIteratorRef)</code> */
	public static int LLVMGetSectionContainsSymbol(LLVMLibrary.LLVMSectionIteratorRef SI, LLVMLibrary.LLVMSymbolIteratorRef Sym) {
		return LLVMGetSectionContainsSymbol(Pointer.getPeer(SI), Pointer.getPeer(Sym));
	}
	protected native static int LLVMGetSectionContainsSymbol(@Ptr long SI, @Ptr long Sym);
	/**
	 * Section Relocation iterators<br>
	 * Original signature : <code>LLVMRelocationIteratorRef LLVMGetRelocations(LLVMSectionIteratorRef)</code>
	 */
	public static LLVMLibrary.LLVMRelocationIteratorRef LLVMGetRelocations(LLVMLibrary.LLVMSectionIteratorRef Section) {
		return new LLVMLibrary.LLVMRelocationIteratorRef(LLVMGetRelocations(Pointer.getPeer(Section)));
	}
	@Ptr 
	protected native static long LLVMGetRelocations(@Ptr long Section);
	/** Original signature : <code>void LLVMDisposeRelocationIterator(LLVMRelocationIteratorRef)</code> */
	public static void LLVMDisposeRelocationIterator(LLVMLibrary.LLVMRelocationIteratorRef RI) {
		LLVMDisposeRelocationIterator(Pointer.getPeer(RI));
	}
	protected native static void LLVMDisposeRelocationIterator(@Ptr long RI);
	/** Original signature : <code>LLVMBool LLVMIsRelocationIteratorAtEnd(LLVMSectionIteratorRef, LLVMRelocationIteratorRef)</code> */
	public static int LLVMIsRelocationIteratorAtEnd(LLVMLibrary.LLVMSectionIteratorRef Section, LLVMLibrary.LLVMRelocationIteratorRef RI) {
		return LLVMIsRelocationIteratorAtEnd(Pointer.getPeer(Section), Pointer.getPeer(RI));
	}
	protected native static int LLVMIsRelocationIteratorAtEnd(@Ptr long Section, @Ptr long RI);
	/** Original signature : <code>void LLVMMoveToNextRelocation(LLVMRelocationIteratorRef)</code> */
	public static void LLVMMoveToNextRelocation(LLVMLibrary.LLVMRelocationIteratorRef RI) {
		LLVMMoveToNextRelocation(Pointer.getPeer(RI));
	}
	protected native static void LLVMMoveToNextRelocation(@Ptr long RI);
	/**
	 * SymbolRef accessors<br>
	 * Original signature : <code>char* LLVMGetSymbolName(LLVMSymbolIteratorRef)</code>
	 */
	public static Pointer<Byte > LLVMGetSymbolName(LLVMLibrary.LLVMSymbolIteratorRef SI) {
		return (Pointer)Pointer.pointerToAddress(LLVMGetSymbolName(Pointer.getPeer(SI)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetSymbolName(@Ptr long SI);
	/** Original signature : <code>uint64_t LLVMGetSymbolAddress(LLVMSymbolIteratorRef)</code> */
	public static long LLVMGetSymbolAddress(LLVMLibrary.LLVMSymbolIteratorRef SI) {
		return LLVMGetSymbolAddress(Pointer.getPeer(SI));
	}
	protected native static long LLVMGetSymbolAddress(@Ptr long SI);
	/** Original signature : <code>uint64_t LLVMGetSymbolSize(LLVMSymbolIteratorRef)</code> */
	public static long LLVMGetSymbolSize(LLVMLibrary.LLVMSymbolIteratorRef SI) {
		return LLVMGetSymbolSize(Pointer.getPeer(SI));
	}
	protected native static long LLVMGetSymbolSize(@Ptr long SI);
	/**
	 * RelocationRef accessors<br>
	 * Original signature : <code>uint64_t LLVMGetRelocationOffset(LLVMRelocationIteratorRef)</code>
	 */
	public static long LLVMGetRelocationOffset(LLVMLibrary.LLVMRelocationIteratorRef RI) {
		return LLVMGetRelocationOffset(Pointer.getPeer(RI));
	}
	protected native static long LLVMGetRelocationOffset(@Ptr long RI);
	/** Original signature : <code>LLVMSymbolIteratorRef LLVMGetRelocationSymbol(LLVMRelocationIteratorRef)</code> */
	public static LLVMLibrary.LLVMSymbolIteratorRef LLVMGetRelocationSymbol(LLVMLibrary.LLVMRelocationIteratorRef RI) {
		return new LLVMLibrary.LLVMSymbolIteratorRef(LLVMGetRelocationSymbol(Pointer.getPeer(RI)));
	}
	@Ptr 
	protected native static long LLVMGetRelocationSymbol(@Ptr long RI);
	/** Original signature : <code>uint64_t LLVMGetRelocationType(LLVMRelocationIteratorRef)</code> */
	public static long LLVMGetRelocationType(LLVMLibrary.LLVMRelocationIteratorRef RI) {
		return LLVMGetRelocationType(Pointer.getPeer(RI));
	}
	protected native static long LLVMGetRelocationType(@Ptr long RI);
	/**
	 * following functions.<br>
	 * Original signature : <code>char* LLVMGetRelocationTypeName(LLVMRelocationIteratorRef)</code>
	 */
	public static Pointer<Byte > LLVMGetRelocationTypeName(LLVMLibrary.LLVMRelocationIteratorRef RI) {
		return (Pointer)Pointer.pointerToAddress(LLVMGetRelocationTypeName(Pointer.getPeer(RI)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetRelocationTypeName(@Ptr long RI);
	/** Original signature : <code>char* LLVMGetRelocationValueString(LLVMRelocationIteratorRef)</code> */
	public static Pointer<Byte > LLVMGetRelocationValueString(LLVMLibrary.LLVMRelocationIteratorRef RI) {
		return (Pointer)Pointer.pointerToAddress(LLVMGetRelocationValueString(Pointer.getPeer(RI)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetRelocationValueString(@Ptr long RI);
	/**
	 * Obtain the data layout for a module.<br>
	 * @see Module::getDataLayout()<br>
	 * Original signature : <code>LLVMTargetDataRef LLVMGetModuleDataLayout(LLVMModuleRef)</code>
	 */
	public static LLVMLibrary.LLVMTargetDataRef LLVMGetModuleDataLayout(LLVMLibrary.LLVMModuleRef M) {
		return new LLVMLibrary.LLVMTargetDataRef(LLVMGetModuleDataLayout(Pointer.getPeer(M)));
	}
	@Ptr 
	protected native static long LLVMGetModuleDataLayout(@Ptr long M);
	/**
	 * Set the data layout for a module.<br>
	 * @see Module::setDataLayout()<br>
	 * Original signature : <code>void LLVMSetModuleDataLayout(LLVMModuleRef, LLVMTargetDataRef)</code>
	 */
	public static void LLVMSetModuleDataLayout(LLVMLibrary.LLVMModuleRef M, LLVMLibrary.LLVMTargetDataRef DL) {
		LLVMSetModuleDataLayout(Pointer.getPeer(M), Pointer.getPeer(DL));
	}
	protected native static void LLVMSetModuleDataLayout(@Ptr long M, @Ptr long DL);
	/**
	 * Creates target data from a target layout string.<br>
	 * See the constructor llvm::DataLayout::DataLayout.<br>
	 * Original signature : <code>LLVMTargetDataRef LLVMCreateTargetData(const char*)</code>
	 */
	public static LLVMLibrary.LLVMTargetDataRef LLVMCreateTargetData(Pointer<Byte > StringRep) {
		return new LLVMLibrary.LLVMTargetDataRef(LLVMCreateTargetData(Pointer.getPeer(StringRep)));
	}
	@Ptr 
	protected native static long LLVMCreateTargetData(@Ptr long StringRep);
	/**
	 * Deallocates a TargetData.<br>
	 * See the destructor llvm::DataLayout::~DataLayout.<br>
	 * Original signature : <code>void LLVMDisposeTargetData(LLVMTargetDataRef)</code>
	 */
	public static void LLVMDisposeTargetData(LLVMLibrary.LLVMTargetDataRef TD) {
		LLVMDisposeTargetData(Pointer.getPeer(TD));
	}
	protected native static void LLVMDisposeTargetData(@Ptr long TD);
	/**
	 * Adds target library information to a pass manager. This does not take<br>
	 * ownership of the target library info.<br>
	 * See the method llvm::PassManagerBase::add.<br>
	 * Original signature : <code>void LLVMAddTargetLibraryInfo(LLVMTargetLibraryInfoRef, LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddTargetLibraryInfo(LLVMLibrary.LLVMTargetLibraryInfoRef TLI, LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddTargetLibraryInfo(Pointer.getPeer(TLI), Pointer.getPeer(PM));
	}
	protected native static void LLVMAddTargetLibraryInfo(@Ptr long TLI, @Ptr long PM);
	/**
	 * Converts target data to a target layout string. The string must be disposed<br>
	 * with LLVMDisposeMessage.<br>
	 * See the constructor llvm::DataLayout::DataLayout.<br>
	 * Original signature : <code>char* LLVMCopyStringRepOfTargetData(LLVMTargetDataRef)</code>
	 */
	public static Pointer<Byte > LLVMCopyStringRepOfTargetData(LLVMLibrary.LLVMTargetDataRef TD) {
		return (Pointer)Pointer.pointerToAddress(LLVMCopyStringRepOfTargetData(Pointer.getPeer(TD)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMCopyStringRepOfTargetData(@Ptr long TD);
	/**
	 * Returns the byte order of a target, either LLVMBigEndian or<br>
	 * LLVMLittleEndian.<br>
	 * See the method llvm::DataLayout::isLittleEndian.<br>
	 * Original signature : <code>LLVMByteOrdering LLVMByteOrder(LLVMTargetDataRef)</code>
	 */
	public static IntValuedEnum<LLVMLibrary.LLVMByteOrdering > LLVMByteOrder(LLVMLibrary.LLVMTargetDataRef TD) {
		return FlagSet.fromValue(LLVMByteOrder(Pointer.getPeer(TD)), LLVMLibrary.LLVMByteOrdering.class);
	}
	protected native static int LLVMByteOrder(@Ptr long TD);
	/**
	 * Returns the pointer size in bytes for a target.<br>
	 * See the method llvm::DataLayout::getPointerSize.<br>
	 * Original signature : <code>int LLVMPointerSize(LLVMTargetDataRef)</code>
	 */
	public static int LLVMPointerSize(LLVMLibrary.LLVMTargetDataRef TD) {
		return LLVMPointerSize(Pointer.getPeer(TD));
	}
	protected native static int LLVMPointerSize(@Ptr long TD);
	/**
	 * Returns the pointer size in bytes for a target for a specified<br>
	 * address space.<br>
	 * See the method llvm::DataLayout::getPointerSize.<br>
	 * Original signature : <code>int LLVMPointerSizeForAS(LLVMTargetDataRef, unsigned)</code>
	 */
	public static int LLVMPointerSizeForAS(LLVMLibrary.LLVMTargetDataRef TD, int AS) {
		return LLVMPointerSizeForAS(Pointer.getPeer(TD), AS);
	}
	protected native static int LLVMPointerSizeForAS(@Ptr long TD, int AS);
	/**
	 * Returns the integer type that is the same size as a pointer on a target.<br>
	 * See the method llvm::DataLayout::getIntPtrType.<br>
	 * Original signature : <code>LLVMTypeRef LLVMIntPtrType(LLVMTargetDataRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMIntPtrType(LLVMLibrary.LLVMTargetDataRef TD) {
		return new LLVMLibrary.LLVMTypeRef(LLVMIntPtrType(Pointer.getPeer(TD)));
	}
	@Ptr 
	protected native static long LLVMIntPtrType(@Ptr long TD);
	/**
	 * Returns the integer type that is the same size as a pointer on a target.<br>
	 * This version allows the address space to be specified.<br>
	 * See the method llvm::DataLayout::getIntPtrType.<br>
	 * Original signature : <code>LLVMTypeRef LLVMIntPtrTypeForAS(LLVMTargetDataRef, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMIntPtrTypeForAS(LLVMLibrary.LLVMTargetDataRef TD, int AS) {
		return new LLVMLibrary.LLVMTypeRef(LLVMIntPtrTypeForAS(Pointer.getPeer(TD), AS));
	}
	@Ptr 
	protected native static long LLVMIntPtrTypeForAS(@Ptr long TD, int AS);
	/**
	 * Returns the integer type that is the same size as a pointer on a target.<br>
	 * See the method llvm::DataLayout::getIntPtrType.<br>
	 * Original signature : <code>LLVMTypeRef LLVMIntPtrTypeInContext(LLVMContextRef, LLVMTargetDataRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMIntPtrTypeInContext(LLVMLibrary.LLVMContextRef C, LLVMLibrary.LLVMTargetDataRef TD) {
		return new LLVMLibrary.LLVMTypeRef(LLVMIntPtrTypeInContext(Pointer.getPeer(C), Pointer.getPeer(TD)));
	}
	@Ptr 
	protected native static long LLVMIntPtrTypeInContext(@Ptr long C, @Ptr long TD);
	/**
	 * Returns the integer type that is the same size as a pointer on a target.<br>
	 * This version allows the address space to be specified.<br>
	 * See the method llvm::DataLayout::getIntPtrType.<br>
	 * Original signature : <code>LLVMTypeRef LLVMIntPtrTypeForASInContext(LLVMContextRef, LLVMTargetDataRef, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMIntPtrTypeForASInContext(LLVMLibrary.LLVMContextRef C, LLVMLibrary.LLVMTargetDataRef TD, int AS) {
		return new LLVMLibrary.LLVMTypeRef(LLVMIntPtrTypeForASInContext(Pointer.getPeer(C), Pointer.getPeer(TD), AS));
	}
	@Ptr 
	protected native static long LLVMIntPtrTypeForASInContext(@Ptr long C, @Ptr long TD, int AS);
	/**
	 * Computes the size of a type in bytes for a target.<br>
	 * See the method llvm::DataLayout::getTypeSizeInBits.<br>
	 * Original signature : <code>long long LLVMSizeOfTypeInBits(LLVMTargetDataRef, LLVMTypeRef)</code>
	 */
	public static long LLVMSizeOfTypeInBits(LLVMLibrary.LLVMTargetDataRef TD, LLVMLibrary.LLVMTypeRef Ty) {
		return LLVMSizeOfTypeInBits(Pointer.getPeer(TD), Pointer.getPeer(Ty));
	}
	protected native static long LLVMSizeOfTypeInBits(@Ptr long TD, @Ptr long Ty);
	/**
	 * Computes the storage size of a type in bytes for a target.<br>
	 * See the method llvm::DataLayout::getTypeStoreSize.<br>
	 * Original signature : <code>long long LLVMStoreSizeOfType(LLVMTargetDataRef, LLVMTypeRef)</code>
	 */
	public static long LLVMStoreSizeOfType(LLVMLibrary.LLVMTargetDataRef TD, LLVMLibrary.LLVMTypeRef Ty) {
		return LLVMStoreSizeOfType(Pointer.getPeer(TD), Pointer.getPeer(Ty));
	}
	protected native static long LLVMStoreSizeOfType(@Ptr long TD, @Ptr long Ty);
	/**
	 * Computes the ABI size of a type in bytes for a target.<br>
	 * See the method llvm::DataLayout::getTypeAllocSize.<br>
	 * Original signature : <code>long long LLVMABISizeOfType(LLVMTargetDataRef, LLVMTypeRef)</code>
	 */
	public static long LLVMABISizeOfType(LLVMLibrary.LLVMTargetDataRef TD, LLVMLibrary.LLVMTypeRef Ty) {
		return LLVMABISizeOfType(Pointer.getPeer(TD), Pointer.getPeer(Ty));
	}
	protected native static long LLVMABISizeOfType(@Ptr long TD, @Ptr long Ty);
	/**
	 * Computes the ABI alignment of a type in bytes for a target.<br>
	 * See the method llvm::DataLayout::getTypeABISize.<br>
	 * Original signature : <code>int LLVMABIAlignmentOfType(LLVMTargetDataRef, LLVMTypeRef)</code>
	 */
	public static int LLVMABIAlignmentOfType(LLVMLibrary.LLVMTargetDataRef TD, LLVMLibrary.LLVMTypeRef Ty) {
		return LLVMABIAlignmentOfType(Pointer.getPeer(TD), Pointer.getPeer(Ty));
	}
	protected native static int LLVMABIAlignmentOfType(@Ptr long TD, @Ptr long Ty);
	/**
	 * Computes the call frame alignment of a type in bytes for a target.<br>
	 * See the method llvm::DataLayout::getTypeABISize.<br>
	 * Original signature : <code>int LLVMCallFrameAlignmentOfType(LLVMTargetDataRef, LLVMTypeRef)</code>
	 */
	public static int LLVMCallFrameAlignmentOfType(LLVMLibrary.LLVMTargetDataRef TD, LLVMLibrary.LLVMTypeRef Ty) {
		return LLVMCallFrameAlignmentOfType(Pointer.getPeer(TD), Pointer.getPeer(Ty));
	}
	protected native static int LLVMCallFrameAlignmentOfType(@Ptr long TD, @Ptr long Ty);
	/**
	 * Computes the preferred alignment of a type in bytes for a target.<br>
	 * See the method llvm::DataLayout::getTypeABISize.<br>
	 * Original signature : <code>int LLVMPreferredAlignmentOfType(LLVMTargetDataRef, LLVMTypeRef)</code>
	 */
	public static int LLVMPreferredAlignmentOfType(LLVMLibrary.LLVMTargetDataRef TD, LLVMLibrary.LLVMTypeRef Ty) {
		return LLVMPreferredAlignmentOfType(Pointer.getPeer(TD), Pointer.getPeer(Ty));
	}
	protected native static int LLVMPreferredAlignmentOfType(@Ptr long TD, @Ptr long Ty);
	/**
	 * Computes the preferred alignment of a global variable in bytes for a target.<br>
	 * See the method llvm::DataLayout::getPreferredAlignment.<br>
	 * Original signature : <code>int LLVMPreferredAlignmentOfGlobal(LLVMTargetDataRef, LLVMValueRef)</code>
	 */
	public static int LLVMPreferredAlignmentOfGlobal(LLVMLibrary.LLVMTargetDataRef TD, LLVMLibrary.LLVMValueRef GlobalVar) {
		return LLVMPreferredAlignmentOfGlobal(Pointer.getPeer(TD), Pointer.getPeer(GlobalVar));
	}
	protected native static int LLVMPreferredAlignmentOfGlobal(@Ptr long TD, @Ptr long GlobalVar);
	/**
	 * Computes the structure element that contains the byte offset for a target.<br>
	 * See the method llvm::StructLayout::getElementContainingOffset.<br>
	 * Original signature : <code>int LLVMElementAtOffset(LLVMTargetDataRef, LLVMTypeRef, unsigned long long)</code>
	 */
	public static int LLVMElementAtOffset(LLVMLibrary.LLVMTargetDataRef TD, LLVMLibrary.LLVMTypeRef StructTy, long Offset) {
		return LLVMElementAtOffset(Pointer.getPeer(TD), Pointer.getPeer(StructTy), Offset);
	}
	protected native static int LLVMElementAtOffset(@Ptr long TD, @Ptr long StructTy, long Offset);
	/**
	 * Computes the byte offset of the indexed struct element for a target.<br>
	 * See the method llvm::StructLayout::getElementContainingOffset.<br>
	 * Original signature : <code>long long LLVMOffsetOfElement(LLVMTargetDataRef, LLVMTypeRef, unsigned)</code>
	 */
	public static long LLVMOffsetOfElement(LLVMLibrary.LLVMTargetDataRef TD, LLVMLibrary.LLVMTypeRef StructTy, int Element) {
		return LLVMOffsetOfElement(Pointer.getPeer(TD), Pointer.getPeer(StructTy), Element);
	}
	protected native static long LLVMOffsetOfElement(@Ptr long TD, @Ptr long StructTy, int Element);
	public static class LLVMAttributeRef extends TypedPointer {
		public LLVMAttributeRef(long address) {
			super(address);
		}
		public LLVMAttributeRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMContextRef extends TypedPointer {
		public LLVMContextRef(long address) {
			super(address);
		}
		public LLVMContextRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMObjectFileRef extends TypedPointer {
		public LLVMObjectFileRef(long address) {
			super(address);
		}
		public LLVMObjectFileRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMSymbolIteratorRef extends TypedPointer {
		public LLVMSymbolIteratorRef(long address) {
			super(address);
		}
		public LLVMSymbolIteratorRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMDiagnosticInfoRef extends TypedPointer {
		public LLVMDiagnosticInfoRef(long address) {
			super(address);
		}
		public LLVMDiagnosticInfoRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMValueRef extends TypedPointer {
		public LLVMValueRef(long address) {
			super(address);
		}
		public LLVMValueRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMPassManagerRef extends TypedPointer {
		public LLVMPassManagerRef(long address) {
			super(address);
		}
		public LLVMPassManagerRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMRelocationIteratorRef extends TypedPointer {
		public LLVMRelocationIteratorRef(long address) {
			super(address);
		}
		public LLVMRelocationIteratorRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMTypeRef extends TypedPointer {
		public LLVMTypeRef(long address) {
			super(address);
		}
		public LLVMTypeRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMModuleProviderRef extends TypedPointer {
		public LLVMModuleProviderRef(long address) {
			super(address);
		}
		public LLVMModuleProviderRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMModuleRef extends TypedPointer {
		public LLVMModuleRef(long address) {
			super(address);
		}
		public LLVMModuleRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMUseRef extends TypedPointer {
		public LLVMUseRef(long address) {
			super(address);
		}
		public LLVMUseRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMPassManagerBuilderRef extends TypedPointer {
		public LLVMPassManagerBuilderRef(long address) {
			super(address);
		}
		public LLVMPassManagerBuilderRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMBasicBlockRef extends TypedPointer {
		public LLVMBasicBlockRef(long address) {
			super(address);
		}
		public LLVMBasicBlockRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMTargetLibraryInfoRef extends TypedPointer {
		public LLVMTargetLibraryInfoRef(long address) {
			super(address);
		}
		public LLVMTargetLibraryInfoRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMMemoryBufferRef extends TypedPointer {
		public LLVMMemoryBufferRef(long address) {
			super(address);
		}
		public LLVMMemoryBufferRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMSectionIteratorRef extends TypedPointer {
		public LLVMSectionIteratorRef(long address) {
			super(address);
		}
		public LLVMSectionIteratorRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMPassRegistryRef extends TypedPointer {
		public LLVMPassRegistryRef(long address) {
			super(address);
		}
		public LLVMPassRegistryRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMBuilderRef extends TypedPointer {
		public LLVMBuilderRef(long address) {
			super(address);
		}
		public LLVMBuilderRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMTargetDataRef extends TypedPointer {
		public LLVMTargetDataRef(long address) {
			super(address);
		}
		public LLVMTargetDataRef(Pointer address) {
			super(address);
		}
	};
	/** Undefined type */
	public static interface LLVMOpaqueRelocationIterator {
		
	};
	/** Undefined type */
	public static interface LLVMOpaqueTargetData {
		
	};
	/** Undefined type */
	public static interface LLVMOpaqueDiagnosticInfo {
		
	};
	/** Undefined type */
	public static interface LLVMOpaquePassManager {
		
	};
	/** Undefined type */
	public static interface LLVMOpaqueTargetLibraryInfotData {
		
	};
	/** Undefined type */
	public static interface LLVMOpaqueBasicBlock {
		
	};
	/** Undefined type */
	public static interface LLVMOpaqueMemoryBuffer {
		
	};
	/** Undefined type */
	public static interface LLVMOpaqueValue {
		
	};
	/** Undefined type */
	public static interface LLVMOpaqueUse {
		
	};
	/** Undefined type */
	public static interface LLVMOpaquePassManagerBuilder {
		
	};
	/** Undefined type */
	public static interface LLVMOpaqueModule {
		
	};
	/** Undefined type */
	public static interface LLVMOpaqueType {
		
	};
	/** Undefined type */
	public static interface LLVMOpaqueModuleProvider {
		
	};
	/** Undefined type */
	public static interface LLVMOpaqueSymbolIterator {
		
	};
	/** Undefined type */
	public static interface LLVMOpaqueBuilder {
		
	};
	/** Undefined type */
	public static interface LLVMOpaqueContext {
		
	};
	/** Undefined type */
	public static interface LLVMOpaqueObjectFile {
		
	};
	/** Undefined type */
	public static interface LLVMOpaquePassRegistry {
		
	};
	/** Undefined type */
	public static interface LLVMOpaqueSectionIterator {
		
	};
	/** Undefined type */
	public static interface LLVMOpaqueAttributeRef {
		
	};
}
