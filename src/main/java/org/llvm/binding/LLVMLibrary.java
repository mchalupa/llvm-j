package org.llvm.binding;
import java.util.Collections;
import java.util.Iterator;
import org.bridj.BridJ;
import org.bridj.CRuntime;
import org.bridj.Callback;
import org.bridj.FlagSet;
import org.bridj.IntValuedEnum;
import org.bridj.Pointer;
import org.bridj.TypedPointer;
import org.bridj.ann.Library;
import org.bridj.ann.Name;
import org.bridj.ann.Ptr;
import org.bridj.ann.Runtime;
import org.bridj.util.DefaultParameterizedType;
/**
 * Wrapper for library <b>LLVM</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("LLVM-4.0") 
@Runtime(CRuntime.class) 
public class LLVMLibrary {
	static {
		BridJ.register();
	}
	/** enum values */
	public enum LLVMVerifierFailureAction implements IntValuedEnum<LLVMVerifierFailureAction > {
		/** verifier will print to stderr and abort() */
		LLVMAbortProcessAction(0),
		/** verifier will print to stderr and return 1 */
		LLVMPrintMessageAction(1),
		/** verifier will just return 1 */
		LLVMReturnStatusAction(2);
		LLVMVerifierFailureAction(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMVerifierFailureAction > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMVerifierFailureAction > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/**
	 * @defgroup LLVMCTarget Target information<br>
	 * @ingroup LLVMC<br>
	 * @{<br>
	 * enum values
	 */
	public enum LLVMByteOrdering implements IntValuedEnum<LLVMByteOrdering > {
		LLVMBigEndian(0),
		LLVMLittleEndian(1);
		LLVMByteOrdering(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMByteOrdering > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMByteOrdering > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	public static abstract class LLVMMemoryManagerAllocateCodeSectionCallback extends Callback<LLVMMemoryManagerAllocateCodeSectionCallback > {
		public Pointer<Byte > apply(Pointer<? > Opaque, Pointer<Integer > Size, int Alignment, int SectionID, Pointer<Byte > SectionName) {
			return (Pointer)Pointer.pointerToAddress(apply(Pointer.getPeer(Opaque), Pointer.getPeer(Size), Alignment, SectionID, Pointer.getPeer(SectionName)), Byte.class);
		}
		@Ptr 
		public long apply(@Ptr long Opaque, @Ptr long Size, int Alignment, int SectionID, @Ptr long SectionName) {
			return Pointer.getPeer(apply(Pointer.pointerToAddress(Opaque), (Pointer)Pointer.pointerToAddress(Size, Integer.class), Alignment, SectionID, (Pointer)Pointer.pointerToAddress(SectionName, Byte.class)));
		}
	};
	public static abstract class LLVMMemoryManagerAllocateDataSectionCallback extends Callback<LLVMMemoryManagerAllocateDataSectionCallback > {
		public Pointer<Byte > apply(Pointer<? > Opaque, Pointer<Integer > Size, int Alignment, int SectionID, Pointer<Byte > SectionName, int IsReadOnly) {
			return (Pointer)Pointer.pointerToAddress(apply(Pointer.getPeer(Opaque), Pointer.getPeer(Size), Alignment, SectionID, Pointer.getPeer(SectionName), IsReadOnly), Byte.class);
		}
		@Ptr 
		public long apply(@Ptr long Opaque, @Ptr long Size, int Alignment, int SectionID, @Ptr long SectionName, int IsReadOnly) {
			return Pointer.getPeer(apply(Pointer.pointerToAddress(Opaque), (Pointer)Pointer.pointerToAddress(Size, Integer.class), Alignment, SectionID, (Pointer)Pointer.pointerToAddress(SectionName, Byte.class), IsReadOnly));
		}
	};
	public static abstract class LLVMMemoryManagerFinalizeMemoryCallback extends Callback<LLVMMemoryManagerFinalizeMemoryCallback > {
		public int apply(Pointer<? > Opaque, Pointer<Pointer<Byte > > ErrMsg) {
			return apply(Pointer.getPeer(Opaque), Pointer.getPeer(ErrMsg));
		}
		public int apply(@Ptr long Opaque, @Ptr long ErrMsg) {
			return apply(Pointer.pointerToAddress(Opaque), (Pointer)Pointer.pointerToAddress(ErrMsg, DefaultParameterizedType.paramType(Pointer.class, Byte.class)));
		}
	};
	public static abstract class LLVMMemoryManagerDestroyCallback extends Callback<LLVMMemoryManagerDestroyCallback > {
		public void apply(Pointer<? > Opaque) {
			apply(Pointer.getPeer(Opaque));
		}
		public void apply(@Ptr long Opaque) {
			apply(Pointer.pointerToAddress(Opaque));
		}
	};
	/**
	 * See llvm::createAggressiveDCEPass function.<br>
	 * Original signature : <code>void LLVMAddAggressiveDCEPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddAggressiveDCEPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddAggressiveDCEPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddAggressiveDCEPass(@Ptr long PM);
	/**
	 * See llvm::createBitTrackingDCEPass function.<br>
	 * Original signature : <code>void LLVMAddBitTrackingDCEPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddBitTrackingDCEPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddBitTrackingDCEPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddBitTrackingDCEPass(@Ptr long PM);
	/**
	 * See llvm::createAlignmentFromAssumptionsPass function.<br>
	 * Original signature : <code>void LLVMAddAlignmentFromAssumptionsPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddAlignmentFromAssumptionsPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddAlignmentFromAssumptionsPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddAlignmentFromAssumptionsPass(@Ptr long PM);
	/**
	 * See llvm::createCFGSimplificationPass function.<br>
	 * Original signature : <code>void LLVMAddCFGSimplificationPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddCFGSimplificationPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddCFGSimplificationPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddCFGSimplificationPass(@Ptr long PM);
	/**
	 * See llvm::createDeadStoreEliminationPass function.<br>
	 * Original signature : <code>void LLVMAddDeadStoreEliminationPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddDeadStoreEliminationPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddDeadStoreEliminationPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddDeadStoreEliminationPass(@Ptr long PM);
	/**
	 * See llvm::createScalarizerPass function.<br>
	 * Original signature : <code>void LLVMAddScalarizerPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddScalarizerPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddScalarizerPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddScalarizerPass(@Ptr long PM);
	/**
	 * See llvm::createMergedLoadStoreMotionPass function.<br>
	 * Original signature : <code>void LLVMAddMergedLoadStoreMotionPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddMergedLoadStoreMotionPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddMergedLoadStoreMotionPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddMergedLoadStoreMotionPass(@Ptr long PM);
	/**
	 * See llvm::createGVNPass function.<br>
	 * Original signature : <code>void LLVMAddGVNPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddGVNPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddGVNPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddGVNPass(@Ptr long PM);
	/**
	 * See llvm::createGVNPass function.<br>
	 * Original signature : <code>void LLVMAddNewGVNPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddNewGVNPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddNewGVNPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddNewGVNPass(@Ptr long PM);
	/**
	 * See llvm::createIndVarSimplifyPass function.<br>
	 * Original signature : <code>void LLVMAddIndVarSimplifyPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddIndVarSimplifyPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddIndVarSimplifyPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddIndVarSimplifyPass(@Ptr long PM);
	/**
	 * See llvm::createInstructionCombiningPass function.<br>
	 * Original signature : <code>void LLVMAddInstructionCombiningPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddInstructionCombiningPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddInstructionCombiningPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddInstructionCombiningPass(@Ptr long PM);
	/**
	 * See llvm::createJumpThreadingPass function.<br>
	 * Original signature : <code>void LLVMAddJumpThreadingPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddJumpThreadingPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddJumpThreadingPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddJumpThreadingPass(@Ptr long PM);
	/**
	 * See llvm::createLICMPass function.<br>
	 * Original signature : <code>void LLVMAddLICMPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddLICMPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddLICMPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddLICMPass(@Ptr long PM);
	/**
	 * See llvm::createLoopDeletionPass function.<br>
	 * Original signature : <code>void LLVMAddLoopDeletionPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddLoopDeletionPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddLoopDeletionPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddLoopDeletionPass(@Ptr long PM);
	/**
	 * See llvm::createLoopIdiomPass function<br>
	 * Original signature : <code>void LLVMAddLoopIdiomPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddLoopIdiomPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddLoopIdiomPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddLoopIdiomPass(@Ptr long PM);
	/**
	 * See llvm::createLoopRotatePass function.<br>
	 * Original signature : <code>void LLVMAddLoopRotatePass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddLoopRotatePass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddLoopRotatePass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddLoopRotatePass(@Ptr long PM);
	/**
	 * See llvm::createLoopRerollPass function.<br>
	 * Original signature : <code>void LLVMAddLoopRerollPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddLoopRerollPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddLoopRerollPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddLoopRerollPass(@Ptr long PM);
	/**
	 * See llvm::createLoopUnrollPass function.<br>
	 * Original signature : <code>void LLVMAddLoopUnrollPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddLoopUnrollPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddLoopUnrollPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddLoopUnrollPass(@Ptr long PM);
	/**
	 * See llvm::createLoopUnswitchPass function.<br>
	 * Original signature : <code>void LLVMAddLoopUnswitchPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddLoopUnswitchPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddLoopUnswitchPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddLoopUnswitchPass(@Ptr long PM);
	/**
	 * See llvm::createMemCpyOptPass function.<br>
	 * Original signature : <code>void LLVMAddMemCpyOptPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddMemCpyOptPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddMemCpyOptPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddMemCpyOptPass(@Ptr long PM);
	/**
	 * See llvm::createPartiallyInlineLibCallsPass function.<br>
	 * Original signature : <code>void LLVMAddPartiallyInlineLibCallsPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddPartiallyInlineLibCallsPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddPartiallyInlineLibCallsPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddPartiallyInlineLibCallsPass(@Ptr long PM);
	/**
	 * See llvm::createLowerSwitchPass function.<br>
	 * Original signature : <code>void LLVMAddLowerSwitchPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddLowerSwitchPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddLowerSwitchPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddLowerSwitchPass(@Ptr long PM);
	/**
	 * See llvm::createPromoteMemoryToRegisterPass function.<br>
	 * Original signature : <code>void LLVMAddPromoteMemoryToRegisterPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddPromoteMemoryToRegisterPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddPromoteMemoryToRegisterPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddPromoteMemoryToRegisterPass(@Ptr long PM);
	/**
	 * See llvm::createReassociatePass function.<br>
	 * Original signature : <code>void LLVMAddReassociatePass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddReassociatePass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddReassociatePass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddReassociatePass(@Ptr long PM);
	/**
	 * See llvm::createSCCPPass function.<br>
	 * Original signature : <code>void LLVMAddSCCPPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddSCCPPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddSCCPPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddSCCPPass(@Ptr long PM);
	/**
	 * See llvm::createSROAPass function.<br>
	 * Original signature : <code>void LLVMAddScalarReplAggregatesPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddScalarReplAggregatesPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddScalarReplAggregatesPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddScalarReplAggregatesPass(@Ptr long PM);
	/**
	 * See llvm::createSROAPass function.<br>
	 * Original signature : <code>void LLVMAddScalarReplAggregatesPassSSA(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddScalarReplAggregatesPassSSA(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddScalarReplAggregatesPassSSA(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddScalarReplAggregatesPassSSA(@Ptr long PM);
	/**
	 * See llvm::createSROAPass function.<br>
	 * Original signature : <code>void LLVMAddScalarReplAggregatesPassWithThreshold(LLVMPassManagerRef, int)</code>
	 */
	public static void LLVMAddScalarReplAggregatesPassWithThreshold(LLVMLibrary.LLVMPassManagerRef PM, int Threshold) {
		LLVMAddScalarReplAggregatesPassWithThreshold(Pointer.getPeer(PM), Threshold);
	}
	protected native static void LLVMAddScalarReplAggregatesPassWithThreshold(@Ptr long PM, int Threshold);
	/**
	 * See llvm::createSimplifyLibCallsPass function.<br>
	 * Original signature : <code>void LLVMAddSimplifyLibCallsPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddSimplifyLibCallsPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddSimplifyLibCallsPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddSimplifyLibCallsPass(@Ptr long PM);
	/**
	 * See llvm::createTailCallEliminationPass function.<br>
	 * Original signature : <code>void LLVMAddTailCallEliminationPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddTailCallEliminationPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddTailCallEliminationPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddTailCallEliminationPass(@Ptr long PM);
	/**
	 * See llvm::createConstantPropagationPass function.<br>
	 * Original signature : <code>void LLVMAddConstantPropagationPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddConstantPropagationPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddConstantPropagationPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddConstantPropagationPass(@Ptr long PM);
	/**
	 * See llvm::demotePromoteMemoryToRegisterPass function.<br>
	 * Original signature : <code>void LLVMAddDemoteMemoryToRegisterPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddDemoteMemoryToRegisterPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddDemoteMemoryToRegisterPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddDemoteMemoryToRegisterPass(@Ptr long PM);
	/**
	 * See llvm::createVerifierPass function.<br>
	 * Original signature : <code>void LLVMAddVerifierPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddVerifierPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddVerifierPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddVerifierPass(@Ptr long PM);
	/**
	 * See llvm::createCorrelatedValuePropagationPass function<br>
	 * Original signature : <code>void LLVMAddCorrelatedValuePropagationPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddCorrelatedValuePropagationPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddCorrelatedValuePropagationPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddCorrelatedValuePropagationPass(@Ptr long PM);
	/**
	 * See llvm::createEarlyCSEPass function<br>
	 * Original signature : <code>void LLVMAddEarlyCSEPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddEarlyCSEPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddEarlyCSEPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddEarlyCSEPass(@Ptr long PM);
	/**
	 * See llvm::createEarlyCSEPass function<br>
	 * Original signature : <code>void LLVMAddEarlyCSEMemSSAPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddEarlyCSEMemSSAPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddEarlyCSEMemSSAPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddEarlyCSEMemSSAPass(@Ptr long PM);
	/**
	 * See llvm::createLowerExpectIntrinsicPass function<br>
	 * Original signature : <code>void LLVMAddLowerExpectIntrinsicPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddLowerExpectIntrinsicPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddLowerExpectIntrinsicPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddLowerExpectIntrinsicPass(@Ptr long PM);
	/**
	 * See llvm::createTypeBasedAliasAnalysisPass function<br>
	 * Original signature : <code>void LLVMAddTypeBasedAliasAnalysisPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddTypeBasedAliasAnalysisPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddTypeBasedAliasAnalysisPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddTypeBasedAliasAnalysisPass(@Ptr long PM);
	/**
	 * See llvm::createScopedNoAliasAAPass function<br>
	 * Original signature : <code>void LLVMAddScopedNoAliasAAPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddScopedNoAliasAAPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddScopedNoAliasAAPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddScopedNoAliasAAPass(@Ptr long PM);
	/**
	 * See llvm::createBasicAliasAnalysisPass function<br>
	 * Original signature : <code>void LLVMAddBasicAliasAnalysisPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddBasicAliasAnalysisPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddBasicAliasAnalysisPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddBasicAliasAnalysisPass(@Ptr long PM);
	/**
	 * See llvm::PassManagerBuilder.<br>
	 * Original signature : <code>LLVMPassManagerBuilderRef LLVMPassManagerBuilderCreate()</code>
	 */
	public static LLVMLibrary.LLVMPassManagerBuilderRef LLVMPassManagerBuilderCreate() {
		return new LLVMLibrary.LLVMPassManagerBuilderRef(LLVMPassManagerBuilderCreate$2());
	}
	@Ptr 
	@Name("LLVMPassManagerBuilderCreate") 
	protected native static long LLVMPassManagerBuilderCreate$2();
	/** Original signature : <code>void LLVMPassManagerBuilderDispose(LLVMPassManagerBuilderRef)</code> */
	public static void LLVMPassManagerBuilderDispose(LLVMLibrary.LLVMPassManagerBuilderRef PMB) {
		LLVMPassManagerBuilderDispose(Pointer.getPeer(PMB));
	}
	protected native static void LLVMPassManagerBuilderDispose(@Ptr long PMB);
	/**
	 * See llvm::PassManagerBuilder::OptLevel.<br>
	 * Original signature : <code>void LLVMPassManagerBuilderSetOptLevel(LLVMPassManagerBuilderRef, unsigned)</code>
	 */
	public static void LLVMPassManagerBuilderSetOptLevel(LLVMLibrary.LLVMPassManagerBuilderRef PMB, int OptLevel) {
		LLVMPassManagerBuilderSetOptLevel(Pointer.getPeer(PMB), OptLevel);
	}
	protected native static void LLVMPassManagerBuilderSetOptLevel(@Ptr long PMB, int OptLevel);
	/**
	 * See llvm::PassManagerBuilder::SizeLevel.<br>
	 * Original signature : <code>void LLVMPassManagerBuilderSetSizeLevel(LLVMPassManagerBuilderRef, unsigned)</code>
	 */
	public static void LLVMPassManagerBuilderSetSizeLevel(LLVMLibrary.LLVMPassManagerBuilderRef PMB, int SizeLevel) {
		LLVMPassManagerBuilderSetSizeLevel(Pointer.getPeer(PMB), SizeLevel);
	}
	protected native static void LLVMPassManagerBuilderSetSizeLevel(@Ptr long PMB, int SizeLevel);
	/**
	 * See llvm::PassManagerBuilder::DisableUnitAtATime.<br>
	 * Original signature : <code>void LLVMPassManagerBuilderSetDisableUnitAtATime(LLVMPassManagerBuilderRef, LLVMBool)</code>
	 */
	public static void LLVMPassManagerBuilderSetDisableUnitAtATime(LLVMLibrary.LLVMPassManagerBuilderRef PMB, int Value) {
		LLVMPassManagerBuilderSetDisableUnitAtATime(Pointer.getPeer(PMB), Value);
	}
	protected native static void LLVMPassManagerBuilderSetDisableUnitAtATime(@Ptr long PMB, int Value);
	/**
	 * See llvm::PassManagerBuilder::DisableUnrollLoops.<br>
	 * Original signature : <code>void LLVMPassManagerBuilderSetDisableUnrollLoops(LLVMPassManagerBuilderRef, LLVMBool)</code>
	 */
	public static void LLVMPassManagerBuilderSetDisableUnrollLoops(LLVMLibrary.LLVMPassManagerBuilderRef PMB, int Value) {
		LLVMPassManagerBuilderSetDisableUnrollLoops(Pointer.getPeer(PMB), Value);
	}
	protected native static void LLVMPassManagerBuilderSetDisableUnrollLoops(@Ptr long PMB, int Value);
	/**
	 * See llvm::PassManagerBuilder::DisableSimplifyLibCalls<br>
	 * Original signature : <code>void LLVMPassManagerBuilderSetDisableSimplifyLibCalls(LLVMPassManagerBuilderRef, LLVMBool)</code>
	 */
	public static void LLVMPassManagerBuilderSetDisableSimplifyLibCalls(LLVMLibrary.LLVMPassManagerBuilderRef PMB, int Value) {
		LLVMPassManagerBuilderSetDisableSimplifyLibCalls(Pointer.getPeer(PMB), Value);
	}
	protected native static void LLVMPassManagerBuilderSetDisableSimplifyLibCalls(@Ptr long PMB, int Value);
	/**
	 * See llvm::PassManagerBuilder::Inliner.<br>
	 * Original signature : <code>void LLVMPassManagerBuilderUseInlinerWithThreshold(LLVMPassManagerBuilderRef, unsigned)</code>
	 */
	public static void LLVMPassManagerBuilderUseInlinerWithThreshold(LLVMLibrary.LLVMPassManagerBuilderRef PMB, int Threshold) {
		LLVMPassManagerBuilderUseInlinerWithThreshold(Pointer.getPeer(PMB), Threshold);
	}
	protected native static void LLVMPassManagerBuilderUseInlinerWithThreshold(@Ptr long PMB, int Threshold);
	/**
	 * See llvm::PassManagerBuilder::populateFunctionPassManager.<br>
	 * Original signature : <code>void LLVMPassManagerBuilderPopulateFunctionPassManager(LLVMPassManagerBuilderRef, LLVMPassManagerRef)</code>
	 */
	public static void LLVMPassManagerBuilderPopulateFunctionPassManager(LLVMLibrary.LLVMPassManagerBuilderRef PMB, LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMPassManagerBuilderPopulateFunctionPassManager(Pointer.getPeer(PMB), Pointer.getPeer(PM));
	}
	protected native static void LLVMPassManagerBuilderPopulateFunctionPassManager(@Ptr long PMB, @Ptr long PM);
	/**
	 * See llvm::PassManagerBuilder::populateModulePassManager.<br>
	 * Original signature : <code>void LLVMPassManagerBuilderPopulateModulePassManager(LLVMPassManagerBuilderRef, LLVMPassManagerRef)</code>
	 */
	public static void LLVMPassManagerBuilderPopulateModulePassManager(LLVMLibrary.LLVMPassManagerBuilderRef PMB, LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMPassManagerBuilderPopulateModulePassManager(Pointer.getPeer(PMB), Pointer.getPeer(PM));
	}
	protected native static void LLVMPassManagerBuilderPopulateModulePassManager(@Ptr long PMB, @Ptr long PM);
	/**
	 * See llvm::PassManagerBuilder::populateLTOPassManager.<br>
	 * Original signature : <code>void LLVMPassManagerBuilderPopulateLTOPassManager(LLVMPassManagerBuilderRef, LLVMPassManagerRef, LLVMBool, LLVMBool)</code>
	 */
	public static void LLVMPassManagerBuilderPopulateLTOPassManager(LLVMLibrary.LLVMPassManagerBuilderRef PMB, LLVMLibrary.LLVMPassManagerRef PM, int Internalize, int RunInliner) {
		LLVMPassManagerBuilderPopulateLTOPassManager(Pointer.getPeer(PMB), Pointer.getPeer(PM), Internalize, RunInliner);
	}
	protected native static void LLVMPassManagerBuilderPopulateLTOPassManager(@Ptr long PMB, @Ptr long PM, int Internalize, int RunInliner);
	/**
	 * See llvm::createBBVectorizePass function.<br>
	 * Original signature : <code>void LLVMAddBBVectorizePass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddBBVectorizePass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddBBVectorizePass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddBBVectorizePass(@Ptr long PM);
	/**
	 * See llvm::createLoopVectorizePass function.<br>
	 * Original signature : <code>void LLVMAddLoopVectorizePass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddLoopVectorizePass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddLoopVectorizePass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddLoopVectorizePass(@Ptr long PM);
	/**
	 * See llvm::createSLPVectorizerPass function.<br>
	 * Original signature : <code>void LLVMAddSLPVectorizePass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddSLPVectorizePass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddSLPVectorizePass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddSLPVectorizePass(@Ptr long PM);
	/**
	 * See llvm::createArgumentPromotionPass function.<br>
	 * Original signature : <code>void LLVMAddArgumentPromotionPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddArgumentPromotionPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddArgumentPromotionPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddArgumentPromotionPass(@Ptr long PM);
	/**
	 * See llvm::createConstantMergePass function.<br>
	 * Original signature : <code>void LLVMAddConstantMergePass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddConstantMergePass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddConstantMergePass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddConstantMergePass(@Ptr long PM);
	/**
	 * See llvm::createDeadArgEliminationPass function.<br>
	 * Original signature : <code>void LLVMAddDeadArgEliminationPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddDeadArgEliminationPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddDeadArgEliminationPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddDeadArgEliminationPass(@Ptr long PM);
	/**
	 * See llvm::createFunctionAttrsPass function.<br>
	 * Original signature : <code>void LLVMAddFunctionAttrsPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddFunctionAttrsPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddFunctionAttrsPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddFunctionAttrsPass(@Ptr long PM);
	/**
	 * See llvm::createFunctionInliningPass function.<br>
	 * Original signature : <code>void LLVMAddFunctionInliningPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddFunctionInliningPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddFunctionInliningPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddFunctionInliningPass(@Ptr long PM);
	/**
	 * See llvm::createAlwaysInlinerPass function.<br>
	 * Original signature : <code>void LLVMAddAlwaysInlinerPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddAlwaysInlinerPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddAlwaysInlinerPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddAlwaysInlinerPass(@Ptr long PM);
	/**
	 * See llvm::createGlobalDCEPass function.<br>
	 * Original signature : <code>void LLVMAddGlobalDCEPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddGlobalDCEPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddGlobalDCEPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddGlobalDCEPass(@Ptr long PM);
	/**
	 * See llvm::createGlobalOptimizerPass function.<br>
	 * Original signature : <code>void LLVMAddGlobalOptimizerPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddGlobalOptimizerPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddGlobalOptimizerPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddGlobalOptimizerPass(@Ptr long PM);
	/**
	 * See llvm::createIPConstantPropagationPass function.<br>
	 * Original signature : <code>void LLVMAddIPConstantPropagationPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddIPConstantPropagationPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddIPConstantPropagationPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddIPConstantPropagationPass(@Ptr long PM);
	/**
	 * See llvm::createPruneEHPass function.<br>
	 * Original signature : <code>void LLVMAddPruneEHPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddPruneEHPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddPruneEHPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddPruneEHPass(@Ptr long PM);
	/**
	 * See llvm::createIPSCCPPass function.<br>
	 * Original signature : <code>void LLVMAddIPSCCPPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddIPSCCPPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddIPSCCPPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddIPSCCPPass(@Ptr long PM);
	/**
	 * See llvm::createInternalizePass function.<br>
	 * Original signature : <code>void LLVMAddInternalizePass(unsigned)</code>
	 */
	public static native void LLVMAddInternalizePass(int AllButMain);
	/**
	 * See llvm::createStripDeadPrototypesPass function.<br>
	 * Original signature : <code>void LLVMAddStripDeadPrototypesPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddStripDeadPrototypesPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddStripDeadPrototypesPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddStripDeadPrototypesPass(@Ptr long PM);
	/**
	 * See llvm::createStripSymbolsPass function.<br>
	 * Original signature : <code>void LLVMAddStripSymbolsPass(LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddStripSymbolsPass(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddStripSymbolsPass(Pointer.getPeer(PM));
	}
	protected native static void LLVMAddStripSymbolsPass(@Ptr long PM);
	/**
	 * Verifies that a module is valid, taking the specified action if not.<br>
	 * Optionally returns a human-readable description of any invalid constructs.<br>
	 * OutMessage must be disposed with LLVMDisposeMessage.<br>
	 * Original signature : <code>LLVMBool LLVMVerifyModule(LLVMModuleRef, LLVMVerifierFailureAction, char**)</code>
	 */
	public static int LLVMVerifyModule(LLVMLibrary.LLVMModuleRef M, IntValuedEnum<LLVMLibrary.LLVMVerifierFailureAction > Action, Pointer<Pointer<Byte > > OutMessage) {
		return LLVMVerifyModule(Pointer.getPeer(M), (int)Action.value(), Pointer.getPeer(OutMessage));
	}
	protected native static int LLVMVerifyModule(@Ptr long M, int Action, @Ptr long OutMessage);
	/**
	 * Verifies that a single function is valid, taking the specified action. Useful<br>
	 * for debugging.<br>
	 * Original signature : <code>LLVMBool LLVMVerifyFunction(LLVMValueRef, LLVMVerifierFailureAction)</code>
	 */
	public static int LLVMVerifyFunction(LLVMLibrary.LLVMValueRef Fn, IntValuedEnum<LLVMLibrary.LLVMVerifierFailureAction > Action) {
		return LLVMVerifyFunction(Pointer.getPeer(Fn), (int)Action.value());
	}
	protected native static int LLVMVerifyFunction(@Ptr long Fn, int Action);
	/**
	 * Open up a ghostview window that displays the CFG of the current function.<br>
	 * Useful for debugging.<br>
	 * Original signature : <code>void LLVMViewFunctionCFG(LLVMValueRef)</code>
	 */
	public static void LLVMViewFunctionCFG(LLVMLibrary.LLVMValueRef Fn) {
		LLVMViewFunctionCFG(Pointer.getPeer(Fn));
	}
	protected native static void LLVMViewFunctionCFG(@Ptr long Fn);
	/** Original signature : <code>void LLVMViewFunctionCFGOnly(LLVMValueRef)</code> */
	public static void LLVMViewFunctionCFGOnly(LLVMLibrary.LLVMValueRef Fn) {
		LLVMViewFunctionCFGOnly(Pointer.getPeer(Fn));
	}
	protected native static void LLVMViewFunctionCFGOnly(@Ptr long Fn);
	/**
	 * Writes a module to the specified path. Returns 0 on success.<br>
	 * Original signature : <code>int LLVMWriteBitcodeToFile(LLVMModuleRef, const char*)</code>
	 */
	public static int LLVMWriteBitcodeToFile(LLVMLibrary.LLVMModuleRef M, Pointer<Byte > Path) {
		return LLVMWriteBitcodeToFile(Pointer.getPeer(M), Pointer.getPeer(Path));
	}
	protected native static int LLVMWriteBitcodeToFile(@Ptr long M, @Ptr long Path);
	/**
	 * Writes a module to an open file descriptor. Returns 0 on success.<br>
	 * Original signature : <code>int LLVMWriteBitcodeToFD(LLVMModuleRef, int, int, int)</code>
	 */
	public static int LLVMWriteBitcodeToFD(LLVMLibrary.LLVMModuleRef M, int FD, int ShouldClose, int Unbuffered) {
		return LLVMWriteBitcodeToFD(Pointer.getPeer(M), FD, ShouldClose, Unbuffered);
	}
	protected native static int LLVMWriteBitcodeToFD(@Ptr long M, int FD, int ShouldClose, int Unbuffered);
	/**
	 * Deprecated for LLVMWriteBitcodeToFD. Writes a module to an open file<br>
	 * descriptor. Returns 0 on success. Closes the Handle.<br>
	 * Original signature : <code>int LLVMWriteBitcodeToFileHandle(LLVMModuleRef, int)</code>
	 */
	public static int LLVMWriteBitcodeToFileHandle(LLVMLibrary.LLVMModuleRef M, int Handle) {
		return LLVMWriteBitcodeToFileHandle(Pointer.getPeer(M), Handle);
	}
	protected native static int LLVMWriteBitcodeToFileHandle(@Ptr long M, int Handle);
	/**
	 * Writes a module to a new memory buffer and returns it.<br>
	 * Original signature : <code>LLVMMemoryBufferRef LLVMWriteBitcodeToMemoryBuffer(LLVMModuleRef)</code>
	 */
	public static LLVMLibrary.LLVMMemoryBufferRef LLVMWriteBitcodeToMemoryBuffer(LLVMLibrary.LLVMModuleRef M) {
		return new LLVMLibrary.LLVMMemoryBufferRef(LLVMWriteBitcodeToMemoryBuffer(Pointer.getPeer(M)));
	}
	@Ptr 
	protected native static long LLVMWriteBitcodeToMemoryBuffer(@Ptr long M);
	/**
	 * @defgroup LLVMCExecutionEngine Execution Engine<br>
	 * @ingroup LLVMC<br>
	 * @{<br>
	 * Original signature : <code>void LLVMLinkInMCJIT()</code>
	 */
	public static native void LLVMLinkInMCJIT();
	/** Original signature : <code>void LLVMLinkInInterpreter()</code> */
	public static native void LLVMLinkInInterpreter();
	/**
	 * ===-- Operations on generic values --------------------------------------===<br>
	 * Original signature : <code>LLVMGenericValueRef LLVMCreateGenericValueOfInt(LLVMTypeRef, unsigned long long, LLVMBool)</code>
	 */
	public static LLVMLibrary.LLVMGenericValueRef LLVMCreateGenericValueOfInt(LLVMLibrary.LLVMTypeRef Ty, long N, int IsSigned) {
		return new LLVMLibrary.LLVMGenericValueRef(LLVMCreateGenericValueOfInt(Pointer.getPeer(Ty), N, IsSigned));
	}
	@Ptr 
	protected native static long LLVMCreateGenericValueOfInt(@Ptr long Ty, long N, int IsSigned);
	/** Original signature : <code>LLVMGenericValueRef LLVMCreateGenericValueOfPointer(void*)</code> */
	public static LLVMLibrary.LLVMGenericValueRef LLVMCreateGenericValueOfPointer(Pointer<? > P) {
		return new LLVMLibrary.LLVMGenericValueRef(LLVMCreateGenericValueOfPointer(Pointer.getPeer(P)));
	}
	@Ptr 
	protected native static long LLVMCreateGenericValueOfPointer(@Ptr long P);
	/** Original signature : <code>LLVMGenericValueRef LLVMCreateGenericValueOfFloat(LLVMTypeRef, double)</code> */
	public static LLVMLibrary.LLVMGenericValueRef LLVMCreateGenericValueOfFloat(LLVMLibrary.LLVMTypeRef Ty, double N) {
		return new LLVMLibrary.LLVMGenericValueRef(LLVMCreateGenericValueOfFloat(Pointer.getPeer(Ty), N));
	}
	@Ptr 
	protected native static long LLVMCreateGenericValueOfFloat(@Ptr long Ty, double N);
	/** Original signature : <code>int LLVMGenericValueIntWidth(LLVMGenericValueRef)</code> */
	public static int LLVMGenericValueIntWidth(LLVMLibrary.LLVMGenericValueRef GenValRef) {
		return LLVMGenericValueIntWidth(Pointer.getPeer(GenValRef));
	}
	protected native static int LLVMGenericValueIntWidth(@Ptr long GenValRef);
	/** Original signature : <code>long long LLVMGenericValueToInt(LLVMGenericValueRef, LLVMBool)</code> */
	public static long LLVMGenericValueToInt(LLVMLibrary.LLVMGenericValueRef GenVal, int IsSigned) {
		return LLVMGenericValueToInt(Pointer.getPeer(GenVal), IsSigned);
	}
	protected native static long LLVMGenericValueToInt(@Ptr long GenVal, int IsSigned);
	/** Original signature : <code>void* LLVMGenericValueToPointer(LLVMGenericValueRef)</code> */
	public static Pointer<? > LLVMGenericValueToPointer(LLVMLibrary.LLVMGenericValueRef GenVal) {
		return Pointer.pointerToAddress(LLVMGenericValueToPointer(Pointer.getPeer(GenVal)));
	}
	@Ptr 
	protected native static long LLVMGenericValueToPointer(@Ptr long GenVal);
	/** Original signature : <code>double LLVMGenericValueToFloat(LLVMTypeRef, LLVMGenericValueRef)</code> */
	public static double LLVMGenericValueToFloat(LLVMLibrary.LLVMTypeRef TyRef, LLVMLibrary.LLVMGenericValueRef GenVal) {
		return LLVMGenericValueToFloat(Pointer.getPeer(TyRef), Pointer.getPeer(GenVal));
	}
	protected native static double LLVMGenericValueToFloat(@Ptr long TyRef, @Ptr long GenVal);
	/** Original signature : <code>void LLVMDisposeGenericValue(LLVMGenericValueRef)</code> */
	public static void LLVMDisposeGenericValue(LLVMLibrary.LLVMGenericValueRef GenVal) {
		LLVMDisposeGenericValue(Pointer.getPeer(GenVal));
	}
	protected native static void LLVMDisposeGenericValue(@Ptr long GenVal);
	/**
	 * ===-- Operations on execution engines -----------------------------------===<br>
	 * Original signature : <code>LLVMBool LLVMCreateExecutionEngineForModule(LLVMExecutionEngineRef*, LLVMModuleRef, char**)</code>
	 */
	public static int LLVMCreateExecutionEngineForModule(Pointer<LLVMLibrary.LLVMExecutionEngineRef > OutEE, LLVMLibrary.LLVMModuleRef M, Pointer<Pointer<Byte > > OutError) {
		return LLVMCreateExecutionEngineForModule(Pointer.getPeer(OutEE), Pointer.getPeer(M), Pointer.getPeer(OutError));
	}
	protected native static int LLVMCreateExecutionEngineForModule(@Ptr long OutEE, @Ptr long M, @Ptr long OutError);
	/** Original signature : <code>LLVMBool LLVMCreateInterpreterForModule(LLVMExecutionEngineRef*, LLVMModuleRef, char**)</code> */
	public static int LLVMCreateInterpreterForModule(Pointer<LLVMLibrary.LLVMExecutionEngineRef > OutInterp, LLVMLibrary.LLVMModuleRef M, Pointer<Pointer<Byte > > OutError) {
		return LLVMCreateInterpreterForModule(Pointer.getPeer(OutInterp), Pointer.getPeer(M), Pointer.getPeer(OutError));
	}
	protected native static int LLVMCreateInterpreterForModule(@Ptr long OutInterp, @Ptr long M, @Ptr long OutError);
	/** Original signature : <code>LLVMBool LLVMCreateJITCompilerForModule(LLVMExecutionEngineRef*, LLVMModuleRef, unsigned, char**)</code> */
	public static int LLVMCreateJITCompilerForModule(Pointer<LLVMLibrary.LLVMExecutionEngineRef > OutJIT, LLVMLibrary.LLVMModuleRef M, int OptLevel, Pointer<Pointer<Byte > > OutError) {
		return LLVMCreateJITCompilerForModule(Pointer.getPeer(OutJIT), Pointer.getPeer(M), OptLevel, Pointer.getPeer(OutError));
	}
	protected native static int LLVMCreateJITCompilerForModule(@Ptr long OutJIT, @Ptr long M, int OptLevel, @Ptr long OutError);
	/** Original signature : <code>void LLVMInitializeMCJITCompilerOptions(LLVMMCJITCompilerOptions*, size_t)</code> */
	public static void LLVMInitializeMCJITCompilerOptions(Pointer<LLVMMCJITCompilerOptions > Options, @Ptr long SizeOfOptions) {
		LLVMInitializeMCJITCompilerOptions(Pointer.getPeer(Options), SizeOfOptions);
	}
	protected native static void LLVMInitializeMCJITCompilerOptions(@Ptr long Options, @Ptr long SizeOfOptions);
	/**
	 * Create an MCJIT execution engine for a module, with the given options. It is<br>
	 * the responsibility of the caller to ensure that all fields in Options up to<br>
	 * the given SizeOfOptions are initialized. It is correct to pass a smaller<br>
	 * value of SizeOfOptions that omits some fields. The canonical way of using<br>
	 * this is:<br>
	 * LLVMMCJITCompilerOptions options;<br>
	 * LLVMInitializeMCJITCompilerOptions(&options, sizeof(options));<br>
	 * ... fill in those options you care about<br>
	 * LLVMCreateMCJITCompilerForModule(&jit, mod, &options, sizeof(options),<br>
	 *                                  &error);<br>
	 * Note that this is also correct, though possibly suboptimal:<br>
	 * LLVMCreateMCJITCompilerForModule(&jit, mod, 0, 0, &error);<br>
	 * Original signature : <code>LLVMBool LLVMCreateMCJITCompilerForModule(LLVMExecutionEngineRef*, LLVMModuleRef, LLVMMCJITCompilerOptions*, size_t, char**)</code>
	 */
	public static int LLVMCreateMCJITCompilerForModule(Pointer<LLVMLibrary.LLVMExecutionEngineRef > OutJIT, LLVMLibrary.LLVMModuleRef M, Pointer<LLVMMCJITCompilerOptions > Options, @Ptr long SizeOfOptions, Pointer<Pointer<Byte > > OutError) {
		return LLVMCreateMCJITCompilerForModule(Pointer.getPeer(OutJIT), Pointer.getPeer(M), Pointer.getPeer(Options), SizeOfOptions, Pointer.getPeer(OutError));
	}
	protected native static int LLVMCreateMCJITCompilerForModule(@Ptr long OutJIT, @Ptr long M, @Ptr long Options, @Ptr long SizeOfOptions, @Ptr long OutError);
	/** Original signature : <code>void LLVMDisposeExecutionEngine(LLVMExecutionEngineRef)</code> */
	public static void LLVMDisposeExecutionEngine(LLVMLibrary.LLVMExecutionEngineRef EE) {
		LLVMDisposeExecutionEngine(Pointer.getPeer(EE));
	}
	protected native static void LLVMDisposeExecutionEngine(@Ptr long EE);
	/** Original signature : <code>void LLVMRunStaticConstructors(LLVMExecutionEngineRef)</code> */
	public static void LLVMRunStaticConstructors(LLVMLibrary.LLVMExecutionEngineRef EE) {
		LLVMRunStaticConstructors(Pointer.getPeer(EE));
	}
	protected native static void LLVMRunStaticConstructors(@Ptr long EE);
	/** Original signature : <code>void LLVMRunStaticDestructors(LLVMExecutionEngineRef)</code> */
	public static void LLVMRunStaticDestructors(LLVMLibrary.LLVMExecutionEngineRef EE) {
		LLVMRunStaticDestructors(Pointer.getPeer(EE));
	}
	protected native static void LLVMRunStaticDestructors(@Ptr long EE);
	/** Original signature : <code>int LLVMRunFunctionAsMain(LLVMExecutionEngineRef, LLVMValueRef, unsigned, const const char**, const const char**)</code> */
	public static int LLVMRunFunctionAsMain(LLVMLibrary.LLVMExecutionEngineRef EE, LLVMLibrary.LLVMValueRef F, int ArgC, Pointer<Pointer<Byte > > ArgV, Pointer<Pointer<Byte > > EnvP) {
		return LLVMRunFunctionAsMain(Pointer.getPeer(EE), Pointer.getPeer(F), ArgC, Pointer.getPeer(ArgV), Pointer.getPeer(EnvP));
	}
	protected native static int LLVMRunFunctionAsMain(@Ptr long EE, @Ptr long F, int ArgC, @Ptr long ArgV, @Ptr long EnvP);
	/** Original signature : <code>LLVMGenericValueRef LLVMRunFunction(LLVMExecutionEngineRef, LLVMValueRef, unsigned, LLVMGenericValueRef*)</code> */
	public static LLVMLibrary.LLVMGenericValueRef LLVMRunFunction(LLVMLibrary.LLVMExecutionEngineRef EE, LLVMLibrary.LLVMValueRef F, int NumArgs, Pointer<LLVMLibrary.LLVMGenericValueRef > Args) {
		return new LLVMLibrary.LLVMGenericValueRef(LLVMRunFunction(Pointer.getPeer(EE), Pointer.getPeer(F), NumArgs, Pointer.getPeer(Args)));
	}
	@Ptr 
	protected native static long LLVMRunFunction(@Ptr long EE, @Ptr long F, int NumArgs, @Ptr long Args);
	/** Original signature : <code>void LLVMFreeMachineCodeForFunction(LLVMExecutionEngineRef, LLVMValueRef)</code> */
	public static void LLVMFreeMachineCodeForFunction(LLVMLibrary.LLVMExecutionEngineRef EE, LLVMLibrary.LLVMValueRef F) {
		LLVMFreeMachineCodeForFunction(Pointer.getPeer(EE), Pointer.getPeer(F));
	}
	protected native static void LLVMFreeMachineCodeForFunction(@Ptr long EE, @Ptr long F);
	/** Original signature : <code>void LLVMAddModule(LLVMExecutionEngineRef, LLVMModuleRef)</code> */
	public static void LLVMAddModule(LLVMLibrary.LLVMExecutionEngineRef EE, LLVMLibrary.LLVMModuleRef M) {
		LLVMAddModule(Pointer.getPeer(EE), Pointer.getPeer(M));
	}
	protected native static void LLVMAddModule(@Ptr long EE, @Ptr long M);
	/** Original signature : <code>LLVMBool LLVMRemoveModule(LLVMExecutionEngineRef, LLVMModuleRef, LLVMModuleRef*, char**)</code> */
	public static int LLVMRemoveModule(LLVMLibrary.LLVMExecutionEngineRef EE, LLVMLibrary.LLVMModuleRef M, Pointer<LLVMLibrary.LLVMModuleRef > OutMod, Pointer<Pointer<Byte > > OutError) {
		return LLVMRemoveModule(Pointer.getPeer(EE), Pointer.getPeer(M), Pointer.getPeer(OutMod), Pointer.getPeer(OutError));
	}
	protected native static int LLVMRemoveModule(@Ptr long EE, @Ptr long M, @Ptr long OutMod, @Ptr long OutError);
	/** Original signature : <code>LLVMBool LLVMFindFunction(LLVMExecutionEngineRef, const char*, LLVMValueRef*)</code> */
	public static int LLVMFindFunction(LLVMLibrary.LLVMExecutionEngineRef EE, Pointer<Byte > Name, Pointer<LLVMLibrary.LLVMValueRef > OutFn) {
		return LLVMFindFunction(Pointer.getPeer(EE), Pointer.getPeer(Name), Pointer.getPeer(OutFn));
	}
	protected native static int LLVMFindFunction(@Ptr long EE, @Ptr long Name, @Ptr long OutFn);
	/** Original signature : <code>void* LLVMRecompileAndRelinkFunction(LLVMExecutionEngineRef, LLVMValueRef)</code> */
	public static Pointer<? > LLVMRecompileAndRelinkFunction(LLVMLibrary.LLVMExecutionEngineRef EE, LLVMLibrary.LLVMValueRef Fn) {
		return Pointer.pointerToAddress(LLVMRecompileAndRelinkFunction(Pointer.getPeer(EE), Pointer.getPeer(Fn)));
	}
	@Ptr 
	protected native static long LLVMRecompileAndRelinkFunction(@Ptr long EE, @Ptr long Fn);
	/** Original signature : <code>LLVMTargetDataRef LLVMGetExecutionEngineTargetData(LLVMExecutionEngineRef)</code> */
	public static LLVMLibrary.LLVMTargetDataRef LLVMGetExecutionEngineTargetData(LLVMLibrary.LLVMExecutionEngineRef EE) {
		return new LLVMLibrary.LLVMTargetDataRef(LLVMGetExecutionEngineTargetData(Pointer.getPeer(EE)));
	}
	@Ptr 
	protected native static long LLVMGetExecutionEngineTargetData(@Ptr long EE);
	/** Original signature : <code>LLVMTargetMachineRef LLVMGetExecutionEngineTargetMachine(LLVMExecutionEngineRef)</code> */
	public static LLVMLibrary.LLVMTargetMachineRef LLVMGetExecutionEngineTargetMachine(LLVMLibrary.LLVMExecutionEngineRef EE) {
		return Pointer.pointerToAddress(LLVMGetExecutionEngineTargetMachine(Pointer.getPeer(EE)));
	}
	@Ptr 
	protected native static long LLVMGetExecutionEngineTargetMachine(@Ptr long EE);
	/** Original signature : <code>void LLVMAddGlobalMapping(LLVMExecutionEngineRef, LLVMValueRef, void*)</code> */
	public static void LLVMAddGlobalMapping(LLVMLibrary.LLVMExecutionEngineRef EE, LLVMLibrary.LLVMValueRef Global, Pointer<? > Addr) {
		LLVMAddGlobalMapping(Pointer.getPeer(EE), Pointer.getPeer(Global), Pointer.getPeer(Addr));
	}
	protected native static void LLVMAddGlobalMapping(@Ptr long EE, @Ptr long Global, @Ptr long Addr);
	/** Original signature : <code>void* LLVMGetPointerToGlobal(LLVMExecutionEngineRef, LLVMValueRef)</code> */
	public static Pointer<? > LLVMGetPointerToGlobal(LLVMLibrary.LLVMExecutionEngineRef EE, LLVMLibrary.LLVMValueRef Global) {
		return Pointer.pointerToAddress(LLVMGetPointerToGlobal(Pointer.getPeer(EE), Pointer.getPeer(Global)));
	}
	@Ptr 
	protected native static long LLVMGetPointerToGlobal(@Ptr long EE, @Ptr long Global);
	/** Original signature : <code>uint64_t LLVMGetGlobalValueAddress(LLVMExecutionEngineRef, const char*)</code> */
	public static long LLVMGetGlobalValueAddress(LLVMLibrary.LLVMExecutionEngineRef EE, Pointer<Byte > Name) {
		return LLVMGetGlobalValueAddress(Pointer.getPeer(EE), Pointer.getPeer(Name));
	}
	protected native static long LLVMGetGlobalValueAddress(@Ptr long EE, @Ptr long Name);
	/** Original signature : <code>uint64_t LLVMGetFunctionAddress(LLVMExecutionEngineRef, const char*)</code> */
	public static long LLVMGetFunctionAddress(LLVMLibrary.LLVMExecutionEngineRef EE, Pointer<Byte > Name) {
		return LLVMGetFunctionAddress(Pointer.getPeer(EE), Pointer.getPeer(Name));
	}
	protected native static long LLVMGetFunctionAddress(@Ptr long EE, @Ptr long Name);
	/**
	 * Create a simple custom MCJIT memory manager. This memory manager can<br>
	 * intercept allocations in a module-oblivious way. This will return NULL<br>
	 * if any of the passed functions are NULL.<br>
	 * @param Opaque An opaque client object to pass back to the callbacks.<br>
	 * @param AllocateCodeSection Allocate a block of memory for executable code.<br>
	 * @param AllocateDataSection Allocate a block of memory for data.<br>
	 * @param FinalizeMemory Set page permissions and flush cache. Return 0 on<br>
	 *   success, 1 on error.<br>
	 * Original signature : <code>LLVMMCJITMemoryManagerRef LLVMCreateSimpleMCJITMemoryManager(void*, LLVMMemoryManagerAllocateCodeSectionCallback, LLVMMemoryManagerAllocateDataSectionCallback, LLVMMemoryManagerFinalizeMemoryCallback, LLVMMemoryManagerDestroyCallback)</code>
	 */
	public static LLVMLibrary.LLVMMCJITMemoryManagerRef LLVMCreateSimpleMCJITMemoryManager(Pointer<? > Opaque, Pointer<LLVMLibrary.LLVMMemoryManagerAllocateCodeSectionCallback > AllocateCodeSection, Pointer<LLVMLibrary.LLVMMemoryManagerAllocateDataSectionCallback > AllocateDataSection, Pointer<LLVMLibrary.LLVMMemoryManagerFinalizeMemoryCallback > FinalizeMemory, Pointer<LLVMLibrary.LLVMMemoryManagerDestroyCallback > Destroy) {
		return new LLVMLibrary.LLVMMCJITMemoryManagerRef(LLVMCreateSimpleMCJITMemoryManager(Pointer.getPeer(Opaque), Pointer.getPeer(AllocateCodeSection), Pointer.getPeer(AllocateDataSection), Pointer.getPeer(FinalizeMemory), Pointer.getPeer(Destroy)));
	}
	@Ptr 
	protected native static long LLVMCreateSimpleMCJITMemoryManager(@Ptr long Opaque, @Ptr long AllocateCodeSection, @Ptr long AllocateDataSection, @Ptr long FinalizeMemory, @Ptr long Destroy);
	/** Original signature : <code>void LLVMDisposeMCJITMemoryManager(LLVMMCJITMemoryManagerRef)</code> */
	public static void LLVMDisposeMCJITMemoryManager(LLVMLibrary.LLVMMCJITMemoryManagerRef MM) {
		LLVMDisposeMCJITMemoryManager(Pointer.getPeer(MM));
	}
	protected native static void LLVMDisposeMCJITMemoryManager(@Ptr long MM);
	/**
	 * @defgroup LLVMCInitialization Initialization Routines<br>
	 * @ingroup LLVMC<br>
	 * This module contains routines used to initialize the LLVM system.<br>
	 * @{<br>
	 * Original signature : <code>void LLVMInitializeCore(LLVMPassRegistryRef)</code>
	 */
	public static void LLVMInitializeCore(LLVMLibrary.LLVMPassRegistryRef R) {
		LLVMInitializeCore(Pointer.getPeer(R));
	}
	protected native static void LLVMInitializeCore(@Ptr long R);
	/** Original signature : <code>void LLVMInitializeTransformUtils(LLVMPassRegistryRef)</code> */
	public static void LLVMInitializeTransformUtils(LLVMLibrary.LLVMPassRegistryRef R) {
		LLVMInitializeTransformUtils(Pointer.getPeer(R));
	}
	protected native static void LLVMInitializeTransformUtils(@Ptr long R);
	/** Original signature : <code>void LLVMInitializeScalarOpts(LLVMPassRegistryRef)</code> */
	public static void LLVMInitializeScalarOpts(LLVMLibrary.LLVMPassRegistryRef R) {
		LLVMInitializeScalarOpts(Pointer.getPeer(R));
	}
	protected native static void LLVMInitializeScalarOpts(@Ptr long R);
	/** Original signature : <code>void LLVMInitializeObjCARCOpts(LLVMPassRegistryRef)</code> */
	public static void LLVMInitializeObjCARCOpts(LLVMLibrary.LLVMPassRegistryRef R) {
		LLVMInitializeObjCARCOpts(Pointer.getPeer(R));
	}
	protected native static void LLVMInitializeObjCARCOpts(@Ptr long R);
	/** Original signature : <code>void LLVMInitializeVectorization(LLVMPassRegistryRef)</code> */
	public static void LLVMInitializeVectorization(LLVMLibrary.LLVMPassRegistryRef R) {
		LLVMInitializeVectorization(Pointer.getPeer(R));
	}
	protected native static void LLVMInitializeVectorization(@Ptr long R);
	/** Original signature : <code>void LLVMInitializeInstCombine(LLVMPassRegistryRef)</code> */
	public static void LLVMInitializeInstCombine(LLVMLibrary.LLVMPassRegistryRef R) {
		LLVMInitializeInstCombine(Pointer.getPeer(R));
	}
	protected native static void LLVMInitializeInstCombine(@Ptr long R);
	/** Original signature : <code>void LLVMInitializeIPO(LLVMPassRegistryRef)</code> */
	public static void LLVMInitializeIPO(LLVMLibrary.LLVMPassRegistryRef R) {
		LLVMInitializeIPO(Pointer.getPeer(R));
	}
	protected native static void LLVMInitializeIPO(@Ptr long R);
	/** Original signature : <code>void LLVMInitializeInstrumentation(LLVMPassRegistryRef)</code> */
	public static void LLVMInitializeInstrumentation(LLVMLibrary.LLVMPassRegistryRef R) {
		LLVMInitializeInstrumentation(Pointer.getPeer(R));
	}
	protected native static void LLVMInitializeInstrumentation(@Ptr long R);
	/** Original signature : <code>void LLVMInitializeAnalysis(LLVMPassRegistryRef)</code> */
	public static void LLVMInitializeAnalysis(LLVMLibrary.LLVMPassRegistryRef R) {
		LLVMInitializeAnalysis(Pointer.getPeer(R));
	}
	protected native static void LLVMInitializeAnalysis(@Ptr long R);
	/** Original signature : <code>void LLVMInitializeIPA(LLVMPassRegistryRef)</code> */
	public static void LLVMInitializeIPA(LLVMLibrary.LLVMPassRegistryRef R) {
		LLVMInitializeIPA(Pointer.getPeer(R));
	}
	protected native static void LLVMInitializeIPA(@Ptr long R);
	/** Original signature : <code>void LLVMInitializeCodeGen(LLVMPassRegistryRef)</code> */
	public static void LLVMInitializeCodeGen(LLVMLibrary.LLVMPassRegistryRef R) {
		LLVMInitializeCodeGen(Pointer.getPeer(R));
	}
	protected native static void LLVMInitializeCodeGen(@Ptr long R);
	/** Original signature : <code>void LLVMInitializeTarget(LLVMPassRegistryRef)</code> */
	public static void LLVMInitializeTarget(LLVMLibrary.LLVMPassRegistryRef R) {
		LLVMInitializeTarget(Pointer.getPeer(R));
	}
	protected native static void LLVMInitializeTarget(@Ptr long R);
	/**
	 * ObjectFile creation<br>
	 * Original signature : <code>LLVMObjectFileRef LLVMCreateObjectFile(LLVMMemoryBufferRef)</code>
	 */
	public static LLVMLibrary.LLVMObjectFileRef LLVMCreateObjectFile(LLVMLibrary.LLVMMemoryBufferRef MemBuf) {
		return new LLVMLibrary.LLVMObjectFileRef(LLVMCreateObjectFile(Pointer.getPeer(MemBuf)));
	}
	@Ptr 
	protected native static long LLVMCreateObjectFile(@Ptr long MemBuf);
	/** Original signature : <code>void LLVMDisposeObjectFile(LLVMObjectFileRef)</code> */
	public static void LLVMDisposeObjectFile(LLVMLibrary.LLVMObjectFileRef ObjectFile) {
		LLVMDisposeObjectFile(Pointer.getPeer(ObjectFile));
	}
	protected native static void LLVMDisposeObjectFile(@Ptr long ObjectFile);
	/**
	 * ObjectFile Section iterators<br>
	 * Original signature : <code>LLVMSectionIteratorRef LLVMGetSections(LLVMObjectFileRef)</code>
	 */
	public static LLVMLibrary.LLVMSectionIteratorRef LLVMGetSections(LLVMLibrary.LLVMObjectFileRef ObjectFile) {
		return new LLVMLibrary.LLVMSectionIteratorRef(LLVMGetSections(Pointer.getPeer(ObjectFile)));
	}
	@Ptr 
	protected native static long LLVMGetSections(@Ptr long ObjectFile);
	/** Original signature : <code>void LLVMDisposeSectionIterator(LLVMSectionIteratorRef)</code> */
	public static void LLVMDisposeSectionIterator(LLVMLibrary.LLVMSectionIteratorRef SI) {
		LLVMDisposeSectionIterator(Pointer.getPeer(SI));
	}
	protected native static void LLVMDisposeSectionIterator(@Ptr long SI);
	/** Original signature : <code>LLVMBool LLVMIsSectionIteratorAtEnd(LLVMObjectFileRef, LLVMSectionIteratorRef)</code> */
	public static int LLVMIsSectionIteratorAtEnd(LLVMLibrary.LLVMObjectFileRef ObjectFile, LLVMLibrary.LLVMSectionIteratorRef SI) {
		return LLVMIsSectionIteratorAtEnd(Pointer.getPeer(ObjectFile), Pointer.getPeer(SI));
	}
	protected native static int LLVMIsSectionIteratorAtEnd(@Ptr long ObjectFile, @Ptr long SI);
	/** Original signature : <code>void LLVMMoveToNextSection(LLVMSectionIteratorRef)</code> */
	public static void LLVMMoveToNextSection(LLVMLibrary.LLVMSectionIteratorRef SI) {
		LLVMMoveToNextSection(Pointer.getPeer(SI));
	}
	protected native static void LLVMMoveToNextSection(@Ptr long SI);
	/** Original signature : <code>void LLVMMoveToContainingSection(LLVMSectionIteratorRef, LLVMSymbolIteratorRef)</code> */
	public static void LLVMMoveToContainingSection(LLVMLibrary.LLVMSectionIteratorRef Sect, LLVMLibrary.LLVMSymbolIteratorRef Sym) {
		LLVMMoveToContainingSection(Pointer.getPeer(Sect), Pointer.getPeer(Sym));
	}
	protected native static void LLVMMoveToContainingSection(@Ptr long Sect, @Ptr long Sym);
	/**
	 * ObjectFile Symbol iterators<br>
	 * Original signature : <code>LLVMSymbolIteratorRef LLVMGetSymbols(LLVMObjectFileRef)</code>
	 */
	public static LLVMLibrary.LLVMSymbolIteratorRef LLVMGetSymbols(LLVMLibrary.LLVMObjectFileRef ObjectFile) {
		return new LLVMLibrary.LLVMSymbolIteratorRef(LLVMGetSymbols(Pointer.getPeer(ObjectFile)));
	}
	@Ptr 
	protected native static long LLVMGetSymbols(@Ptr long ObjectFile);
	/** Original signature : <code>void LLVMDisposeSymbolIterator(LLVMSymbolIteratorRef)</code> */
	public static void LLVMDisposeSymbolIterator(LLVMLibrary.LLVMSymbolIteratorRef SI) {
		LLVMDisposeSymbolIterator(Pointer.getPeer(SI));
	}
	protected native static void LLVMDisposeSymbolIterator(@Ptr long SI);
	/** Original signature : <code>LLVMBool LLVMIsSymbolIteratorAtEnd(LLVMObjectFileRef, LLVMSymbolIteratorRef)</code> */
	public static int LLVMIsSymbolIteratorAtEnd(LLVMLibrary.LLVMObjectFileRef ObjectFile, LLVMLibrary.LLVMSymbolIteratorRef SI) {
		return LLVMIsSymbolIteratorAtEnd(Pointer.getPeer(ObjectFile), Pointer.getPeer(SI));
	}
	protected native static int LLVMIsSymbolIteratorAtEnd(@Ptr long ObjectFile, @Ptr long SI);
	/** Original signature : <code>void LLVMMoveToNextSymbol(LLVMSymbolIteratorRef)</code> */
	public static void LLVMMoveToNextSymbol(LLVMLibrary.LLVMSymbolIteratorRef SI) {
		LLVMMoveToNextSymbol(Pointer.getPeer(SI));
	}
	protected native static void LLVMMoveToNextSymbol(@Ptr long SI);
	/**
	 * SectionRef accessors<br>
	 * Original signature : <code>char* LLVMGetSectionName(LLVMSectionIteratorRef)</code>
	 */
	public static Pointer<Byte > LLVMGetSectionName(LLVMLibrary.LLVMSectionIteratorRef SI) {
		return (Pointer)Pointer.pointerToAddress(LLVMGetSectionName(Pointer.getPeer(SI)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetSectionName(@Ptr long SI);
	/** Original signature : <code>uint64_t LLVMGetSectionSize(LLVMSectionIteratorRef)</code> */
	public static long LLVMGetSectionSize(LLVMLibrary.LLVMSectionIteratorRef SI) {
		return LLVMGetSectionSize(Pointer.getPeer(SI));
	}
	protected native static long LLVMGetSectionSize(@Ptr long SI);
	/** Original signature : <code>char* LLVMGetSectionContents(LLVMSectionIteratorRef)</code> */
	public static Pointer<Byte > LLVMGetSectionContents(LLVMLibrary.LLVMSectionIteratorRef SI) {
		return (Pointer)Pointer.pointerToAddress(LLVMGetSectionContents(Pointer.getPeer(SI)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetSectionContents(@Ptr long SI);
	/** Original signature : <code>uint64_t LLVMGetSectionAddress(LLVMSectionIteratorRef)</code> */
	public static long LLVMGetSectionAddress(LLVMLibrary.LLVMSectionIteratorRef SI) {
		return LLVMGetSectionAddress(Pointer.getPeer(SI));
	}
	protected native static long LLVMGetSectionAddress(@Ptr long SI);
	/** Original signature : <code>LLVMBool LLVMGetSectionContainsSymbol(LLVMSectionIteratorRef, LLVMSymbolIteratorRef)</code> */
	public static int LLVMGetSectionContainsSymbol(LLVMLibrary.LLVMSectionIteratorRef SI, LLVMLibrary.LLVMSymbolIteratorRef Sym) {
		return LLVMGetSectionContainsSymbol(Pointer.getPeer(SI), Pointer.getPeer(Sym));
	}
	protected native static int LLVMGetSectionContainsSymbol(@Ptr long SI, @Ptr long Sym);
	/**
	 * Section Relocation iterators<br>
	 * Original signature : <code>LLVMRelocationIteratorRef LLVMGetRelocations(LLVMSectionIteratorRef)</code>
	 */
	public static LLVMLibrary.LLVMRelocationIteratorRef LLVMGetRelocations(LLVMLibrary.LLVMSectionIteratorRef Section) {
		return new LLVMLibrary.LLVMRelocationIteratorRef(LLVMGetRelocations(Pointer.getPeer(Section)));
	}
	@Ptr 
	protected native static long LLVMGetRelocations(@Ptr long Section);
	/** Original signature : <code>void LLVMDisposeRelocationIterator(LLVMRelocationIteratorRef)</code> */
	public static void LLVMDisposeRelocationIterator(LLVMLibrary.LLVMRelocationIteratorRef RI) {
		LLVMDisposeRelocationIterator(Pointer.getPeer(RI));
	}
	protected native static void LLVMDisposeRelocationIterator(@Ptr long RI);
	/** Original signature : <code>LLVMBool LLVMIsRelocationIteratorAtEnd(LLVMSectionIteratorRef, LLVMRelocationIteratorRef)</code> */
	public static int LLVMIsRelocationIteratorAtEnd(LLVMLibrary.LLVMSectionIteratorRef Section, LLVMLibrary.LLVMRelocationIteratorRef RI) {
		return LLVMIsRelocationIteratorAtEnd(Pointer.getPeer(Section), Pointer.getPeer(RI));
	}
	protected native static int LLVMIsRelocationIteratorAtEnd(@Ptr long Section, @Ptr long RI);
	/** Original signature : <code>void LLVMMoveToNextRelocation(LLVMRelocationIteratorRef)</code> */
	public static void LLVMMoveToNextRelocation(LLVMLibrary.LLVMRelocationIteratorRef RI) {
		LLVMMoveToNextRelocation(Pointer.getPeer(RI));
	}
	protected native static void LLVMMoveToNextRelocation(@Ptr long RI);
	/**
	 * SymbolRef accessors<br>
	 * Original signature : <code>char* LLVMGetSymbolName(LLVMSymbolIteratorRef)</code>
	 */
	public static Pointer<Byte > LLVMGetSymbolName(LLVMLibrary.LLVMSymbolIteratorRef SI) {
		return (Pointer)Pointer.pointerToAddress(LLVMGetSymbolName(Pointer.getPeer(SI)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetSymbolName(@Ptr long SI);
	/** Original signature : <code>uint64_t LLVMGetSymbolAddress(LLVMSymbolIteratorRef)</code> */
	public static long LLVMGetSymbolAddress(LLVMLibrary.LLVMSymbolIteratorRef SI) {
		return LLVMGetSymbolAddress(Pointer.getPeer(SI));
	}
	protected native static long LLVMGetSymbolAddress(@Ptr long SI);
	/** Original signature : <code>uint64_t LLVMGetSymbolSize(LLVMSymbolIteratorRef)</code> */
	public static long LLVMGetSymbolSize(LLVMLibrary.LLVMSymbolIteratorRef SI) {
		return LLVMGetSymbolSize(Pointer.getPeer(SI));
	}
	protected native static long LLVMGetSymbolSize(@Ptr long SI);
	/**
	 * RelocationRef accessors<br>
	 * Original signature : <code>uint64_t LLVMGetRelocationOffset(LLVMRelocationIteratorRef)</code>
	 */
	public static long LLVMGetRelocationOffset(LLVMLibrary.LLVMRelocationIteratorRef RI) {
		return LLVMGetRelocationOffset(Pointer.getPeer(RI));
	}
	protected native static long LLVMGetRelocationOffset(@Ptr long RI);
	/** Original signature : <code>LLVMSymbolIteratorRef LLVMGetRelocationSymbol(LLVMRelocationIteratorRef)</code> */
	public static LLVMLibrary.LLVMSymbolIteratorRef LLVMGetRelocationSymbol(LLVMLibrary.LLVMRelocationIteratorRef RI) {
		return new LLVMLibrary.LLVMSymbolIteratorRef(LLVMGetRelocationSymbol(Pointer.getPeer(RI)));
	}
	@Ptr 
	protected native static long LLVMGetRelocationSymbol(@Ptr long RI);
	/** Original signature : <code>uint64_t LLVMGetRelocationType(LLVMRelocationIteratorRef)</code> */
	public static long LLVMGetRelocationType(LLVMLibrary.LLVMRelocationIteratorRef RI) {
		return LLVMGetRelocationType(Pointer.getPeer(RI));
	}
	protected native static long LLVMGetRelocationType(@Ptr long RI);
	/**
	 * following functions.<br>
	 * Original signature : <code>char* LLVMGetRelocationTypeName(LLVMRelocationIteratorRef)</code>
	 */
	public static Pointer<Byte > LLVMGetRelocationTypeName(LLVMLibrary.LLVMRelocationIteratorRef RI) {
		return (Pointer)Pointer.pointerToAddress(LLVMGetRelocationTypeName(Pointer.getPeer(RI)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetRelocationTypeName(@Ptr long RI);
	/** Original signature : <code>char* LLVMGetRelocationValueString(LLVMRelocationIteratorRef)</code> */
	public static Pointer<Byte > LLVMGetRelocationValueString(LLVMLibrary.LLVMRelocationIteratorRef RI) {
		return (Pointer)Pointer.pointerToAddress(LLVMGetRelocationValueString(Pointer.getPeer(RI)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetRelocationValueString(@Ptr long RI);
	/**
	 * Obtain the data layout for a module.<br>
	 * @see Module::getDataLayout()<br>
	 * Original signature : <code>LLVMTargetDataRef LLVMGetModuleDataLayout(LLVMModuleRef)</code>
	 */
	public static LLVMLibrary.LLVMTargetDataRef LLVMGetModuleDataLayout(LLVMLibrary.LLVMModuleRef M) {
		return new LLVMLibrary.LLVMTargetDataRef(LLVMGetModuleDataLayout(Pointer.getPeer(M)));
	}
	@Ptr 
	protected native static long LLVMGetModuleDataLayout(@Ptr long M);
	/**
	 * Set the data layout for a module.<br>
	 * @see Module::setDataLayout()<br>
	 * Original signature : <code>void LLVMSetModuleDataLayout(LLVMModuleRef, LLVMTargetDataRef)</code>
	 */
	public static void LLVMSetModuleDataLayout(LLVMLibrary.LLVMModuleRef M, LLVMLibrary.LLVMTargetDataRef DL) {
		LLVMSetModuleDataLayout(Pointer.getPeer(M), Pointer.getPeer(DL));
	}
	protected native static void LLVMSetModuleDataLayout(@Ptr long M, @Ptr long DL);
	/**
	 * Creates target data from a target layout string.<br>
	 * See the constructor llvm::DataLayout::DataLayout.<br>
	 * Original signature : <code>LLVMTargetDataRef LLVMCreateTargetData(const char*)</code>
	 */
	public static LLVMLibrary.LLVMTargetDataRef LLVMCreateTargetData(Pointer<Byte > StringRep) {
		return new LLVMLibrary.LLVMTargetDataRef(LLVMCreateTargetData(Pointer.getPeer(StringRep)));
	}
	@Ptr 
	protected native static long LLVMCreateTargetData(@Ptr long StringRep);
	/**
	 * Deallocates a TargetData.<br>
	 * See the destructor llvm::DataLayout::~DataLayout.<br>
	 * Original signature : <code>void LLVMDisposeTargetData(LLVMTargetDataRef)</code>
	 */
	public static void LLVMDisposeTargetData(LLVMLibrary.LLVMTargetDataRef TD) {
		LLVMDisposeTargetData(Pointer.getPeer(TD));
	}
	protected native static void LLVMDisposeTargetData(@Ptr long TD);
	/**
	 * Adds target library information to a pass manager. This does not take<br>
	 * ownership of the target library info.<br>
	 * See the method llvm::PassManagerBase::add.<br>
	 * Original signature : <code>void LLVMAddTargetLibraryInfo(LLVMTargetLibraryInfoRef, LLVMPassManagerRef)</code>
	 */
	public static void LLVMAddTargetLibraryInfo(LLVMLibrary.LLVMTargetLibraryInfoRef TLI, LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMAddTargetLibraryInfo(Pointer.getPeer(TLI), Pointer.getPeer(PM));
	}
	protected native static void LLVMAddTargetLibraryInfo(@Ptr long TLI, @Ptr long PM);
	/**
	 * Converts target data to a target layout string. The string must be disposed<br>
	 * with LLVMDisposeMessage.<br>
	 * See the constructor llvm::DataLayout::DataLayout.<br>
	 * Original signature : <code>char* LLVMCopyStringRepOfTargetData(LLVMTargetDataRef)</code>
	 */
	public static Pointer<Byte > LLVMCopyStringRepOfTargetData(LLVMLibrary.LLVMTargetDataRef TD) {
		return (Pointer)Pointer.pointerToAddress(LLVMCopyStringRepOfTargetData(Pointer.getPeer(TD)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMCopyStringRepOfTargetData(@Ptr long TD);
	/**
	 * Returns the byte order of a target, either LLVMBigEndian or<br>
	 * LLVMLittleEndian.<br>
	 * See the method llvm::DataLayout::isLittleEndian.<br>
	 * Original signature : <code>LLVMByteOrdering LLVMByteOrder(LLVMTargetDataRef)</code>
	 */
	public static IntValuedEnum<LLVMLibrary.LLVMByteOrdering > LLVMByteOrder(LLVMLibrary.LLVMTargetDataRef TD) {
		return FlagSet.fromValue(LLVMByteOrder(Pointer.getPeer(TD)), LLVMLibrary.LLVMByteOrdering.class);
	}
	protected native static int LLVMByteOrder(@Ptr long TD);
	/**
	 * Returns the pointer size in bytes for a target.<br>
	 * See the method llvm::DataLayout::getPointerSize.<br>
	 * Original signature : <code>int LLVMPointerSize(LLVMTargetDataRef)</code>
	 */
	public static int LLVMPointerSize(LLVMLibrary.LLVMTargetDataRef TD) {
		return LLVMPointerSize(Pointer.getPeer(TD));
	}
	protected native static int LLVMPointerSize(@Ptr long TD);
	/**
	 * Returns the pointer size in bytes for a target for a specified<br>
	 * address space.<br>
	 * See the method llvm::DataLayout::getPointerSize.<br>
	 * Original signature : <code>int LLVMPointerSizeForAS(LLVMTargetDataRef, unsigned)</code>
	 */
	public static int LLVMPointerSizeForAS(LLVMLibrary.LLVMTargetDataRef TD, int AS) {
		return LLVMPointerSizeForAS(Pointer.getPeer(TD), AS);
	}
	protected native static int LLVMPointerSizeForAS(@Ptr long TD, int AS);
	/**
	 * Returns the integer type that is the same size as a pointer on a target.<br>
	 * See the method llvm::DataLayout::getIntPtrType.<br>
	 * Original signature : <code>LLVMTypeRef LLVMIntPtrType(LLVMTargetDataRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMIntPtrType(LLVMLibrary.LLVMTargetDataRef TD) {
		return new LLVMLibrary.LLVMTypeRef(LLVMIntPtrType(Pointer.getPeer(TD)));
	}
	@Ptr 
	protected native static long LLVMIntPtrType(@Ptr long TD);
	/**
	 * Returns the integer type that is the same size as a pointer on a target.<br>
	 * This version allows the address space to be specified.<br>
	 * See the method llvm::DataLayout::getIntPtrType.<br>
	 * Original signature : <code>LLVMTypeRef LLVMIntPtrTypeForAS(LLVMTargetDataRef, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMIntPtrTypeForAS(LLVMLibrary.LLVMTargetDataRef TD, int AS) {
		return new LLVMLibrary.LLVMTypeRef(LLVMIntPtrTypeForAS(Pointer.getPeer(TD), AS));
	}
	@Ptr 
	protected native static long LLVMIntPtrTypeForAS(@Ptr long TD, int AS);
	/**
	 * Returns the integer type that is the same size as a pointer on a target.<br>
	 * See the method llvm::DataLayout::getIntPtrType.<br>
	 * Original signature : <code>LLVMTypeRef LLVMIntPtrTypeInContext(LLVMContextRef, LLVMTargetDataRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMIntPtrTypeInContext(LLVMLibrary.LLVMContextRef C, LLVMLibrary.LLVMTargetDataRef TD) {
		return new LLVMLibrary.LLVMTypeRef(LLVMIntPtrTypeInContext(Pointer.getPeer(C), Pointer.getPeer(TD)));
	}
	@Ptr 
	protected native static long LLVMIntPtrTypeInContext(@Ptr long C, @Ptr long TD);
	/**
	 * Returns the integer type that is the same size as a pointer on a target.<br>
	 * This version allows the address space to be specified.<br>
	 * See the method llvm::DataLayout::getIntPtrType.<br>
	 * Original signature : <code>LLVMTypeRef LLVMIntPtrTypeForASInContext(LLVMContextRef, LLVMTargetDataRef, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMIntPtrTypeForASInContext(LLVMLibrary.LLVMContextRef C, LLVMLibrary.LLVMTargetDataRef TD, int AS) {
		return new LLVMLibrary.LLVMTypeRef(LLVMIntPtrTypeForASInContext(Pointer.getPeer(C), Pointer.getPeer(TD), AS));
	}
	@Ptr 
	protected native static long LLVMIntPtrTypeForASInContext(@Ptr long C, @Ptr long TD, int AS);
	/**
	 * Computes the size of a type in bytes for a target.<br>
	 * See the method llvm::DataLayout::getTypeSizeInBits.<br>
	 * Original signature : <code>long long LLVMSizeOfTypeInBits(LLVMTargetDataRef, LLVMTypeRef)</code>
	 */
	public static long LLVMSizeOfTypeInBits(LLVMLibrary.LLVMTargetDataRef TD, LLVMLibrary.LLVMTypeRef Ty) {
		return LLVMSizeOfTypeInBits(Pointer.getPeer(TD), Pointer.getPeer(Ty));
	}
	protected native static long LLVMSizeOfTypeInBits(@Ptr long TD, @Ptr long Ty);
	/**
	 * Computes the storage size of a type in bytes for a target.<br>
	 * See the method llvm::DataLayout::getTypeStoreSize.<br>
	 * Original signature : <code>long long LLVMStoreSizeOfType(LLVMTargetDataRef, LLVMTypeRef)</code>
	 */
	public static long LLVMStoreSizeOfType(LLVMLibrary.LLVMTargetDataRef TD, LLVMLibrary.LLVMTypeRef Ty) {
		return LLVMStoreSizeOfType(Pointer.getPeer(TD), Pointer.getPeer(Ty));
	}
	protected native static long LLVMStoreSizeOfType(@Ptr long TD, @Ptr long Ty);
	/**
	 * Computes the ABI size of a type in bytes for a target.<br>
	 * See the method llvm::DataLayout::getTypeAllocSize.<br>
	 * Original signature : <code>long long LLVMABISizeOfType(LLVMTargetDataRef, LLVMTypeRef)</code>
	 */
	public static long LLVMABISizeOfType(LLVMLibrary.LLVMTargetDataRef TD, LLVMLibrary.LLVMTypeRef Ty) {
		return LLVMABISizeOfType(Pointer.getPeer(TD), Pointer.getPeer(Ty));
	}
	protected native static long LLVMABISizeOfType(@Ptr long TD, @Ptr long Ty);
	/**
	 * Computes the ABI alignment of a type in bytes for a target.<br>
	 * See the method llvm::DataLayout::getTypeABISize.<br>
	 * Original signature : <code>int LLVMABIAlignmentOfType(LLVMTargetDataRef, LLVMTypeRef)</code>
	 */
	public static int LLVMABIAlignmentOfType(LLVMLibrary.LLVMTargetDataRef TD, LLVMLibrary.LLVMTypeRef Ty) {
		return LLVMABIAlignmentOfType(Pointer.getPeer(TD), Pointer.getPeer(Ty));
	}
	protected native static int LLVMABIAlignmentOfType(@Ptr long TD, @Ptr long Ty);
	/**
	 * Computes the call frame alignment of a type in bytes for a target.<br>
	 * See the method llvm::DataLayout::getTypeABISize.<br>
	 * Original signature : <code>int LLVMCallFrameAlignmentOfType(LLVMTargetDataRef, LLVMTypeRef)</code>
	 */
	public static int LLVMCallFrameAlignmentOfType(LLVMLibrary.LLVMTargetDataRef TD, LLVMLibrary.LLVMTypeRef Ty) {
		return LLVMCallFrameAlignmentOfType(Pointer.getPeer(TD), Pointer.getPeer(Ty));
	}
	protected native static int LLVMCallFrameAlignmentOfType(@Ptr long TD, @Ptr long Ty);
	/**
	 * Computes the preferred alignment of a type in bytes for a target.<br>
	 * See the method llvm::DataLayout::getTypeABISize.<br>
	 * Original signature : <code>int LLVMPreferredAlignmentOfType(LLVMTargetDataRef, LLVMTypeRef)</code>
	 */
	public static int LLVMPreferredAlignmentOfType(LLVMLibrary.LLVMTargetDataRef TD, LLVMLibrary.LLVMTypeRef Ty) {
		return LLVMPreferredAlignmentOfType(Pointer.getPeer(TD), Pointer.getPeer(Ty));
	}
	protected native static int LLVMPreferredAlignmentOfType(@Ptr long TD, @Ptr long Ty);
	/**
	 * Computes the preferred alignment of a global variable in bytes for a target.<br>
	 * See the method llvm::DataLayout::getPreferredAlignment.<br>
	 * Original signature : <code>int LLVMPreferredAlignmentOfGlobal(LLVMTargetDataRef, LLVMValueRef)</code>
	 */
	public static int LLVMPreferredAlignmentOfGlobal(LLVMLibrary.LLVMTargetDataRef TD, LLVMLibrary.LLVMValueRef GlobalVar) {
		return LLVMPreferredAlignmentOfGlobal(Pointer.getPeer(TD), Pointer.getPeer(GlobalVar));
	}
	protected native static int LLVMPreferredAlignmentOfGlobal(@Ptr long TD, @Ptr long GlobalVar);
	/**
	 * Computes the structure element that contains the byte offset for a target.<br>
	 * See the method llvm::StructLayout::getElementContainingOffset.<br>
	 * Original signature : <code>int LLVMElementAtOffset(LLVMTargetDataRef, LLVMTypeRef, unsigned long long)</code>
	 */
	public static int LLVMElementAtOffset(LLVMLibrary.LLVMTargetDataRef TD, LLVMLibrary.LLVMTypeRef StructTy, long Offset) {
		return LLVMElementAtOffset(Pointer.getPeer(TD), Pointer.getPeer(StructTy), Offset);
	}
	protected native static int LLVMElementAtOffset(@Ptr long TD, @Ptr long StructTy, long Offset);
	/**
	 * Computes the byte offset of the indexed struct element for a target.<br>
	 * See the method llvm::StructLayout::getElementContainingOffset.<br>
	 * Original signature : <code>long long LLVMOffsetOfElement(LLVMTargetDataRef, LLVMTypeRef, unsigned)</code>
	 */
	public static long LLVMOffsetOfElement(LLVMLibrary.LLVMTargetDataRef TD, LLVMLibrary.LLVMTypeRef StructTy, int Element) {
		return LLVMOffsetOfElement(Pointer.getPeer(TD), Pointer.getPeer(StructTy), Element);
	}
	protected native static long LLVMOffsetOfElement(@Ptr long TD, @Ptr long StructTy, int Element);
	public static class LLVMContextRef extends TypedPointer {
		public LLVMContextRef(long address) {
			super(address);
		}
		public LLVMContextRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMObjectFileRef extends TypedPointer {
		public LLVMObjectFileRef(long address) {
			super(address);
		}
		public LLVMObjectFileRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMSymbolIteratorRef extends TypedPointer {
		public LLVMSymbolIteratorRef(long address) {
			super(address);
		}
		public LLVMSymbolIteratorRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMValueRef extends TypedPointer {
		public LLVMValueRef(long address) {
			super(address);
		}
		public LLVMValueRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMPassManagerRef extends TypedPointer {
		public LLVMPassManagerRef(long address) {
			super(address);
		}
		public LLVMPassManagerRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMRelocationIteratorRef extends TypedPointer {
		public LLVMRelocationIteratorRef(long address) {
			super(address);
		}
		public LLVMRelocationIteratorRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMTypeRef extends TypedPointer {
		public LLVMTypeRef(long address) {
			super(address);
		}
		public LLVMTypeRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMModuleRef extends TypedPointer {
		public LLVMModuleRef(long address) {
			super(address);
		}
		public LLVMModuleRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMGenericValueRef extends TypedPointer {
		public LLVMGenericValueRef(long address) {
			super(address);
		}
		public LLVMGenericValueRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMPassManagerBuilderRef extends TypedPointer {
		public LLVMPassManagerBuilderRef(long address) {
			super(address);
		}
		public LLVMPassManagerBuilderRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMExecutionEngineRef extends TypedPointer {
		public LLVMExecutionEngineRef(long address) {
			super(address);
		}
		public LLVMExecutionEngineRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMTargetLibraryInfoRef extends TypedPointer {
		public LLVMTargetLibraryInfoRef(long address) {
			super(address);
		}
		public LLVMTargetLibraryInfoRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMMemoryBufferRef extends TypedPointer {
		public LLVMMemoryBufferRef(long address) {
			super(address);
		}
		public LLVMMemoryBufferRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMSectionIteratorRef extends TypedPointer {
		public LLVMSectionIteratorRef(long address) {
			super(address);
		}
		public LLVMSectionIteratorRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMPassRegistryRef extends TypedPointer {
		public LLVMPassRegistryRef(long address) {
			super(address);
		}
		public LLVMPassRegistryRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMMCJITMemoryManagerRef extends TypedPointer {
		public LLVMMCJITMemoryManagerRef(long address) {
			super(address);
		}
		public LLVMMCJITMemoryManagerRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMTargetDataRef extends TypedPointer {
		public LLVMTargetDataRef(long address) {
			super(address);
		}
		public LLVMTargetDataRef(Pointer address) {
			super(address);
		}
	};
	/** Undefined type */
	public static interface LLVMOpaqueRelocationIterator {
		
	};
	/** Undefined type */
	public static interface LLVMOpaqueTargetData {
		
	};
	/** Undefined type */
	public static interface LLVMOpaquePassManager {
		
	};
	/** Undefined type */
	public static interface LLVMOpaqueTargetLibraryInfotData {
		
	};
	/** Undefined type */
	public static interface LLVMOpaqueMemoryBuffer {
		
	};
	/** Undefined type */
	public static interface LLVMOpaqueGenericValue {
		
	};
	/** Undefined type */
	public static interface LLVMOpaqueMCJITMemoryManager {
		
	};
	/** Undefined type */
	public static interface LLVMOpaqueValue {
		
	};
	/** Undefined type */
	public static interface LLVMTargetMachineRef {
		
	};
	/** Undefined type */
	public static interface LLVMOpaquePassManagerBuilder {
		
	};
	/** Undefined type */
	public static interface LLVMOpaqueModule {
		
	};
	/** Undefined type */
	public static interface LLVMOpaqueType {
		
	};
	/** Undefined type */
	public static interface LLVMOpaqueSymbolIterator {
		
	};
	/** Undefined type */
	public static interface LLVMCodeModel {
		
	};
	/** Undefined type */
	public static interface LLVMOpaqueContext {
		
	};
	/** Undefined type */
	public static interface LLVMOpaqueObjectFile {
		
	};
	/** Undefined type */
	public static interface LLVMOpaqueExecutionEngine {
		
	};
	/** Undefined type */
	public static interface LLVMOpaquePassRegistry {
		
	};
	/** Undefined type */
	public static interface LLVMOpaqueSectionIterator {
		
	};
}
